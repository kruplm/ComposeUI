(function () {
    'use strict';

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  Namespace
     *
     * */
    /**
     * Shared Highcharts properties.
     * @private
     */
    var Globals;
    (function (Globals) {
        /* *
         *
         *  Constants
         *
         * */
        Globals.SVG_NS = 'http://www.w3.org/2000/svg', Globals.product = 'Highcharts', Globals.version = '@product.version@', Globals.win = (typeof window !== 'undefined' ?
            window :
            {}), // eslint-disable-line node/no-unsupported-features/es-builtins
        Globals.doc = Globals.win.document, Globals.svg = (Globals.doc &&
            Globals.doc.createElementNS &&
            !!Globals.doc.createElementNS(Globals.SVG_NS, 'svg').createSVGRect), Globals.userAgent = (Globals.win.navigator && Globals.win.navigator.userAgent) || '', Globals.isChrome = Globals.win.chrome, Globals.isFirefox = Globals.userAgent.indexOf('Firefox') !== -1, Globals.isMS = /(edge|msie|trident)/i.test(Globals.userAgent) && !Globals.win.opera, Globals.isSafari = !Globals.isChrome && Globals.userAgent.indexOf('Safari') !== -1, Globals.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals.userAgent), Globals.isWebKit = Globals.userAgent.indexOf('AppleWebKit') !== -1, Globals.deg2rad = Math.PI * 2 / 360, Globals.hasBidiBug = (Globals.isFirefox &&
            parseInt(Globals.userAgent.split('Firefox/')[1], 10) < 4 // Issue #38
        ), Globals.marginNames = [
            'plotTop',
            'marginRight',
            'marginBottom',
            'plotLeft'
        ], Globals.noop = function () { }, Globals.supportsPassiveEvents = (function () {
            // Checks whether the browser supports passive events, (#11353).
            let supportsPassive = false;
            // Object.defineProperty doesn't work on IE as well as passive
            // events - instead of using polyfill, we can exclude IE totally.
            if (!Globals.isMS) {
                const opts = Object.defineProperty({}, 'passive', {
                    get: function () {
                        supportsPassive = true;
                    }
                });
                if (Globals.win.addEventListener && Globals.win.removeEventListener) {
                    Globals.win.addEventListener('testPassive', Globals.noop, opts);
                    Globals.win.removeEventListener('testPassive', Globals.noop, opts);
                }
            }
            return supportsPassive;
        }());
        /**
         * An array containing the current chart objects in the page. A chart's
         * position in the array is preserved throughout the page's lifetime. When
         * a chart is destroyed, the array item becomes `undefined`.
         *
         * @name Highcharts.charts
         * @type {Array<Highcharts.Chart|undefined>}
         */
        Globals.charts = [];
        /**
         * A shared registry between all bundles to keep track of applied
         * compositions.
         * @private
         */
        Globals.composed = [];
        /**
         * A hook for defining additional date format specifiers. New
         * specifiers are defined as key-value pairs by using the
         * specifier as key, and a function which takes the timestamp as
         * value. This function returns the formatted portion of the
         * date.
         *
         * @sample highcharts/global/dateformats/
         *         Adding support for week number
         *
         * @name Highcharts.dateFormats
         * @type {Record<string, Highcharts.TimeFormatCallbackFunction>}
         */
        Globals.dateFormats = {};
        /**
         * @private
         * @deprecated
         * @todo Use only `Core/Series/SeriesRegistry.seriesTypes`
         */
        Globals.seriesTypes = {};
        /**
         * @private
         */
        Globals.symbolSizes = {};
        /* *
         *
         *  Properties
         *
         * */
        // eslint-disable-next-line prefer-const
        Globals.chartCount = 0;
    })(Globals || (Globals = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var H = Globals;

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { charts: charts$2, doc: doc$4, win: win$8 } = H;
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Provide error messages for debugging, with links to online explanation. This
     * function can be overridden to provide custom error handling.
     *
     * @sample highcharts/chart/highcharts-error/
     *         Custom error handler
     *
     * @function Highcharts.error
     *
     * @param {number|string} code
     *        The error code. See
     *        [errors.xml](https://github.com/highcharts/highcharts/blob/master/errors/errors.xml)
     *        for available codes. If it is a string, the error message is printed
     *        directly in the console.
     *
     * @param {boolean} [stop=false]
     *        Whether to throw an error or just log a warning in the console.
     *
     * @param {Highcharts.Chart} [chart]
     *        Reference to the chart that causes the error. Used in 'debugger'
     *        module to display errors directly on the chart.
     *        Important note: This argument is undefined for errors that lack
     *        access to the Chart instance. In such case, the error will be
     *        displayed on the last created chart.
     *
     * @param {Highcharts.Dictionary<string>} [params]
     *        Additional parameters for the generated message.
     *
     * @return {void}
     */
    function error$5(code, stop, chart, params) {
        const severity = stop ? 'Highcharts error' : 'Highcharts warning';
        if (code === 32) {
            code = `${severity}: Deprecated member`;
        }
        const isCode = isNumber$e(code);
        let message = isCode ?
            `${severity} #${code}: www.highcharts.com/errors/${code}/` :
            code.toString();
        const defaultHandler = function () {
            if (stop) {
                throw new Error(message);
            }
            // Else ...
            if (win$8.console &&
                error$5.messages.indexOf(message) === -1 // Prevent console flooting
            ) {
                console.warn(message); // eslint-disable-line no-console
            }
        };
        if (typeof params !== 'undefined') {
            let additionalMessages = '';
            if (isCode) {
                message += '?';
            }
            objectEach$c(params, function (value, key) {
                additionalMessages += `\n - ${key}: ${value}`;
                if (isCode) {
                    message += encodeURI(key) + '=' + encodeURI(value);
                }
            });
            message += additionalMessages;
        }
        fireEvent$9(H, 'displayError', { chart, code, message, params }, defaultHandler);
        error$5.messages.push(message);
    }
    (function (error) {
        error.messages = [];
    })(error$5 || (error$5 = {}));
    /* eslint-disable valid-jsdoc */
    /**
     * Utility function to deep merge two or more objects and return a third object.
     * If the first argument is true, the contents of the second object is copied
     * into the first object. The merge function can also be used with a single
     * object argument to create a deep copy of an object.
     *
     * @function Highcharts.merge<T>
     *
     * @param {boolean} extend
     *        Whether to extend the left-side object (a) or return a whole new
     *        object.
     *
     * @param {T|undefined} a
     *        The first object to extend. When only this is given, the function
     *        returns a deep copy.
     *
     * @param {...Array<object|undefined>} [n]
     *        An object to merge into the previous one.
     *
     * @return {T}
     *         The merged object. If the first argument is true, the return is the
     *         same as the second argument.
     */ /**
    * Utility function to deep merge two or more objects and return a third object.
    * The merge function can also be used with a single object argument to create a
    * deep copy of an object.
    *
    * @function Highcharts.merge<T>
    *
    * @param {T|undefined} a
    *        The first object to extend. When only this is given, the function
    *        returns a deep copy.
    *
    * @param {...Array<object|undefined>} [n]
    *        An object to merge into the previous one.
    *
    * @return {T}
    *         The merged object. If the first argument is true, the return is the
    *         same as the second argument.
    */
    function merge$f() {
        /* eslint-enable valid-jsdoc */
        let i, args = arguments, ret = {};
        const doCopy = function (copy, original) {
            // An object is replacing a primitive
            if (typeof copy !== 'object') {
                copy = {};
            }
            objectEach$c(original, function (value, key) {
                // Prototype pollution (#14883)
                if (key === '__proto__' || key === 'constructor') {
                    return;
                }
                // Copy the contents of objects, but not arrays or DOM nodes
                if (isObject$7(value, true) &&
                    !isClass(value) &&
                    !isDOMElement(value)) {
                    copy[key] = doCopy(copy[key] || {}, value);
                    // Primitives and arrays are copied over directly
                }
                else {
                    copy[key] = original[key];
                }
            });
            return copy;
        };
        // If first argument is true, copy into the existing object. Used in
        // setOptions.
        if (args[0] === true) {
            ret = args[1];
            args = Array.prototype.slice.call(args, 2);
        }
        // For each argument, extend the return
        const len = args.length;
        for (i = 0; i < len; i++) {
            ret = doCopy(ret, args[i]);
        }
        return ret;
    }
    /**
     * Constrain a value to within a lower and upper threshold.
     *
     * @private
     * @param {number} value The initial value
     * @param {number} min The lower threshold
     * @param {number} max The upper threshold
     * @return {number} Returns a number value within min and max.
     */
    function clamp$4(value, min, max) {
        return value > min ? value < max ? value : max : min;
    }
    /**
     * Utility for crisping a line position to the nearest full pixel depening on
     * the line width
     * @param {number} value       The raw pixel position
     * @param {number} lineWidth   The line width
     * @param {boolean} [inverted] Whether the containing group is inverted.
     *                             Crisping round numbers on the y-scale need to go
     *                             to the other side because the coordinate system
     *                             is flipped (scaleY is -1)
     * @return {number}            The pixel position to use for a crisp display
     */
    const crisp$5 = (value, lineWidth = 0, inverted) => {
        const mod = lineWidth % 2 / 2, inverter = inverted ? -1 : 1;
        return (Math.round(value * inverter - mod) + mod) * inverter;
    };
    // eslint-disable-next-line valid-jsdoc
    /**
     * Return the deep difference between two objects. It can either return the new
     * properties, or optionally return the old values of new properties.
     * @private
     */
    function diffObjects$2(newer, older, keepOlder, collectionsWithUpdate) {
        const ret = {};
        /**
         * Recurse over a set of options and its current values, and store the
         * current values in the ret object.
         */
        function diff(newer, older, ret, depth) {
            const keeper = keepOlder ? older : newer;
            objectEach$c(newer, function (newerVal, key) {
                if (!depth &&
                    collectionsWithUpdate &&
                    collectionsWithUpdate.indexOf(key) > -1 &&
                    older[key]) {
                    newerVal = splat$5(newerVal);
                    ret[key] = [];
                    // Iterate over collections like series, xAxis or yAxis and map
                    // the items by index.
                    for (let i = 0; i < Math.max(newerVal.length, older[key].length); i++) {
                        // Item exists in current data (#6347)
                        if (older[key][i]) {
                            // If the item is missing from the new data, we need to
                            // save the whole config structure. Like when
                            // responsively updating from a dual axis layout to a
                            // single axis and back (#13544).
                            if (newerVal[i] === void 0) {
                                ret[key][i] = older[key][i];
                                // Otherwise, proceed
                            }
                            else {
                                ret[key][i] = {};
                                diff(newerVal[i], older[key][i], ret[key][i], depth + 1);
                            }
                        }
                    }
                }
                else if (isObject$7(newerVal, true) &&
                    !newerVal.nodeType // #10044
                ) {
                    ret[key] = isArray$9(newerVal) ? [] : {};
                    diff(newerVal, older[key] || {}, ret[key], depth + 1);
                    // Delete empty nested objects
                    if (Object.keys(ret[key]).length === 0 &&
                        // Except colorAxis which is a special case where the empty
                        // object means it is enabled. Which is unfortunate and we
                        // should try to find a better way.
                        !(key === 'colorAxis' && depth === 0)) {
                        delete ret[key];
                    }
                }
                else if (newer[key] !== older[key] ||
                    // If the newer key is explicitly undefined, keep it (#10525)
                    (key in newer && !(key in older))) {
                    if (key !== '__proto__' && key !== 'constructor') {
                        ret[key] = keeper[key];
                    }
                }
            });
        }
        diff(newer, older, ret, 0);
        return ret;
    }
    /**
     * Shortcut for parseInt
     *
     * @private
     * @function Highcharts.pInt
     *
     * @param {*} s
     *        any
     *
     * @param {number} [mag]
     *        Magnitude
     *
     * @return {number}
     *         number
     */
    function pInt$5(s, mag) {
        return parseInt(s, mag || 10);
    }
    /**
     * Utility function to check for string type.
     *
     * @function Highcharts.isString
     *
     * @param {*} s
     *        The item to check.
     *
     * @return {boolean}
     *         True if the argument is a string.
     */
    function isString$7(s) {
        return typeof s === 'string';
    }
    /**
     * Utility function to check if an item is an array.
     *
     * @function Highcharts.isArray
     *
     * @param {*} obj
     *        The item to check.
     *
     * @return {boolean}
     *         True if the argument is an array.
     */
    function isArray$9(obj) {
        const str = Object.prototype.toString.call(obj);
        return str === '[object Array]' || str === '[object Array Iterator]';
    }
    /**
     * Utility function to check if an item is of type object.
     *
     * @function Highcharts.isObject
     *
     * @param {*} obj
     *        The item to check.
     *
     * @param {boolean} [strict=false]
     *        Also checks that the object is not an array.
     *
     * @return {boolean}
     *         True if the argument is an object.
     */
    function isObject$7(obj, strict) {
        return (!!obj &&
            typeof obj === 'object' &&
            (!strict || !isArray$9(obj))); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    /**
     * Utility function to check if an Object is a HTML Element.
     *
     * @function Highcharts.isDOMElement
     *
     * @param {*} obj
     *        The item to check.
     *
     * @return {boolean}
     *         True if the argument is a HTML Element.
     */
    function isDOMElement(obj) {
        return isObject$7(obj) && typeof obj.nodeType === 'number';
    }
    /**
     * Utility function to check if an Object is a class.
     *
     * @function Highcharts.isClass
     *
     * @param {object|undefined} obj
     *        The item to check.
     *
     * @return {boolean}
     *         True if the argument is a class.
     */
    function isClass(obj) {
        const c = obj && obj.constructor;
        return !!(isObject$7(obj, true) &&
            !isDOMElement(obj) &&
            (c && c.name && c.name !== 'Object'));
    }
    /**
     * Utility function to check if an item is a number and it is finite (not NaN,
     * Infinity or -Infinity).
     *
     * @function Highcharts.isNumber
     *
     * @param {*} n
     *        The item to check.
     *
     * @return {boolean}
     *         True if the item is a finite number
     */
    function isNumber$e(n) {
        return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;
    }
    /**
     * Remove the last occurence of an item from an array.
     *
     * @function Highcharts.erase
     *
     * @param {Array<*>} arr
     *        The array.
     *
     * @param {*} item
     *        The item to remove.
     *
     * @return {void}
     */
    function erase$5(arr, item) {
        let i = arr.length;
        while (i--) {
            if (arr[i] === item) {
                arr.splice(i, 1);
                break;
            }
        }
    }
    /**
     * Insert a series or an axis in a collection with other items, either the
     * chart series or yAxis series or axis collections, in the correct order
     * according to the index option and whether it is internal. Used internally
     * when adding series and axes.
     *
     * @private
     * @function Highcharts.Chart#insertItem
     * @param  {Highcharts.Series|Highcharts.Axis} item
     *         The item to insert
     * @param  {Array<Highcharts.Series>|Array<Highcharts.Axis>} collection
     *         A collection of items, like `chart.series` or `xAxis.series`.
     * @return {number} The index of the series in the collection.
     */
    function insertItem$2(item, collection) {
        const indexOption = item.options.index, length = collection.length;
        let i;
        for (
        // Internal item (navigator) should always be pushed to the end
        i = item.options.isInternal ? length : 0; i < length + 1; i++) {
            if (
            // No index option, reached the end of the collection,
            // equivalent to pushing
            !collection[i] ||
                // Handle index option, the element to insert has lower index
                (isNumber$e(indexOption) &&
                    indexOption < pick$f(collection[i].options.index, collection[i]._i)) ||
                // Insert the new item before other internal items
                // (navigator)
                collection[i].options.isInternal) {
                collection.splice(i, 0, item);
                break;
            }
        }
        return i;
    }
    /**
     * Adds an item to an array, if it is not present in the array.
     *
     * @function Highcharts.pushUnique
     *
     * @param {Array<unknown>} array
     * The array to add the item to.
     *
     * @param {unknown} item
     * The item to add.
     *
     * @return {boolean}
     * Returns true, if the item was not present and has been added.
     */
    function pushUnique$1(array, item) {
        return array.indexOf(item) < 0 && !!array.push(item);
    }
    /**
     * Check if an object is null or undefined.
     *
     * @function Highcharts.defined
     *
     * @param {*} obj
     *        The object to check.
     *
     * @return {boolean}
     *         False if the object is null or undefined, otherwise true.
     */
    function defined$b(obj) {
        return typeof obj !== 'undefined' && obj !== null;
    }
    /**
     * Set or get an attribute or an object of attributes.
     *
     * To use as a setter, pass a key and a value, or let the second argument be a
     * collection of keys and values. When using a collection, passing a value of
     * `null` or `undefined` will remove the attribute.
     *
     * To use as a getter, pass only a string as the second argument.
     *
     * @function Highcharts.attr
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} elem
     *        The DOM element to receive the attribute(s).
     *
     * @param {string|Highcharts.HTMLAttributes|Highcharts.SVGAttributes} [keyOrAttribs]
     *        The property or an object of key-value pairs.
     *
     * @param {number|string} [value]
     *        The value if a single property is set.
     *
     * @return {string|null|undefined}
     *         When used as a getter, return the value.
     */
    function attr$5(elem, keyOrAttribs, value) {
        const isGetter = isString$7(keyOrAttribs) && !defined$b(value);
        let ret;
        const attrSingle = (value, key) => {
            // Set the value
            if (defined$b(value)) {
                elem.setAttribute(key, value);
                // Get the value
            }
            else if (isGetter) {
                ret = elem.getAttribute(key);
                // IE7 and below cannot get class through getAttribute (#7850)
                if (!ret && key === 'class') {
                    ret = elem.getAttribute(key + 'Name');
                }
                // Remove the value
            }
            else {
                elem.removeAttribute(key);
            }
        };
        // If keyOrAttribs is a string
        if (isString$7(keyOrAttribs)) {
            attrSingle(value, keyOrAttribs);
            // Else if keyOrAttribs is defined, it is a hash of key/value pairs
        }
        else {
            objectEach$c(keyOrAttribs, attrSingle);
        }
        return ret;
    }
    /**
     * Check if an element is an array, and if not, make it into an array.
     *
     * @function Highcharts.splat
     *
     * @param {*} obj
     *        The object to splat.
     *
     * @return {Array}
     *         The produced or original array.
     */
    function splat$5(obj) {
        return isArray$9(obj) ? obj : [obj];
    }
    /**
     * Set a timeout if the delay is given, otherwise perform the function
     * synchronously.
     *
     * @function Highcharts.syncTimeout
     *
     * @param {Function} fn
     *        The function callback.
     *
     * @param {number} delay
     *        Delay in milliseconds.
     *
     * @param {*} [context]
     *        An optional context to send to the function callback.
     *
     * @return {number}
     *         An identifier for the timeout that can later be cleared with
     *         Highcharts.clearTimeout. Returns -1 if there is no timeout.
     */
    function syncTimeout$5(fn, delay, context) {
        if (delay > 0) {
            return setTimeout(fn, delay, context);
        }
        fn.call(0, context);
        return -1;
    }
    /**
     * Internal clear timeout. The function checks that the `id` was not removed
     * (e.g. by `chart.destroy()`). For the details see
     * [issue #7901](https://github.com/highcharts/highcharts/issues/7901).
     *
     * @function Highcharts.clearTimeout
     *
     * @param {number|undefined} id
     * Id of a timeout.
     */
    function internalClearTimeout(id) {
        if (defined$b(id)) {
            clearTimeout(id);
        }
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Utility function to extend an object with the members of another.
     *
     * @function Highcharts.extend<T>
     *
     * @param {T|undefined} a
     *        The object to be extended.
     *
     * @param {Partial<T>} b
     *        The object to add to the first one.
     *
     * @return {T}
     *         Object a, the original object.
     */
    function extend$e(a, b) {
        /* eslint-enable valid-jsdoc */
        let n;
        if (!a) {
            a = {};
        }
        for (n in b) { // eslint-disable-line guard-for-in
            a[n] = b[n];
        }
        return a;
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Return the first value that is not null or undefined.
     *
     * @function Highcharts.pick<T>
     *
     * @param {...Array<T|null|undefined>} items
     *        Variable number of arguments to inspect.
     *
     * @return {T}
     *         The value of the first argument that is not null or undefined.
     */
    function pick$f() {
        const args = arguments;
        const length = args.length;
        for (let i = 0; i < length; i++) {
            const arg = args[i];
            if (typeof arg !== 'undefined' && arg !== null) {
                return arg;
            }
        }
    }
    /**
     * Set CSS on a given element.
     *
     * @function Highcharts.css
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} el
     *        An HTML DOM element.
     *
     * @param {Highcharts.CSSObject} styles
     *        Style object with camel case property names.
     *
     * @return {void}
     */
    function css$4(el, styles) {
        extend$e(el.style, styles);
    }
    /**
     * Utility function to create an HTML element with attributes and styles.
     *
     * @function Highcharts.createElement
     *
     * @param {string} tag
     *        The HTML tag.
     *
     * @param {Highcharts.HTMLAttributes} [attribs]
     *        Attributes as an object of key-value pairs.
     *
     * @param {Highcharts.CSSObject} [styles]
     *        Styles as an object of key-value pairs.
     *
     * @param {Highcharts.HTMLDOMElement} [parent]
     *        The parent HTML object.
     *
     * @param {boolean} [nopad=false]
     *        If true, remove all padding, border and margin.
     *
     * @return {Highcharts.HTMLDOMElement}
     *         The created DOM element.
     */
    function createElement$4(tag, attribs, styles, parent, nopad) {
        const el = doc$4.createElement(tag);
        if (attribs) {
            extend$e(el, attribs);
        }
        if (nopad) {
            css$4(el, { padding: '0', border: 'none', margin: '0' });
        }
        if (styles) {
            css$4(el, styles);
        }
        if (parent) {
            parent.appendChild(el);
        }
        return el;
    }
    // eslint-disable-next-line valid-jsdoc
    /**
     * Extend a prototyped class by new members.
     *
     * @deprecated
     * @function Highcharts.extendClass<T>
     *
     * @param {Highcharts.Class<T>} parent
     *        The parent prototype to inherit.
     *
     * @param {Highcharts.Dictionary<*>} members
     *        A collection of prototype members to add or override compared to the
     *        parent prototype.
     *
     * @return {Highcharts.Class<T>}
     *         A new prototype.
     */
    function extendClass$1(parent, members) {
        const obj = (function () { });
        obj.prototype = new parent(); // eslint-disable-line new-cap
        extend$e(obj.prototype, members);
        return obj;
    }
    /**
     * Left-pad a string to a given length by adding a character repetitively.
     *
     * @function Highcharts.pad
     *
     * @param {number} number
     *        The input string or number.
     *
     * @param {number} [length]
     *        The desired string length.
     *
     * @param {string} [padder=0]
     *        The character to pad with.
     *
     * @return {string}
     *         The padded string.
     */
    function pad$1(number, length, padder) {
        return new Array((length || 2) +
            1 -
            String(number)
                .replace('-', '')
                .length).join(padder || '0') + number;
    }
    /**
     * Return a length based on either the integer value, or a percentage of a base.
     *
     * @function Highcharts.relativeLength
     *
     * @param {Highcharts.RelativeSize} value
     *        A percentage string or a number.
     *
     * @param {number} base
     *        The full length that represents 100%.
     *
     * @param {number} [offset=0]
     *        A pixel offset to apply for percentage values. Used internally in
     *        axis positioning.
     *
     * @return {number}
     *         The computed length.
     */
    function relativeLength$2(value, base, offset) {
        return (/%$/).test(value) ?
            (base * parseFloat(value) / 100) + (offset || 0) :
            parseFloat(value);
    }
    /**
     * Replaces text in a string with a given replacement in a loop to catch nested
     * matches after previous replacements.
     *
     * @function Highcharts.replaceNested
     *
     * @param {string} text
     * Text to search and modify.
     *
     * @param {...Array<(RegExp|string)>} replacements
     * One or multiple tuples with search pattern (`[0]: (string|RegExp)`) and
     * replacement (`[1]: string`) for matching text.
     *
     * @return {string}
     * Text with replacements.
     */
    function replaceNested$2(text, ...replacements) {
        let previous, replacement;
        do {
            previous = text;
            for (replacement of replacements) {
                text = text.replace(replacement[0], replacement[1]);
            }
        } while (text !== previous);
        return text;
    }
    /**
     * Wrap a method with extended functionality, preserving the original function.
     *
     * @function Highcharts.wrap
     *
     * @param {*} obj
     *        The context object that the method belongs to. In real cases, this is
     *        often a prototype.
     *
     * @param {string} method
     *        The name of the method to extend.
     *
     * @param {Highcharts.WrapProceedFunction} func
     *        A wrapper function callback. This function is called with the same
     *        arguments as the original function, except that the original function
     *        is unshifted and passed as the first argument.
     */
    function wrap(obj, method, func) {
        const proceed = obj[method];
        obj[method] = function () {
            const outerArgs = arguments, scope = this;
            return func.apply(this, [
                function () {
                    return proceed.apply(scope, arguments.length ? arguments : outerArgs);
                }
            ].concat([].slice.call(arguments)));
        };
    }
    /**
     * Get the magnitude of a number.
     *
     * @function Highcharts.getMagnitude
     *
     * @param {number} num
     *        The number.
     *
     * @return {number}
     *         The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2 etc.
     */
    function getMagnitude(num) {
        return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
    }
    /**
     * Take an interval and normalize it to multiples of round numbers.
     *
     * @deprecated
     * @function Highcharts.normalizeTickInterval
     *
     * @param {number} interval
     *        The raw, un-rounded interval.
     *
     * @param {Array<*>} [multiples]
     *        Allowed multiples.
     *
     * @param {number} [magnitude]
     *        The magnitude of the number.
     *
     * @param {boolean} [allowDecimals]
     *        Whether to allow decimals.
     *
     * @param {boolean} [hasTickAmount]
     *        If it has tickAmount, avoid landing on tick intervals lower than
     *        original.
     *
     * @return {number}
     *         The normalized interval.
     *
     * @todo
     * Move this function to the Axis prototype. It is here only for historical
     * reasons.
     */
    function normalizeTickInterval$1(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
        let i, retInterval = interval;
        // Round to a tenfold of 1, 2, 2.5 or 5
        magnitude = pick$f(magnitude, getMagnitude(interval));
        const normalized = interval / magnitude;
        // Multiples for a linear scale
        if (!multiples) {
            multiples = hasTickAmount ?
                // Finer grained ticks when the tick amount is hard set, including
                // when alignTicks is true on multiple axes (#4580).
                [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :
                // Else, let ticks fall on rounder numbers
                [1, 2, 2.5, 5, 10];
            // The allowDecimals option
            if (allowDecimals === false) {
                if (magnitude === 1) {
                    multiples = multiples.filter(function (num) {
                        return num % 1 === 0;
                    });
                }
                else if (magnitude <= 0.1) {
                    multiples = [1 / magnitude];
                }
            }
        }
        // Normalize the interval to the nearest multiple
        for (i = 0; i < multiples.length; i++) {
            retInterval = multiples[i];
            // Only allow tick amounts smaller than natural
            if ((hasTickAmount &&
                retInterval * magnitude >= interval) ||
                (!hasTickAmount &&
                    (normalized <=
                        (multiples[i] +
                            (multiples[i + 1] || multiples[i])) / 2))) {
                break;
            }
        }
        // Multiply back to the correct magnitude. Correct floats to appropriate
        // precision (#6085).
        retInterval = correctFloat$3(retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10));
        return retInterval;
    }
    /**
     * Sort an object array and keep the order of equal items. The ECMAScript
     * standard does not specify the behaviour when items are equal.
     *
     * @function Highcharts.stableSort
     *
     * @param {Array<*>} arr
     *        The array to sort.
     *
     * @param {Function} sortFunction
     *        The function to sort it with, like with regular Array.prototype.sort.
     */
    function stableSort(arr, sortFunction) {
        // @todo It seems like Chrome since v70 sorts in a stable way internally,
        // plus all other browsers do it, so over time we may be able to remove this
        // function
        const length = arr.length;
        let sortValue, i;
        // Add index to each item
        for (i = 0; i < length; i++) {
            arr[i].safeI = i; // Stable sort index
        }
        arr.sort(function (a, b) {
            sortValue = sortFunction(a, b);
            return sortValue === 0 ? a.safeI - b.safeI : sortValue;
        });
        // Remove index from items
        for (i = 0; i < length; i++) {
            delete arr[i].safeI; // Stable sort index
        }
    }
    /**
     * Non-recursive method to find the lowest member of an array. `Math.min` raises
     * a maximum call stack size exceeded error in Chrome when trying to apply more
     * than 150.000 points. This method is slightly slower, but safe.
     *
     * @function Highcharts.arrayMin
     *
     * @param {Array<*>} data
     *        An array of numbers.
     *
     * @return {number}
     *         The lowest number.
     */
    function arrayMin$2(data) {
        let i = data.length, min = data[0];
        while (i--) {
            if (data[i] < min) {
                min = data[i];
            }
        }
        return min;
    }
    /**
     * Non-recursive method to find the lowest member of an array. `Math.max` raises
     * a maximum call stack size exceeded error in Chrome when trying to apply more
     * than 150.000 points. This method is slightly slower, but safe.
     *
     * @function Highcharts.arrayMax
     *
     * @param {Array<*>} data
     *        An array of numbers.
     *
     * @return {number}
     *         The highest number.
     */
    function arrayMax$2(data) {
        let i = data.length, max = data[0];
        while (i--) {
            if (data[i] > max) {
                max = data[i];
            }
        }
        return max;
    }
    /**
     * Utility method that destroys any SVGElement instances that are properties on
     * the given object. It loops all properties and invokes destroy if there is a
     * destroy method. The property is then delete.
     *
     * @function Highcharts.destroyObjectProperties
     *
     * @param {*} obj
     *        The object to destroy properties on.
     *
     * @param {*} [except]
     *        Exception, do not destroy this property, only delete it.
     */
    function destroyObjectProperties$4(obj, except, destructablesOnly) {
        objectEach$c(obj, function (val, n) {
            // If the object is non-null and destroy is defined
            if (val !== except && val?.destroy) {
                // Invoke the destroy
                val.destroy();
            }
            // Delete the property from the object
            if (val?.destroy || !destructablesOnly) {
                delete obj[n];
            }
        });
    }
    /**
     * Discard a HTML element
     *
     * @function Highcharts.discardElement
     *
     * @param {Highcharts.HTMLDOMElement} element
     *        The HTML node to discard.
     */
    function discardElement$1(element) {
        if (element && element.parentElement) {
            element.parentElement.removeChild(element);
        }
    }
    /**
     * Fix JS round off float errors.
     *
     * @function Highcharts.correctFloat
     *
     * @param {number} num
     *        A float number to fix.
     *
     * @param {number} [prec=14]
     *        The precision.
     *
     * @return {number}
     *         The corrected float number.
     */
    function correctFloat$3(num, prec) {
        // When the number is higher than 1e14 use the number (#16275)
        return num > 1e14 ? num : parseFloat(num.toPrecision(prec || 14));
    }
    /**
     * The time unit lookup
     *
     * @ignore
     */
    const timeUnits$1 = {
        millisecond: 1,
        second: 1000,
        minute: 60000,
        hour: 3600000,
        day: 24 * 3600000,
        week: 7 * 24 * 3600000,
        month: 28 * 24 * 3600000,
        year: 364 * 24 * 3600000
    };
    /**
     * Easing definition
     *
     * @private
     * @function Math.easeInOutSine
     *
     * @param {number} pos
     *        Current position, ranging from 0 to 1.
     *
     * @return {number}
     *         Ease result
     */
    Math.easeInOutSine = function (pos) {
        return -0.5 * (Math.cos(Math.PI * pos) - 1);
    };
    /**
     * Find the closest distance between two values of a two-dimensional array
     * @private
     * @function Highcharts.getClosestDistance
     *
     * @param {Array<Array<number>>} arrays
     *          An array of arrays of numbers
     *
     * @return {number | undefined}
     *          The closest distance between values
     */
    function getClosestDistance$2(arrays, onError) {
        const allowNegative = !onError;
        let closest, loopLength, distance, i;
        arrays.forEach((xData) => {
            if (xData.length > 1) {
                loopLength = xData.length - 1;
                for (i = loopLength; i > 0; i--) {
                    distance = xData[i] - xData[i - 1];
                    if (distance < 0 && !allowNegative) {
                        onError?.();
                        // Only one call
                        onError = void 0;
                    }
                    else if (distance && (typeof closest === 'undefined' || distance < closest)) {
                        closest = distance;
                    }
                }
            }
        });
        return closest;
    }
    /**
     * Returns the value of a property path on a given object.
     *
     * @private
     * @function getNestedProperty
     *
     * @param {string} path
     * Path to the property, for example `custom.myValue`.
     *
     * @param {unknown} obj
     * Instance containing the property on the specific path.
     *
     * @return {unknown}
     * The unknown property value.
     */
    function getNestedProperty$3(path, parent) {
        const pathElements = path.split('.');
        while (pathElements.length && defined$b(parent)) {
            const pathElement = pathElements.shift();
            // Filter on the key
            if (typeof pathElement === 'undefined' ||
                pathElement === '__proto__') {
                return; // Undefined
            }
            if (pathElement === 'this') {
                let thisProp;
                if (isObject$7(parent)) {
                    thisProp = parent['@this'];
                }
                return thisProp ?? parent;
            }
            const child = parent[pathElement];
            // Filter on the child
            if (!defined$b(child) ||
                typeof child === 'function' ||
                typeof child.nodeType === 'number' ||
                child === win$8) {
                return; // Undefined
            }
            // Else, proceed
            parent = child;
        }
        return parent;
    }
    /**
     * Get the computed CSS value for given element and property, only for numerical
     * properties. For width and height, the dimension of the inner box (excluding
     * padding) is returned. Used for fitting the chart within the container.
     *
     * @function Highcharts.getStyle
     *
     * @param {Highcharts.HTMLDOMElement} el
     * An HTML element.
     *
     * @param {string} prop
     * The property name.
     *
     * @param {boolean} [toInt=true]
     * Parse to integer.
     *
     * @return {number|string|undefined}
     * The style value.
     */
    function getStyle$2(el, prop, toInt) {
        let style;
        // For width and height, return the actual inner pixel size (#4913)
        if (prop === 'width') {
            let offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
            // In flex boxes, we need to use getBoundingClientRect and floor it,
            // because scrollWidth doesn't support subpixel precision (#6427) ...
            const boundingClientRectWidth = el.getBoundingClientRect &&
                el.getBoundingClientRect().width;
            // ...unless if the containing div or its parents are transform-scaled
            // down, in which case the boundingClientRect can't be used as it is
            // also scaled down (#9871, #10498).
            if (boundingClientRectWidth < offsetWidth &&
                boundingClientRectWidth >= offsetWidth - 1) {
                offsetWidth = Math.floor(boundingClientRectWidth);
            }
            return Math.max(0, // #8377
            (offsetWidth -
                (getStyle$2(el, 'padding-left', true) || 0) -
                (getStyle$2(el, 'padding-right', true) || 0)));
        }
        if (prop === 'height') {
            return Math.max(0, // #8377
            (Math.min(el.offsetHeight, el.scrollHeight) -
                (getStyle$2(el, 'padding-top', true) || 0) -
                (getStyle$2(el, 'padding-bottom', true) || 0)));
        }
        // Otherwise, get the computed style
        const css = win$8.getComputedStyle(el, void 0); // eslint-disable-line no-undefined
        if (css) {
            style = css.getPropertyValue(prop);
            if (pick$f(toInt, prop !== 'opacity')) {
                style = pInt$5(style);
            }
        }
        return style;
    }
    /**
     * Search for an item in an array.
     *
     * @function Highcharts.inArray
     *
     * @deprecated
     *
     * @param {*} item
     *        The item to search for.
     *
     * @param {Array<*>} arr
     *        The array or node collection to search in.
     *
     * @param {number} [fromIndex=0]
     *        The index to start searching from.
     *
     * @return {number}
     *         The index within the array, or -1 if not found.
     */
    function inArray(item, arr, fromIndex) {
        error$5(32, false, void 0, { 'Highcharts.inArray': 'use Array.indexOf' });
        return arr.indexOf(item, fromIndex);
    }
    /**
     * Return the value of the first element in the array that satisfies the
     * provided testing function.
     *
     * @function Highcharts.find<T>
     *
     * @param {Array<T>} arr
     *        The array to test.
     *
     * @param {Function} callback
     *        The callback function. The function receives the item as the first
     *        argument. Return `true` if this item satisfies the condition.
     *
     * @return {T|undefined}
     *         The value of the element.
     */
    const find$2 = Array.prototype.find ?
        function (arr, callback) {
            return arr.find(callback);
        } :
        // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
        function (arr, callback) {
            let i;
            const length = arr.length;
            for (i = 0; i < length; i++) {
                if (callback(arr[i], i)) { // eslint-disable-line node/callback-return
                    return arr[i];
                }
            }
        };
    /**
     * Returns an array of a given object's own properties.
     *
     * @function Highcharts.keys
     * @deprecated
     *
     * @param {*} obj
     *        The object of which the properties are to be returned.
     *
     * @return {Array<string>}
     *         An array of strings that represents all the properties.
     */
    function keys(obj) {
        error$5(32, false, void 0, { 'Highcharts.keys': 'use Object.keys' });
        return Object.keys(obj);
    }
    /**
     * Get the element's offset position, corrected for `overflow: auto`.
     *
     * @function Highcharts.offset
     *
     * @param {global.Element} el
     *        The DOM element.
     *
     * @return {Highcharts.OffsetObject}
     *         An object containing `left` and `top` properties for the position in
     *         the page.
     */
    function offset(el) {
        const docElem = doc$4.documentElement, box = (el.parentElement || el.parentNode) ?
            el.getBoundingClientRect() :
            { top: 0, left: 0, width: 0, height: 0 };
        return {
            top: box.top + (win$8.pageYOffset || docElem.scrollTop) -
                (docElem.clientTop || 0),
            left: box.left + (win$8.pageXOffset || docElem.scrollLeft) -
                (docElem.clientLeft || 0),
            width: box.width,
            height: box.height
        };
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Iterate over object key pairs in an object.
     *
     * @function Highcharts.objectEach<T>
     *
     * @param {*} obj
     *        The object to iterate over.
     *
     * @param {Highcharts.ObjectEachCallbackFunction<T>} fn
     *        The iterator callback. It passes three arguments:
     *        * value - The property value.
     *        * key - The property key.
     *        * obj - The object that objectEach is being applied to.
     *
     * @param {T} [ctx]
     *        The context.
     */
    function objectEach$c(obj, fn, ctx) {
        /* eslint-enable valid-jsdoc */
        for (const key in obj) {
            if (Object.hasOwnProperty.call(obj, key)) {
                fn.call(ctx || obj[key], obj[key], key, obj);
            }
        }
    }
    /**
     * Iterate over an array.
     *
     * @deprecated
     * @function Highcharts.each
     *
     * @param {Array<*>} arr
     *        The array to iterate over.
     *
     * @param {Function} fn
     *        The iterator callback. It passes three arguments:
     *        - `item`: The array item.
     *        - `index`: The item's index in the array.
     *        - `arr`: The array that each is being applied to.
     *
     * @param {*} [ctx]
     *        The context.
     *
     * @return {void}
     */
    /**
     * Filter an array by a callback.
     *
     * @deprecated
     * @function Highcharts.grep
     *
     * @param {Array<*>} arr
     *        The array to filter.
     *
     * @param {Function} callback
     *        The callback function. The function receives the item as the first
     *        argument. Return `true` if the item is to be preserved.
     *
     * @return {Array<*>}
     *         A new, filtered array.
     */
    /**
     * Map an array by a callback.
     *
     * @deprecated
     * @function Highcharts.map
     *
     * @param {Array<*>} arr
     *        The array to map.
     *
     * @param {Function} fn
     *        The callback function. Return the new value for the new array.
     *
     * @return {Array<*>}
     *         A new array item with modified items.
     */
    /**
     * Reduce an array to a single value.
     *
     * @deprecated
     * @function Highcharts.reduce
     *
     * @param {Array<*>} arr
     *        The array to reduce.
     *
     * @param {Function} fn
     *        The callback function. Return the reduced value. Receives 4
     *        arguments: Accumulated/reduced value, current value, current array
     *        index, and the array.
     *
     * @param {*} initialValue
     *        The initial value of the accumulator.
     *
     * @return {*}
     *         The reduced value.
     */
    /**
     * Test whether at least one element in the array passes the test implemented by
     * the provided function.
     *
     * @deprecated
     * @function Highcharts.some
     *
     * @param {Array<*>} arr
     *        The array to test
     *
     * @param {Function} fn
     *        The function to run on each item. Return truthy to pass the test.
     *        Receives arguments `currentValue`, `index` and `array`.
     *
     * @param {*} ctx
     *        The context.
     *
     * @return {boolean}
     */
    objectEach$c({
        map: 'map',
        each: 'forEach',
        grep: 'filter',
        reduce: 'reduce',
        some: 'some'
    }, function (val, key) {
        H[key] = function (arr) {
            error$5(32, false, void 0, { [`Highcharts.${key}`]: `use Array.${val}` });
            return Array.prototype[val].apply(arr, [].slice.call(arguments, 1));
        };
    });
    /* eslint-disable valid-jsdoc */
    /**
     * Add an event listener.
     *
     * @function Highcharts.addEvent<T>
     *
     * @param  {Highcharts.Class<T>|T} el
     *         The element or object to add a listener to. It can be a
     *         {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
     *
     * @param  {string} type
     *         The event type.
     *
     * @param  {Highcharts.EventCallbackFunction<T>|Function} fn
     *         The function callback to execute when the event is fired.
     *
     * @param  {Highcharts.EventOptionsObject} [options]
     *         Options for adding the event.
     *
     * @sample highcharts/members/addevent
     *         Use a general `render` event to draw shapes on a chart
     *
     * @return {Function}
     *         A callback function to remove the added event.
     */
    function addEvent$5(el, type, fn, options = {}) {
        /* eslint-enable valid-jsdoc */
        // Add hcEvents to either the prototype (in case we're running addEvent on a
        // class) or the instance. If hasOwnProperty('hcEvents') is false, it is
        // inherited down the prototype chain, in which case we need to set the
        // property on this instance (which may itself be a prototype).
        const owner = typeof el === 'function' && el.prototype || el;
        if (!Object.hasOwnProperty.call(owner, 'hcEvents')) {
            owner.hcEvents = {};
        }
        const events = owner.hcEvents;
        // Allow click events added to points, otherwise they will be prevented by
        // the TouchPointer.pinch function after a pinch zoom operation (#7091).
        if (H.Point && // Without H a dependency loop occurs
            el instanceof H.Point &&
            el.series &&
            el.series.chart) {
            el.series.chart.runTrackerClick = true;
        }
        // Handle DOM events
        // If the browser supports passive events, add it to improve performance
        // on touch events (#11353).
        const addEventListener = el.addEventListener;
        if (addEventListener) {
            addEventListener.call(el, type, fn, H.supportsPassiveEvents ? {
                passive: options.passive === void 0 ?
                    type.indexOf('touch') !== -1 : options.passive,
                capture: false
            } : false);
        }
        if (!events[type]) {
            events[type] = [];
        }
        const eventObject = {
            fn,
            order: typeof options.order === 'number' ? options.order : Infinity
        };
        events[type].push(eventObject);
        // Order the calls
        events[type].sort((a, b) => a.order - b.order);
        // Return a function that can be called to remove this event.
        return function () {
            removeEvent$6(el, type, fn);
        };
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Remove an event that was added with {@link Highcharts#addEvent}.
     *
     * @function Highcharts.removeEvent<T>
     *
     * @param {Highcharts.Class<T>|T} el
     *        The element to remove events on.
     *
     * @param {string} [type]
     *        The type of events to remove. If undefined, all events are removed
     *        from the element.
     *
     * @param {Highcharts.EventCallbackFunction<T>} [fn]
     *        The specific callback to remove. If undefined, all events that match
     *        the element and optionally the type are removed.
     *
     * @return {void}
     */
    function removeEvent$6(el, type, fn) {
        /* eslint-enable valid-jsdoc */
        /**
         * @private
         */
        function removeOneEvent(type, fn) {
            const removeEventListener = el.removeEventListener;
            if (removeEventListener) {
                removeEventListener.call(el, type, fn, false);
            }
        }
        /**
         * @private
         */
        function removeAllEvents(eventCollection) {
            let types, len;
            if (!el.nodeName) {
                return; // Break on non-DOM events
            }
            if (type) {
                types = {};
                types[type] = true;
            }
            else {
                types = eventCollection;
            }
            objectEach$c(types, function (_val, n) {
                if (eventCollection[n]) {
                    len = eventCollection[n].length;
                    while (len--) {
                        removeOneEvent(n, eventCollection[n][len].fn);
                    }
                }
            });
        }
        const owner = typeof el === 'function' && el.prototype || el;
        if (Object.hasOwnProperty.call(owner, 'hcEvents')) {
            const events = owner.hcEvents;
            if (type) {
                const typeEvents = (events[type] || []);
                if (fn) {
                    events[type] = typeEvents.filter(function (obj) {
                        return fn !== obj.fn;
                    });
                    removeOneEvent(type, fn);
                }
                else {
                    removeAllEvents(events);
                    events[type] = [];
                }
            }
            else {
                removeAllEvents(events);
                delete owner.hcEvents;
            }
        }
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Fire an event that was registered with {@link Highcharts#addEvent}.
     *
     * @function Highcharts.fireEvent<T>
     *
     * @param {T} el
     *        The object to fire the event on. It can be a {@link HTMLDOMElement},
     *        an {@link SVGElement} or any other object.
     *
     * @param {string} type
     *        The type of event.
     *
     * @param {Highcharts.Dictionary<*>|Event} [eventArguments]
     *        Custom event arguments that are passed on as an argument to the event
     *        handler.
     *
     * @param {Highcharts.EventCallbackFunction<T>|Function} [defaultFunction]
     *        The default function to execute if the other listeners haven't
     *        returned false.
     *
     * @return {void}
     */
    function fireEvent$9(el, type, eventArguments, defaultFunction) {
        /* eslint-enable valid-jsdoc */
        eventArguments = eventArguments || {};
        if (doc$4.createEvent &&
            (el.dispatchEvent ||
                (el.fireEvent &&
                    // Enable firing events on Highcharts instance.
                    el !== H))) {
            const e = doc$4.createEvent('Events');
            e.initEvent(type, true, true);
            eventArguments = extend$e(e, eventArguments);
            if (el.dispatchEvent) {
                el.dispatchEvent(eventArguments);
            }
            else {
                el.fireEvent(type, eventArguments);
            }
        }
        else if (el.hcEvents) {
            if (!eventArguments.target) {
                // We're running a custom event
                extend$e(eventArguments, {
                    // Attach a simple preventDefault function to skip
                    // default handler if called. The built-in
                    // defaultPrevented property is not overwritable (#5112)
                    preventDefault: function () {
                        eventArguments.defaultPrevented = true;
                    },
                    // Setting target to native events fails with clicking
                    // the zoom-out button in Chrome.
                    target: el,
                    // If the type is not set, we're running a custom event
                    // (#2297). If it is set, we're running a browser event.
                    type: type
                });
            }
            const events = [];
            let object = el;
            let multilevel = false;
            // Recurse up the inheritance chain and collect hcEvents set as own
            // objects on the prototypes.
            while (object.hcEvents) {
                if (Object.hasOwnProperty.call(object, 'hcEvents') &&
                    object.hcEvents[type]) {
                    if (events.length) {
                        multilevel = true;
                    }
                    events.unshift.apply(events, object.hcEvents[type]);
                }
                object = Object.getPrototypeOf(object);
            }
            // For performance reasons, only sort the event handlers in case we are
            // dealing with multiple levels in the prototype chain. Otherwise, the
            // events are already sorted in the addEvent function.
            if (multilevel) {
                // Order the calls
                events.sort((a, b) => a.order - b.order);
            }
            // Call the collected event handlers
            events.forEach((obj) => {
                // If the event handler returns false, prevent the default handler
                // from executing
                if (obj.fn.call(el, eventArguments) === false) {
                    eventArguments.preventDefault();
                }
            });
        }
        // Run the default if not prevented
        if (defaultFunction && !eventArguments.defaultPrevented) {
            defaultFunction.call(el, eventArguments);
        }
    }
    let serialMode;
    /**
     * Get a unique key for using in internal element id's and pointers. The key is
     * composed of a random hash specific to this Highcharts instance, and a
     * counter.
     *
     * @example
     * let id = uniqueKey(); // => 'highcharts-x45f6hp-0'
     *
     * @function Highcharts.uniqueKey
     *
     * @return {string}
     * A unique key.
     */
    const uniqueKey$4 = (function () {
        const hash = Math.random().toString(36).substring(2, 9) + '-';
        let id = 0;
        return function () {
            return 'highcharts-' + (serialMode ? '' : hash) + id++;
        };
    }());
    /**
     * Activates a serial mode for element IDs provided by
     * {@link Highcharts.uniqueKey}. This mode can be used in automated tests, where
     * a simple comparison of two rendered SVG graphics is needed.
     *
     * **Note:** This is only for testing purposes and will break functionality in
     * webpages with multiple charts.
     *
     * @example
     * if (
     *   process &&
     *   process.env.NODE_ENV === 'development'
     * ) {
     *   Highcharts.useSerialIds(true);
     * }
     *
     * @function Highcharts.useSerialIds
     *
     * @param {boolean} [mode]
     * Changes the state of serial mode.
     *
     * @return {boolean|undefined}
     * State of the serial mode.
     */
    function useSerialIds(mode) {
        return (serialMode = pick$f(mode, serialMode));
    }
    function isFunction$4(obj) {
        return typeof obj === 'function';
    }
    // Register Highcharts as a plugin in jQuery
    if (win$8.jQuery) {
        /**
         * Highcharts-extended JQuery.
         *
         * @external JQuery
         */
        /**
         * Helper function to return the chart of the current JQuery selector
         * element.
         *
         * @function external:JQuery#highcharts
         *
         * @return {Highcharts.Chart}
         *         The chart that is linked to the JQuery selector element.
         */ /**
        * Factory function to create a chart in the current JQuery selector
        * element.
        *
        * @function external:JQuery#highcharts
        *
        * @param {'Chart'|'Map'|'StockChart'|string} [className]
        *        Name of the factory class in the Highcharts namespace.
        *
        * @param {Highcharts.Options} [options]
        *        The chart options structure.
        *
        * @param {Highcharts.ChartCallbackFunction} [callback]
        *        Function to run when the chart has loaded and all external
        *        images are loaded. Defining a
        *        [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)
        *        handler is equivalent.
        *
        * @return {JQuery}
        *         The current JQuery selector.
        */
        win$8.jQuery.fn.highcharts = function () {
            const args = [].slice.call(arguments);
            if (this[0]) { // `this[0]` is the renderTo div
                // Create the chart
                if (args[0]) {
                    new H[ // eslint-disable-line computed-property-spacing, no-new
                    // Constructor defaults to Chart
                    isString$7(args[0]) ? args.shift() : 'Chart'](this[0], args[0], args[1]);
                    return this;
                }
                // When called without parameters or with the return argument,
                // return an existing chart
                return charts$2[attr$5(this[0], 'data-highcharts-chart')];
            }
        };
    }
    /* *
     *
     *  Default Export
     *
     * */
    // TODO use named exports when supported.
    const Utilities = {
        addEvent: addEvent$5,
        arrayMax: arrayMax$2,
        arrayMin: arrayMin$2,
        attr: attr$5,
        clamp: clamp$4,
        clearTimeout: internalClearTimeout,
        correctFloat: correctFloat$3,
        createElement: createElement$4,
        crisp: crisp$5,
        css: css$4,
        defined: defined$b,
        destroyObjectProperties: destroyObjectProperties$4,
        diffObjects: diffObjects$2,
        discardElement: discardElement$1,
        erase: erase$5,
        error: error$5,
        extend: extend$e,
        extendClass: extendClass$1,
        find: find$2,
        fireEvent: fireEvent$9,
        getClosestDistance: getClosestDistance$2,
        getMagnitude,
        getNestedProperty: getNestedProperty$3,
        getStyle: getStyle$2,
        inArray,
        insertItem: insertItem$2,
        isArray: isArray$9,
        isClass,
        isDOMElement,
        isFunction: isFunction$4,
        isNumber: isNumber$e,
        isObject: isObject$7,
        isString: isString$7,
        keys,
        merge: merge$f,
        normalizeTickInterval: normalizeTickInterval$1,
        objectEach: objectEach$c,
        offset,
        pad: pad$1,
        pick: pick$f,
        pInt: pInt$5,
        pushUnique: pushUnique$1,
        relativeLength: relativeLength$2,
        removeEvent: removeEvent$6,
        replaceNested: replaceNested$2,
        splat: splat$5,
        stableSort,
        syncTimeout: syncTimeout$5,
        timeUnits: timeUnits$1,
        uniqueKey: uniqueKey$4,
        useSerialIds,
        wrap
    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { isNumber: isNumber$d, merge: merge$e, pInt: pInt$4 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable valid-jsdoc */
    /**
     * Handle color operations. Some object methods are chainable.
     *
     * @class
     * @name Highcharts.Color
     *
     * @param {Highcharts.ColorType} input
     * The input color in either rgba or hex format
     */
    class Color {
        /* *
         *
         *  Static Functions
         *
         * */
        /**
         * Creates a color instance out of a color string or object.
         *
         * @function Highcharts.Color.parse
         *
         * @param {Highcharts.ColorType} [input]
         * The input color in either rgba or hex format.
         *
         * @return {Highcharts.Color}
         * Color instance.
         */
        static parse(input) {
            return input ? new Color(input) : Color.None;
        }
        /* *
         *
         *  Constructor
         *
         * */
        constructor(input) {
            this.rgba = [NaN, NaN, NaN, NaN];
            this.input = input;
            const GlobalColor = H.Color;
            // Backwards compatibility, allow class overwrite
            if (GlobalColor && GlobalColor !== Color) {
                return new GlobalColor(input);
            }
            let result, rgba, i, parser;
            // Gradients
            if (typeof input === 'object' &&
                typeof input.stops !== 'undefined') {
                this.stops = input.stops.map((stop) => new Color(stop[1]));
                // Solid colors
            }
            else if (typeof input === 'string') {
                this.input = input = (Color.names[input.toLowerCase()] || input);
                // Bitmasking as input[0] is not working for legacy IE.
                if (input.charAt(0) === '#') {
                    const len = input.length, col = parseInt(input.substr(1), 16);
                    // Handle long-form, e.g. #AABBCC
                    if (len === 7) {
                        rgba = [
                            (col & 0xFF0000) >> 16,
                            (col & 0xFF00) >> 8,
                            (col & 0xFF),
                            1
                        ];
                        // Handle short-form, e.g. #ABC
                        // In short form, the value is assumed to be the same
                        // for both nibbles for each component. e.g. #ABC = #AABBCC
                    }
                    else if (len === 4) {
                        rgba = [
                            (((col & 0xF00) >> 4) |
                                (col & 0xF00) >> 8),
                            (((col & 0xF0) >> 4) |
                                (col & 0xF0)),
                            ((col & 0xF) << 4) | (col & 0xF),
                            1
                        ];
                    }
                }
                // Otherwise, check regex parsers
                if (!rgba) {
                    i = Color.parsers.length;
                    while (i-- && !rgba) {
                        parser = Color.parsers[i];
                        result = parser.regex.exec(input);
                        if (result) {
                            rgba = parser.parse(result);
                        }
                    }
                }
            }
            if (rgba) {
                this.rgba = rgba;
            }
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Return the color or gradient stops in the specified format
         *
         * @function Highcharts.Color#get
         *
         * @param {string} [format]
         * Possible values are 'a', 'rgb', 'rgba' (default).
         *
         * @return {Highcharts.ColorType}
         * This color as a string or gradient stops.
         */
        get(format) {
            const input = this.input, rgba = this.rgba;
            if (typeof input === 'object' &&
                typeof this.stops !== 'undefined') {
                const ret = merge$e(input);
                ret.stops = [].slice.call(ret.stops);
                this.stops.forEach((stop, i) => {
                    ret.stops[i] = [
                        ret.stops[i][0],
                        stop.get(format)
                    ];
                });
                return ret;
            }
            // It's NaN if gradient colors on a column chart
            if (rgba && isNumber$d(rgba[0])) {
                if (format === 'rgb' || (!format && rgba[3] === 1)) {
                    return 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
                }
                if (format === 'a') {
                    return `${rgba[3]}`;
                }
                return 'rgba(' + rgba.join(',') + ')';
            }
            return input;
        }
        /**
         * Brighten the color instance.
         *
         * @function Highcharts.Color#brighten
         *
         * @param {number} alpha
         * The alpha value.
         *
         * @return {Highcharts.Color}
         * This color with modifications.
         */
        brighten(alpha) {
            const rgba = this.rgba;
            if (this.stops) {
                this.stops.forEach(function (stop) {
                    stop.brighten(alpha);
                });
            }
            else if (isNumber$d(alpha) && alpha !== 0) {
                for (let i = 0; i < 3; i++) {
                    rgba[i] += pInt$4(alpha * 255);
                    if (rgba[i] < 0) {
                        rgba[i] = 0;
                    }
                    if (rgba[i] > 255) {
                        rgba[i] = 255;
                    }
                }
            }
            return this;
        }
        /**
         * Set the color's opacity to a given alpha value.
         *
         * @function Highcharts.Color#setOpacity
         *
         * @param {number} alpha
         *        Opacity between 0 and 1.
         *
         * @return {Highcharts.Color}
         *         Color with modifications.
         */
        setOpacity(alpha) {
            this.rgba[3] = alpha;
            return this;
        }
        /**
         * Return an intermediate color between two colors.
         *
         * @function Highcharts.Color#tweenTo
         *
         * @param {Highcharts.Color} to
         * The color object to tween to.
         *
         * @param {number} pos
         * The intermediate position, where 0 is the from color (current color
         * item), and 1 is the `to` color.
         *
         * @return {Highcharts.ColorType}
         * The intermediate color in rgba notation, or unsupported type.
         */
        tweenTo(to, pos) {
            const fromRgba = this.rgba, toRgba = to.rgba;
            // Unsupported color, return to-color (#3920, #7034)
            if (!isNumber$d(fromRgba[0]) || !isNumber$d(toRgba[0])) {
                return to.input || 'none';
            }
            // Check for has alpha, because rgba colors perform worse due to
            // lack of support in WebKit.
            const hasAlpha = (toRgba[3] !== 1 || fromRgba[3] !== 1);
            return (hasAlpha ? 'rgba(' : 'rgb(') +
                Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) +
                ',' +
                Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) +
                ',' +
                Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) +
                (hasAlpha ?
                    (',' +
                        (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos))) :
                    '') +
                ')';
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    /**
     * Collection of named colors. Can be extended from the outside by adding
     * colors to Highcharts.Color.names.
     * @private
     */
    Color.names = {
        white: '#ffffff',
        black: '#000000'
    };
    /**
     * Collection of parsers. This can be extended from the outside by pushing
     * parsers to `Color.parsers`.
     * @private
     */
    Color.parsers = [{
            // RGBA color
            // eslint-disable-next-line max-len
            regex: /rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,
            parse: function (result) {
                return [
                    pInt$4(result[1]),
                    pInt$4(result[2]),
                    pInt$4(result[3]),
                    parseFloat(result[4], 10)
                ];
            }
        }, {
            // RGB color
            regex: /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,
            parse: function (result) {
                return [pInt$4(result[1]), pInt$4(result[2]), pInt$4(result[3]), 1];
            }
        }];
    // Must be last static member for init cycle
    Color.None = new Color('');

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { parse: color$1 } = Color;
    const { win: win$7 } = H;
    const { isNumber: isNumber$c, objectEach: objectEach$b } = Utilities;
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /* *
     *
     *  Class
     *
     * */
    /**
     * An animator object used internally. One instance applies to one property
     * (attribute or style prop) on one element. Animation is always initiated
     * through {@link SVGElement#animate}.
     *
     * @example
     * let rect = renderer.rect(0, 0, 10, 10).add();
     * rect.animate({ width: 100 });
     *
     * @private
     * @class
     * @name Highcharts.Fx
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem
     * The element to animate.
     *
     * @param {Partial<Highcharts.AnimationOptionsObject>} options
     * Animation options.
     *
     * @param {string} prop
     * The single attribute or CSS property to animate.
     */
    class Fx {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(elem, options, prop) {
            this.pos = NaN;
            this.options = options;
            this.elem = elem;
            this.prop = prop;
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Set the current step of a path definition on SVGElement.
         *
         * @function Highcharts.Fx#dSetter
         *
         */
        dSetter() {
            const paths = this.paths, start = paths && paths[0], end = paths && paths[1], now = this.now || 0;
            let path = [];
            // Land on the final path without adjustment points appended in the ends
            if (now === 1 || !start || !end) {
                path = this.toD || [];
            }
            else if (start.length === end.length && now < 1) {
                for (let i = 0; i < end.length; i++) {
                    // Tween between the start segment and the end segment. Start
                    // with a copy of the end segment and tween the appropriate
                    // numerics
                    const startSeg = start[i];
                    const endSeg = end[i];
                    const tweenSeg = [];
                    for (let j = 0; j < endSeg.length; j++) {
                        const startItem = startSeg[j];
                        const endItem = endSeg[j];
                        // Tween numbers
                        if (isNumber$c(startItem) &&
                            isNumber$c(endItem) &&
                            // Arc boolean flags
                            !(endSeg[0] === 'A' && (j === 4 || j === 5))) {
                            tweenSeg[j] = startItem + now * (endItem - startItem);
                            // Strings, take directly from the end segment
                        }
                        else {
                            tweenSeg[j] = endItem;
                        }
                    }
                    path.push(tweenSeg);
                }
                // If animation is finished or length not matching, land on right value
            }
            else {
                path = end;
            }
            this.elem.attr('d', path, void 0, true);
        }
        /**
         * Update the element with the current animation step.
         *
         * @function Highcharts.Fx#update
         *
         */
        update() {
            const elem = this.elem, prop = this.prop, // If destroyed, it is null
            now = this.now, step = this.options.step;
            // Animation setter defined from outside
            if (this[prop + 'Setter']) {
                this[prop + 'Setter']();
                // Other animations on SVGElement
            }
            else if (elem.attr) {
                if (elem.element) {
                    elem.attr(prop, now, null, true);
                }
                // HTML styles, raw HTML content like container size
            }
            else {
                elem.style[prop] = now + this.unit;
            }
            if (step) {
                step.call(elem, now, this);
            }
        }
        /**
         * Run an animation.
         *
         * @function Highcharts.Fx#run
         *
         * @param {number} from
         *        The current value, value to start from.
         *
         * @param {number} to
         *        The end value, value to land on.
         *
         * @param {string} unit
         *        The property unit, for example `px`.
         *
         */
        run(from, to, unit) {
            const self = this, options = self.options, timer = function (gotoEnd) {
                return timer.stopped ? false : self.step(gotoEnd);
            }, requestAnimationFrame = win$7.requestAnimationFrame ||
                function (step) {
                    setTimeout(step, 13);
                }, step = function () {
                for (let i = 0; i < Fx.timers.length; i++) {
                    if (!Fx.timers[i]()) {
                        Fx.timers.splice(i--, 1);
                    }
                }
                if (Fx.timers.length) {
                    requestAnimationFrame(step);
                }
            };
            if (from === to && !this.elem['forceAnimate:' + this.prop]) {
                delete options.curAnim[this.prop];
                if (options.complete &&
                    Object.keys(options.curAnim).length === 0) {
                    options.complete.call(this.elem);
                }
            }
            else { // #7166
                this.startTime = +new Date();
                this.start = from;
                this.end = to;
                this.unit = unit;
                this.now = this.start;
                this.pos = 0;
                timer.elem = this.elem;
                timer.prop = this.prop;
                if (timer() && Fx.timers.push(timer) === 1) {
                    requestAnimationFrame(step);
                }
            }
        }
        /**
         * Run a single step in the animation.
         *
         * @function Highcharts.Fx#step
         *
         * @param {boolean} [gotoEnd]
         *        Whether to go to the endpoint of the animation after abort.
         *
         * @return {boolean}
         *         Returns `true` if animation continues.
         */
        step(gotoEnd) {
            const t = +new Date(), options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;
            let ret, done;
            if (!!elem.attr && !elem.element) { // #2616, element is destroyed
                ret = false;
            }
            else if (gotoEnd || t >= duration + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                curAnim[this.prop] = true;
                done = true;
                objectEach$b(curAnim, function (val) {
                    if (val !== true) {
                        done = false;
                    }
                });
                if (done && complete) {
                    complete.call(elem);
                }
                ret = false;
            }
            else {
                this.pos = options.easing((t - this.startTime) / duration);
                this.now = this.start + ((this.end -
                    this.start) * this.pos);
                this.update();
                ret = true;
            }
            return ret;
        }
        /**
         * Prepare start and end values so that the path can be animated one to one.
         *
         * @function Highcharts.Fx#initPath
         *
         * @param {Highcharts.SVGElement} elem
         *        The SVGElement item.
         *
         * @param {Highcharts.SVGPathArray|undefined} fromD
         *        Starting path definition.
         *
         * @param {Highcharts.SVGPathArray} toD
         *        Ending path definition.
         *
         * @return {Array<Highcharts.SVGPathArray,Highcharts.SVGPathArray>}
         *         An array containing start and end paths in array form so that
         *         they can be animated in parallel.
         */
        initPath(elem, fromD, toD) {
            const startX = elem.startX, endX = elem.endX, end = toD.slice(), // Copy
            isArea = elem.isArea, positionFactor = isArea ? 2 : 1, disableAnimation = fromD &&
                toD.length > fromD.length &&
                toD.hasStackedCliffs; // #16925
            let shift, fullLength, i, reverse, start = fromD && fromD.slice(); // Copy
            if (!start || disableAnimation) {
                return [end, end];
            }
            /**
             * If shifting points, prepend a dummy point to the end path.
             * @private
             */
            function prepend(arr, other) {
                while (arr.length < fullLength) {
                    // Move to, line to or curve to?
                    const moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
                    if (otherSegment && moveSegment[0] === 'M') {
                        if (otherSegment[0] === 'C') {
                            arr[0] = [
                                'C',
                                moveSegment[1],
                                moveSegment[2],
                                moveSegment[1],
                                moveSegment[2],
                                moveSegment[1],
                                moveSegment[2]
                            ];
                        }
                        else {
                            arr[0] = ['L', moveSegment[1], moveSegment[2]];
                        }
                    }
                    // Prepend a copy of the first point
                    arr.unshift(moveSegment);
                    // For areas, the bottom path goes back again to the left, so we
                    // need to append a copy of the last point.
                    if (isArea) {
                        const z = arr.pop();
                        arr.push(arr[arr.length - 1], z); // Append point and the Z
                    }
                }
            }
            /**
             * Copy and append last point until the length matches the end length.
             * @private
             */
            function append(arr) {
                while (arr.length < fullLength) {
                    // Pull out the slice that is going to be appended or inserted.
                    // In a line graph, the positionFactor is 1, and the last point
                    // is sliced out. In an area graph, the positionFactor is 2,
                    // causing the middle two points to be sliced out, since an area
                    // path starts at left, follows the upper path then turns and
                    // follows the bottom back.
                    const segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
                    // Disable the first control point of curve segments
                    if (segmentToAdd[0] === 'C') {
                        segmentToAdd[1] = segmentToAdd[5];
                        segmentToAdd[2] = segmentToAdd[6];
                    }
                    if (!isArea) {
                        arr.push(segmentToAdd);
                    }
                    else {
                        const lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
                        arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
                    }
                }
            }
            // For sideways animation, find out how much we need to shift to get the
            // start path Xs to match the end path Xs.
            if (startX && endX && endX.length) {
                for (i = 0; i < startX.length; i++) {
                    // Moving left, new points coming in on right
                    if (startX[i] === endX[0]) {
                        shift = i;
                        break;
                        // Moving right
                    }
                    else if (startX[0] ===
                        endX[endX.length - startX.length + i]) {
                        shift = i;
                        reverse = true;
                        break;
                        // Fixed from the right side, "scaling" left
                    }
                    else if (startX[startX.length - 1] ===
                        endX[endX.length - startX.length + i]) {
                        shift = startX.length - i;
                        break;
                    }
                }
                if (typeof shift === 'undefined') {
                    start = [];
                }
            }
            if (start.length && isNumber$c(shift)) {
                // The common target length for the start and end array, where both
                // arrays are padded in opposite ends
                fullLength = end.length + shift * positionFactor;
                if (!reverse) {
                    prepend(end, start);
                    append(start);
                }
                else {
                    prepend(start, end);
                    append(end);
                }
            }
            return [start, end];
        }
        /**
         * Handle animation of the color attributes directly.
         *
         * @function Highcharts.Fx#fillSetter
         *
         */
        fillSetter() {
            Fx.prototype.strokeSetter.apply(this, arguments);
        }
        /**
         * Handle animation of the color attributes directly.
         *
         * @function Highcharts.Fx#strokeSetter
         *
         */
        strokeSetter() {
            this.elem.attr(this.prop, color$1(this.start).tweenTo(color$1(this.end), this.pos), void 0, true);
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    Fx.timers = [];

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defined: defined$a, getStyle: getStyle$1, isArray: isArray$8, isNumber: isNumber$b, isObject: isObject$6, merge: merge$d, objectEach: objectEach$a, pick: pick$e } = Utilities;
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Set the global animation to either a given value, or fall back to the given
     * chart's animation option.
     *
     * @function Highcharts.setAnimation
     *
     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>|undefined} animation
     *        The animation object.
     *
     * @param {Highcharts.Chart} chart
     *        The chart instance.
     *
     * @todo
     * This function always relates to a chart, and sets a property on the renderer,
     * so it should be moved to the SVGRenderer.
     */
    function setAnimation$2(animation, chart) {
        chart.renderer.globalAnimation = pick$e(animation, chart.options.chart.animation, true);
    }
    /**
     * Get the animation in object form, where a disabled animation is always
     * returned as `{ duration: 0 }`.
     *
     * @function Highcharts.animObject
     *
     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=0]
     *        An animation setting. Can be an object with duration, complete and
     *        easing properties, or a boolean to enable or disable.
     *
     * @return {Highcharts.AnimationOptionsObject}
     *         An object with at least a duration property.
     */
    function animObject$6(animation) {
        return isObject$6(animation) ?
            merge$d({ duration: 500, defer: 0 }, animation) :
            { duration: animation ? 500 : 0, defer: 0 };
    }
    /**
     * Get the defer as a number value from series animation options.
     *
     * @function Highcharts.getDeferredAnimation
     *
     * @param {Highcharts.Chart} chart
     *        The chart instance.
     *
     * @param {boolean|Highcharts.AnimationOptionsObject} animation
     *        An animation setting. Can be an object with duration, complete and
     *        easing properties, or a boolean to enable or disable.
     *
     * @param {Highcharts.Series} [series]
     *        Series to defer animation.
     *
     * @return {number}
     *        The numeric value.
     */
    function getDeferredAnimation(chart, animation, series) {
        const labelAnimation = animObject$6(animation), s = series ? [series] : chart.series;
        let defer = 0, duration = 0;
        s.forEach((series) => {
            const seriesAnim = animObject$6(series.options.animation);
            defer = isObject$6(animation) && defined$a(animation.defer) ?
                labelAnimation.defer :
                Math.max(defer, seriesAnim.duration + seriesAnim.defer);
            duration = Math.min(labelAnimation.duration, seriesAnim.duration);
        });
        // Disable defer for exporting
        if (chart.renderer.forExport) {
            defer = 0;
        }
        const anim = {
            defer: Math.max(0, defer - duration),
            duration: Math.min(defer, duration)
        };
        return anim;
    }
    /**
     * The global animate method, which uses Fx to create individual animators.
     *
     * @function Highcharts.animate
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} el
     *        The element to animate.
     *
     * @param {Highcharts.CSSObject|Highcharts.SVGAttributes} params
     *        An object containing key-value pairs of the properties to animate.
     *        Supports numeric as pixel-based CSS properties for HTML objects and
     *        attributes for SVGElements.
     *
     * @param {Partial<Highcharts.AnimationOptionsObject>} [opt]
     *        Animation options.
     *
     * @return {void}
     */
    function animate$2(el, params, opt) {
        let start, unit = '', end, fx, args;
        if (!isObject$6(opt)) { // Number or undefined/null
            args = arguments;
            opt = {
                duration: args[2],
                easing: args[3],
                complete: args[4]
            };
        }
        if (!isNumber$b(opt.duration)) {
            opt.duration = 400;
        }
        opt.easing = typeof opt.easing === 'function' ?
            opt.easing :
            (Math[opt.easing] || Math.easeInOutSine);
        opt.curAnim = merge$d(params);
        objectEach$a(params, function (val, prop) {
            // Stop current running animation of this property
            stop$1(el, prop);
            fx = new Fx(el, opt, prop);
            end = void 0;
            if (prop === 'd' && isArray$8(params.d)) {
                fx.paths = fx.initPath(el, el.pathArray, params.d);
                fx.toD = params.d;
                start = 0;
                end = 1;
            }
            else if (el.attr) {
                start = el.attr(prop);
            }
            else {
                start = parseFloat(getStyle$1(el, prop)) || 0;
                if (prop !== 'opacity') {
                    unit = 'px';
                }
            }
            if (!end) {
                end = val;
            }
            if (typeof end === 'string' && end.match('px')) {
                end = end.replace(/px/g, ''); // #4351
            }
            fx.run(start, end, unit);
        });
    }
    /**
     * Stop running animation.
     *
     * @function Highcharts.stop
     *
     * @param {Highcharts.SVGElement} el
     *        The SVGElement to stop animation on.
     *
     * @param {string} [prop]
     *        The property to stop animating. If given, the stop method will stop a
     *        single property from animating, while others continue.
     *
     * @return {void}
     *
     * @todo
     * A possible extension to this would be to stop a single property, when
     * we want to continue animating others. Then assign the prop to the timer
     * in the Fx.run method, and check for the prop here. This would be an
     * improvement in all cases where we stop the animation from .attr. Instead of
     * stopping everything, we can just stop the actual attributes we're setting.
     */
    function stop$1(el, prop) {
        let i = Fx.timers.length;
        // Remove timers related to this element (#4519)
        while (i--) {
            if (Fx.timers[i].elem === el && (!prop || prop === Fx.timers[i].prop)) {
                Fx.timers[i].stopped = true; // #4667
            }
        }
    }
    const animationExports = {
        animate: animate$2,
        animObject: animObject$6,
        getDeferredAnimation,
        setAnimation: setAnimation$2,
        stop: stop$1
    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  Namespace
     *
     * */
    var AxisDefaults;
    (function (AxisDefaults) {
        /* *
         *
         *  Constants
         *
         * */
        /**
         * The X axis or category axis. Normally this is the horizontal axis,
         * though if the chart is inverted this is the vertical axis. In case of
         * multiple axes, the xAxis node is an array of configuration objects.
         *
         * See the [Axis class](/class-reference/Highcharts.Axis) for programmatic
         * access to the axis.
         *
         * @productdesc {highmaps}
         * In Highmaps, the axis is hidden, but it is used behind the scenes to
         * control features like zooming and panning. Zooming is in effect the same
         * as setting the extremes of one of the exes.
         *
         * @type         {*|Array<*>}
         * @optionparent xAxis
         */
        AxisDefaults.xAxis = {
            /**
             * When using multiple axis, the ticks of two or more opposite axes
             * will automatically be aligned by adding ticks to the axis or axes
             * with the least ticks, as if `tickAmount` were specified.
             *
             * This can be prevented by setting `alignTicks` to false. If the grid
             * lines look messy, it's a good idea to hide them for the secondary
             * axis by setting `gridLineWidth` to 0.
             *
             * If `startOnTick` or `endOnTick` in an Axis options are set to false,
             * then the `alignTicks ` will be disabled for the Axis.
             *
             * Disabled for logarithmic axes.
             *
             * @product   highcharts highstock gantt
             */
            alignTicks: true,
            /**
             * Whether to allow decimals in this axis' ticks. When counting
             * integers, like persons or hits on a web page, decimals should
             * be avoided in the labels. By default, decimals are allowed on small
             * scale axes.
             *
             * @see [minTickInterval](#xAxis.minTickInterval)
             *
             * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/
             *         True by default
             * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/
             *         False
             *
             * @type      {boolean|undefined}
             * @default   undefined
             * @since     2.0
             */
            allowDecimals: void 0,
            /**
             * When using an alternate grid color, a band is painted across the
             * plot area between every other grid line.
             *
             * @sample {highcharts} highcharts/yaxis/alternategridcolor/
             *         Alternate grid color on the Y axis
             * @sample {highstock} stock/xaxis/alternategridcolor/
             *         Alternate grid color on the Y axis
             *
             * @type      {Highcharts.ColorType}
             * @apioption xAxis.alternateGridColor
             */
            /**
             * An array defining breaks in the axis, the sections defined will be
             * left out and all the points shifted closer to each other.
             *
             * @productdesc {highcharts}
             * Requires that the broken-axis.js module is loaded.
             *
             * @sample {highcharts} highcharts/axisbreak/break-simple/
             *         Simple break
             * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/
             *         Advanced with callback
             * @sample {highstock} stock/demo/intraday-breaks/
             *         Break on nights and weekends
             *
             * @type      {Array<*>}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks
             */
            /**
             * A number indicating how much space should be left between the start
             * and the end of the break. The break size is given in axis units,
             * so for instance on a `datetime` axis, a break size of 3600000 would
             * indicate the equivalent of an hour.
             *
             * @type      {number}
             * @default   0
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks.breakSize
             */
            /**
             * The point where the break starts.
             *
             * @type      {number}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks.from
             */
            /**
             * Defines an interval after which the break appears again. By default
             * the breaks do not repeat.
             *
             * @type      {number}
             * @default   0
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks.repeat
             */
            /**
             * The point where the break ends.
             *
             * @type      {number}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks.to
             */
            /**
             * If categories are present for the xAxis, names are used instead of
             * numbers for that axis.
             *
             * Since Highcharts 3.0, categories can also
             * be extracted by giving each point a [name](#series.data) and setting
             * axis [type](#xAxis.type) to `category`. However, if you have multiple
             * series, best practice remains defining the `categories` array.
             *
             * Example: `categories: ['Apples', 'Bananas', 'Oranges']`
             *
             * @sample {highcharts} highcharts/demo/line-labels/
             *         With
             * @sample {highcharts} highcharts/xaxis/categories/
             *         Without
             *
             * @type      {Array<string>}
             * @product   highcharts gantt
             * @apioption xAxis.categories
             */
            /**
             * The highest allowed value for automatically computed axis extremes.
             *
             * @see [floor](#xAxis.floor)
             *
             * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/
             *         Floor and ceiling
             *
             * @type       {number}
             * @since      4.0
             * @product    highcharts highstock gantt
             * @apioption  xAxis.ceiling
             */
            /**
             * A class name that opens for styling the axis by CSS, especially in
             * Highcharts styled mode. The class name is applied to group elements
             * for the grid, axis elements and labels.
             *
             * @sample {highcharts|highstock|highmaps} highcharts/css/axis/
             *         Multiple axes with separate styling
             *
             * @type      {string}
             * @since     5.0.0
             * @apioption xAxis.className
             */
            /**
             * Configure a crosshair that follows either the mouse pointer or the
             * hovered point.
             *
             * In styled mode, the crosshairs are styled in the
             * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
             * `.highcharts-xaxis-category` classes.
             *
             * @productdesc {highstock}
             * In Highcharts stock, by default, the crosshair is enabled on the
             * X axis and disabled on the Y axis.
             *
             * @sample {highcharts} highcharts/xaxis/crosshair-both/
             *         Crosshair on both axes
             * @sample {highstock} stock/xaxis/crosshairs-xy/
             *         Crosshair on both axes, with y axis label
             * @sample {highmaps} highcharts/xaxis/crosshair-both/
             *         Crosshair on both axes
             *
             * @declare   Highcharts.AxisCrosshairOptions
             * @type      {boolean|*}
             * @default   false
             * @since     4.1
             * @apioption xAxis.crosshair
             */
            /**
             * The value on a perpendicular axis where this axis should cross. This
             * is typically used on mathematical plots where the axes cross at 0.
             * When `crossing` is set, space will not be reserved at the sides of
             * the chart for axis labels and title, so those may be clipped. In this
             * case it is better to place the axes without the `crossing` option.
             *
             * @type      {number}
             * @sample    highcharts/xaxis/crossing
             *            Function plot with axes crossing at 0
             * @since 11.0.1
             * @apioption xAxis.crossing
             */
            /**
             * A class name for the crosshair, especially as a hook for styling.
             *
             * @type      {string}
             * @since     5.0.0
             * @apioption xAxis.crosshair.className
             */
            /**
             * The color of the crosshair. Defaults to `#cccccc` for numeric and
             * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
             * the crosshair by default highlights the whole category.
             *
             * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/
             *         Customized crosshairs
             *
             * @type      {Highcharts.ColorType}
             * @default   #cccccc
             * @since     4.1
             * @apioption xAxis.crosshair.color
             */
            /**
             * The dash style for the crosshair. See
             * [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
             * for possible values.
             *
             * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
             *         Dotted crosshair
             * @sample {highstock} stock/xaxis/crosshair-dashed/
             *         Dashed X axis crosshair
             *
             * @type      {Highcharts.DashStyleValue}
             * @default   Solid
             * @since     4.1
             * @apioption xAxis.crosshair.dashStyle
             */
            /**
             * A label on the axis next to the crosshair.
             *
             * In styled mode, the label is styled with the
             * `.highcharts-crosshair-label` class.
             *
             * @sample {highstock} stock/xaxis/crosshair-label/
             *         Crosshair labels
             * @sample {highstock} highcharts/css/crosshair-label/
             *         Style mode
             *
             * @declare   Highcharts.AxisCrosshairLabelOptions
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label
             */
            /**
             * Alignment of the label compared to the axis. Defaults to `"left"` for
             * right-side axes, `"right"` for left-side axes and `"center"` for
             * horizontal axes.
             *
             * @type      {Highcharts.AlignValue}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.align
             */
            /**
             * The background color for the label. Defaults to the related series
             * color, or `#666666` if that is not available.
             *
             * @type      {Highcharts.ColorType}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.backgroundColor
             */
            /**
             * The border color for the crosshair label
             *
             * @type      {Highcharts.ColorType}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.borderColor
             */
            /**
             * The border corner radius of the crosshair label.
             *
             * @type      {number}
             * @default   3
             * @since     2.1.10
             * @product   highstock
             * @apioption xAxis.crosshair.label.borderRadius
             */
            /**
             * The border width for the crosshair label.
             *
             * @type      {number}
             * @default   0
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.borderWidth
             */
            /**
             * Flag to enable crosshair's label.
             *
             * @sample {highstock} stock/xaxis/crosshairs-xy/
             *         Enabled label for yAxis' crosshair
             *
             * @type      {boolean}
             * @default   false
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.enabled
             */
            /**
             * A format string for the crosshair label. Defaults to `{value}` for
             * numeric axes and `{value:%b %d, %Y}` for datetime axes.
             *
             * @type      {string}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.format
             */
            /**
             * Formatter function for the label text.
             *
             * @type      {Highcharts.XAxisCrosshairLabelFormatterCallbackFunction}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.formatter
             */
            /**
             * Padding inside the crosshair label.
             *
             * @type      {number}
             * @default   8
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.padding
             */
            /**
             * The shape to use for the label box.
             *
             * @type      {string}
             * @default   callout
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.shape
             */
            /**
             * Text styles for the crosshair label.
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"color": "white", "fontWeight": "normal", "fontSize": "11px", "textAlign": "center"}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.style
             */
            /**
             * Whether the crosshair should snap to the point or follow the pointer
             * independent of points.
             *
             * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/
             *         True by default
             * @sample {highmaps} maps/demo/latlon-advanced/
             *         Snap is false
             *
             * @type      {boolean}
             * @default   true
             * @since     4.1
             * @apioption xAxis.crosshair.snap
             */
            /**
             * The pixel width of the crosshair. Defaults to 1 for numeric or
             * datetime axes, and for one category width for category axes.
             *
             * @sample {highcharts} highcharts/xaxis/crosshair-customized/
             *         Customized crosshairs
             * @sample {highstock} highcharts/xaxis/crosshair-customized/
             *         Customized crosshairs
             * @sample {highmaps} highcharts/xaxis/crosshair-customized/
             *         Customized crosshairs
             *
             * @type      {number}
             * @default   1
             * @since     4.1
             * @apioption xAxis.crosshair.width
             */
            /**
             * The Z index of the crosshair. Higher Z indices allow drawing the
             * crosshair on top of the series or behind the grid lines.
             *
             * @type      {number}
             * @default   2
             * @since     4.1
             * @apioption xAxis.crosshair.zIndex
             */
            /**
             * Whether to pan axis. If `chart.panning` is enabled, the option
             * allows to disable panning on an individual axis.
             */
            panningEnabled: true,
            /**
             * The Z index for the axis group.
             *
             * @see [axis.gridZIndex](#xAxis.gridZIndex)
             * @see [axis.labels.zIndex](#xAxis.labels.zIndex)
             */
            zIndex: 2,
            /**
             * Whether to zoom axis. If `chart.zoomType` is set, the option allows
             * to disable zooming on an individual axis.
             *
             * @sample {highcharts} highcharts/xaxis/zoomenabled/
             *         Zoom enabled is false
             */
            zoomEnabled: true,
            /**
             * For a datetime axis, the scale will automatically adjust to the
             * appropriate unit. This member gives the default string
             * representations used for each unit. For intermediate values,
             * different units may be used, for example the `day` unit can be used
             * on midnight and `hour` unit be used for intermediate values on the
             * same axis.
             *
             * For an overview of the replacement codes, see
             * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
             *
             * Defaults to:
             * ```js
             * {
             *     millisecond: '%H:%M:%S.%L',
             *     second: '%H:%M:%S',
             *     minute: '%H:%M',
             *     hour: '%H:%M',
             *     day: '%e. %b',
             *     week: '%e. %b',
             *     month: '%b \'%y',
             *     year: '%Y'
             * }
             * ```
             *
             * @sample {highcharts} highcharts/xaxis/datetimelabelformats/
             *         Different day format on X axis
             * @sample {highstock} stock/xaxis/datetimelabelformats/
             *         More information in x axis labels
             *
             * @declare Highcharts.AxisDateTimeLabelFormatsOptions
             * @product highcharts highstock gantt
             */
            dateTimeLabelFormats: {
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                millisecond: {
                    /**
                     * @type {Array<string>}
                     * @default undefined
                     * @apioption xAxis.dateTimeLabelFormats.millisecond.list
                     */
                    /**
                     * @apioption xAxis.dateTimeLabelFormats.millisecond.main
                     */
                    main: '%H:%M:%S.%L',
                    range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                second: {
                    /**
                     * @type {Array<string>}
                     * @default undefined
                     * @apioption xAxis.dateTimeLabelFormats.second.list
                     */
                    /**
                     * @apioption xAxis.dateTimeLabelFormats.second.main
                     */
                    main: '%H:%M:%S',
                    range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                minute: {
                    /**
                     * @type {Array<string>}
                     * @default undefined
                     * @apioption xAxis.dateTimeLabelFormats.minute.list
                     */
                    /**
                     * @apioption xAxis.dateTimeLabelFormats.minute.main
                     */
                    main: '%H:%M',
                    range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                hour: {
                    /**
                     * @type {Array<string>}
                     * @default undefined
                     * @apioption xAxis.dateTimeLabelFormats.hour.list
                     */
                    /**
                     * @apioption xAxis.dateTimeLabelFormats.hour.main
                     */
                    main: '%H:%M',
                    range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                day: {
                    /**
                     * @type {Array<string>}
                     * @default undefined
                     * @apioption xAxis.dateTimeLabelFormats.day.list
                     */
                    /**
                     * @apioption xAxis.dateTimeLabelFormats.day.main
                     */
                    main: '%e %b'
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                week: {
                    /**
                     * @type {Array<string>}
                     * @default undefined
                     * @apioption xAxis.dateTimeLabelFormats.week.list
                     */
                    /**
                     * @apioption xAxis.dateTimeLabelFormats.week.main
                     */
                    main: '%e %b'
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                month: {
                    /**
                     * @type {Array<string>}
                     * @default undefined
                     * @apioption xAxis.dateTimeLabelFormats.month.list
                     */
                    /**
                     * @apioption xAxis.dateTimeLabelFormats.month.main
                     */
                    main: '%b \'%y'
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                year: {
                    /**
                     * @type {Array<string>}
                     * @default undefined
                     * @apioption xAxis.dateTimeLabelFormats.year.list
                     */
                    /**
                     * @apioption xAxis.dateTimeLabelFormats.year.main
                     */
                    main: '%Y'
                }
            },
            /**
             * Whether to force the axis to end on a tick. Use this option with
             * the `maxPadding` option to control the axis end.
             *
             * @productdesc {highstock}
             * In Highcharts Stock, `endOnTick` is always `false` when the navigator
             * is enabled, to prevent jumpy scrolling. With disabled navigator
             * enabling `endOnTick` may lead to extending the xAxis to show the last
             * tick, therefore range selector buttons may not have an active state
             * if the axis gets extended.
             *
             * @sample {highcharts} highcharts/yaxis/endontick/
             *         True by default
             * @sample {highcharts} highcharts/yaxis/endontick-false/
             *         False
             * @sample {highstock} stock/demo/basic-line/
             *         True by default
             * @sample {highstock} stock/xaxis/endontick/
             *         False
             *
             * @since 1.2.0
             */
            endOnTick: false,
            /**
             * Event handlers for the axis.
             *
             * @type      {*}
             * @apioption xAxis.events
             */
            /**
             * An event fired after the breaks have rendered.
             *
             * @see [breaks](#xAxis.breaks)
             *
             * @sample {highcharts} highcharts/axisbreak/break-event/
             *         AfterBreak Event
             *
             * @type      {Highcharts.AxisEventCallbackFunction}
             * @since     4.1.0
             * @product   highcharts gantt
             * @apioption xAxis.events.afterBreaks
             */
            /**
             * As opposed to the `setExtremes` event, this event fires after the
             * final min and max values are computed and corrected for `minRange`.
             *
             * Fires when the minimum and maximum is set for the axis, either by
             * calling the `.setExtremes()` method or by selecting an area in the
             * chart. One parameter, `event`, is passed to the function, containing
             * common event information.
             *
             * The new user set minimum and maximum values can be found by
             * `event.min` and `event.max`. These reflect the axis minimum and
             * maximum in axis values. The actual data extremes are found in
             * `event.dataMin` and `event.dataMax`.
             *
             * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
             * @since     2.3
             * @context   Highcharts.Axis
             * @apioption xAxis.events.afterSetExtremes
             */
            /**
             * An event fired when a break from this axis occurs on a point.
             *
             * @see [breaks](#xAxis.breaks)
             *
             * @sample {highcharts} highcharts/axisbreak/break-visualized/
             *         Visualization of a Break
             *
             * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
             * @since     4.1.0
             * @product   highcharts gantt
             * @context   Highcharts.Axis
             * @apioption xAxis.events.pointBreak
             */
            /**
             * An event fired when a point falls inside a break from this axis.
             *
             * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
             * @product   highcharts highstock gantt
             * @context   Highcharts.Axis
             * @apioption xAxis.events.pointInBreak
             */
            /**
             * An event fired when a point is outside a break after zoom.
             *
             * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
             * @product   highcharts highstock gantt
             * @context   Highcharts.Axis
             * @apioption xAxis.events.pointBreakOut
             */
            /**
             * Fires when the minimum and maximum is set for the axis, either by
             * calling the `.setExtremes()` method or by selecting an area in the
             * chart. One parameter, `event`, is passed to the function,
             * containing common event information.
             *
             * The new user set minimum and maximum values can be found by
             * `event.min` and `event.max`. These reflect the axis minimum and
             * maximum in data values. When an axis is zoomed all the way out from
             * the "Reset zoom" button, `event.min` and `event.max` are null, and
             * the new extremes are set based on `this.dataMin` and `this.dataMax`.
             *
             * @sample {highstock} stock/xaxis/events-setextremes/
             *         Log new extremes on x axis
             *
             * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Axis
             * @apioption xAxis.events.setExtremes
             */
            /**
             * The lowest allowed value for automatically computed axis extremes.
             *
             * @see [ceiling](#yAxis.ceiling)
             *
             * @sample {highcharts} highcharts/yaxis/floor-ceiling/
             *         Floor and ceiling
             * @sample {highstock} stock/demo/lazy-loading/
             *         Prevent negative stock price on Y axis
             *
             * @type      {number}
             * @since     4.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.floor
             */
            /**
             * The dash or dot style of the grid lines. For possible values, see
             * [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
             *
             * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/
             *         Long dashes
             * @sample {highstock} stock/xaxis/gridlinedashstyle/
             *         Long dashes
             *
             * @type      {Highcharts.DashStyleValue}
             * @since     1.2
             */
            gridLineDashStyle: 'Solid',
            /**
             * The Z index of the grid lines.
             *
             * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/
             *         A Z index of 4 renders the grid above the graph
             *
             * @product   highcharts highstock gantt
             *
             * @see [axis.zIndex](#xAxis.zIndex)
             * @see [axis.labels.zIndex](#xAxis.labels.zIndex)
             */
            gridZIndex: 1,
            /**
             * An id for the axis. This can be used after render time to get
             * a pointer to the axis object through `chart.get()`.
             *
             * @sample {highcharts} highcharts/xaxis/id/
             *         Get the object
             * @sample {highstock} stock/xaxis/id/
             *         Get the object
             *
             * @type      {string}
             * @since     1.2.0
             * @apioption xAxis.id
             */
            /**
             * The axis labels show the number or category for each tick.
             *
             * Since v8.0.0: Labels are animated in categorized x-axis with
             * updating data if `tickInterval` and `step` is set to 1.
             *
             * @productdesc {highmaps}
             * X and Y axis labels are by default disabled in Highmaps, but the
             * functionality is inherited from Highcharts and used on `colorAxis`,
             * and can be enabled on X and Y axes too.
             */
            labels: {
                /**
                 * What part of the string the given position is anchored to.
                 * If `left`, the left side of the string is at the axis position.
                 * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
                 * an intelligent guess based on which side of the chart the axis
                 * is on and the rotation of the label.
                 *
                 * @see [reserveSpace](#xAxis.labels.reserveSpace)
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-align-left/
                 *         Left
                 * @sample {highcharts} highcharts/xaxis/labels-align-right/
                 *         Right
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
                 *         Left-aligned labels on a vertical category axis
                 *
                 * @type      {Highcharts.AlignValue}
                 * @apioption xAxis.labels.align
                 */
                /**
                 * Whether to allow the axis labels to overlap. When false,
                 * overlapping labels are hidden.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-allowoverlap-true/
                 *         X axis labels overlap enabled
                 *
                 * @type      {boolean}
                 * @default   false
                 * @apioption xAxis.labels.allowOverlap
                 */
                /**
                 * For horizontal axes, the allowed degrees of label rotation
                 * to prevent overlapping labels. If there is enough space,
                 * labels are not rotated. As the chart gets narrower, it
                 * will start rotating the labels -45 degrees, then remove
                 * every second label and try again with rotations 0 and -45 etc.
                 * Set it to `undefined` to disable rotation, which will
                 * cause the labels to word-wrap if possible. Defaults to `[-45]``
                 * on bottom and top axes, `undefined` on left and right axes.
                 *
                 * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/
                 *         Default auto rotation of 0 or -45
                 * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/
                 *         Custom graded auto rotation
                 *
                 * @type      {Array<number>}
                 * @default   undefined
                 * @since     4.1.0
                 * @product   highcharts highstock gantt
                 * @apioption xAxis.labels.autoRotation
                 */
                /**
                 * When each category width is more than this many pixels, we don't
                 * apply auto rotation. Instead, we lay out the axis label with word
                 * wrap. A lower limit makes sense when the label contains multiple
                 * short words that don't extend the available horizontal space for
                 * each label.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/
                 *         Lower limit
                 *
                 * @since     4.1.5
                 * @product   highcharts gantt
                 */
                autoRotationLimit: 80,
                /**
                 * The label's pixel distance from the perimeter of the plot area.
                 * On cartesian charts, this is overridden if the `labels.y` setting
                 * is set.
                 *
                 * @sample {highcharts} highcharts/yaxis/labels-distance/
                 *         Polar chart, labels centered under the arc
                 *
                 * @type      {number}
                 * @product   highcharts gantt
                 */
                distance: 15,
                /**
                 * Enable or disable the axis labels.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-enabled/
                 *         X axis labels disabled
                 * @sample {highstock} stock/xaxis/labels-enabled/
                 *         X axis labels disabled
                 *
                 */
                enabled: true,
                /**
                 * A format string for the axis label. The context is available as
                 * format string variables. For example, you can use `{text}` to
                 * insert the default formatted text. The recommended way of adding
                 * units for the label is using `text`, for example `{text} km`.
                 *
                 * To add custom numeric or datetime formatting, use `{value}` with
                 * formatting, for example `{value:.1f}` or `{value:%Y-%m-%d}`.
                 *
                 * See
                 * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
                 * for more examples of formatting.
                 *
                 * The default value is not specified due to the dynamic
                 * nature of the default implementation.
                 *
                 * @sample {highcharts|highstock} highcharts/yaxis/labels-format/
                 *         Add units to Y axis label
                 * @sample {highcharts} highcharts/xaxis/labels-format-linked/
                 *         Linked category names
                 * @sample {highcharts} highcharts/xaxis/labels-format-custom/
                 *         Custom number format
                 *
                 * @type      {string}
                 * @since     3.0
                 * @apioption xAxis.labels.format
                 */
                /**
                 * Callback JavaScript function to format the label. The value
                 * is given by `this.value`. Additional properties for `this` are
                 * `axis`, `chart`, `isFirst`, `isLast` and `text` which holds the
                 * value of the default formatter.
                 *
                 * Defaults to a built in function returning a formatted string
                 * depending on whether the axis is `category`, `datetime`,
                 * `numeric` or other.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/
                 *         Linked category names
                 * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/
                 *         Modified numeric labels
                 * @sample {highstock} stock/xaxis/labels-formatter/
                 *         Added units on Y axis
                 *
                 * @type      {Highcharts.AxisLabelsFormatterCallbackFunction}
                 * @apioption xAxis.labels.formatter
                 */
                /**
                 * The number of pixels to indent the labels per level in a treegrid
                 * axis.
                 *
                 * @sample gantt/treegrid-axis/demo
                 *         Indentation 10px by default.
                 * @sample gantt/treegrid-axis/indentation-0px
                 *         Indentation set to 0px.
                 *
                 * @product gantt
                 */
                indentation: 10,
                /**
                 * Horizontal axis only. When `staggerLines` is not set,
                 * `maxStaggerLines` defines how many lines the axis is allowed to
                 * add to automatically avoid overlapping X labels. Set to `1` to
                 * disable overlap detection.
                 *
                 * @deprecated
                 * @type      {number}
                 * @default   5
                 * @since     1.3.3
                 * @apioption xAxis.labels.maxStaggerLines
                 */
                /**
                 * How to handle overflowing labels on horizontal axis. If set to
                 * `"allow"`, it will not be aligned at all. By default it
                 * `"justify"` labels inside the chart area. If there is room to
                 * move it, it will be aligned to the edge, else it will be removed.
                 *
                 * @since      2.2.5
                 * @validvalue ["allow", "justify"]
                 */
                overflow: 'justify',
                /**
                 * The pixel padding for axis labels, to ensure white space between
                 * them. Defaults to 4 for horizontal axes, 1 for vertical.
                 *
                 * @type      {number}
                 * @default   undefined
                 * @product   highcharts gantt
                 * @apioption xAxis.labels.padding
                 */
                /**
                 * Whether to reserve space for the labels. By default, space is
                 * reserved for the labels in these cases:
                 *
                 * * On all horizontal axes.
                 * * On vertical axes if `label.align` is `right` on a left-side
                 * axis or `left` on a right-side axis.
                 * * On vertical axes if `label.align` is `center`.
                 *
                 * This can be turned off when for example the labels are rendered
                 * inside the plot area instead of outside.
                 *
                 * @see [labels.align](#xAxis.labels.align)
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace/
                 *         No reserved space, labels inside plot
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
                 *         Left-aligned labels on a vertical category axis
                 *
                 * @type      {boolean}
                 * @since     4.1.10
                 * @product   highcharts highstock gantt
                 * @apioption xAxis.labels.reserveSpace
                 */
                reserveSpace: void 0,
                /**
                 * Rotation of the labels in degrees. When `undefined`, the
                 * `autoRotation` option takes precedence.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-rotation/
                 *         X axis labels rotated 90°
                 *
                 * @type      {number}
                 * @default   0
                 * @apioption xAxis.labels.rotation
                 */
                rotation: void 0,
                /**
                 * Horizontal axes only. The number of lines to spread the labels
                 * over to make room or tighter labels. 0 disables staggering.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-staggerlines/
                 *         Show labels over two lines
                 * @sample {highstock} stock/xaxis/labels-staggerlines/
                 *         Show labels over two lines
                 *
                 * @since     2.1
                 */
                staggerLines: 0,
                /**
                 * To show only every _n_'th label on the axis, set the step to _n_.
                 * Setting the step to 2 shows every other label.
                 *
                 * By default, when 0, the step is calculated automatically to avoid
                 * overlap. To prevent this, set it to 1\. This usually only
                 * happens on a category axis, and is often a sign that you have
                 * chosen the wrong axis type.
                 *
                 * Read more at
                 * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)
                 * => What axis should I use?
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-step/
                 *         Showing only every other axis label on a categorized
                 *         x-axis
                 * @sample {highcharts} highcharts/xaxis/labels-step-auto/
                 *         Auto steps on a category axis
                 *
                 * @since     2.1
                 */
                step: 0,
                /**
                 * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
                 * to render the labels.
                 */
                useHTML: false,
                /**
                 * The x position offset of all labels relative to the tick
                 * positions on the axis. Overrides the `labels.distance` option.
                 *
                 * @type      {number}
                 * @apioption xAxis.labels.x
                 */
                /**
                 * The y position offset of all labels relative to the tick
                 * positions on the axis. Overrides the `labels.distance` option.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         X axis labels placed on grid lines
                 *
                 * @type      {number}
                 * @apioption xAxis.labels.y
                 */
                /**
                 * The Z index for the axis labels.
                 *
                 * @see [axis.zIndex](#xAxis.zIndex)
                 * @see [axis.gridZIndex](#xAxis.gridZIndex)
                 */
                zIndex: 7,
                /**
                 * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
                 * wrapping of category labels. Use `textOverflow: 'none'` to
                 * prevent ellipsis (dots).
                 *
                 * In styled mode, the labels are styled with the
                 * `.highcharts-axis-labels` class.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-style/
                 *         Red X axis labels
                 *
                 * @type      {Highcharts.CSSObject}
                 */
                style: {
                    /** @internal */
                    color: "#333333" /* Palette.neutralColor80 */,
                    /** @internal */
                    cursor: 'default',
                    /** @internal */
                    fontSize: '0.8em'
                }
            },
            /**
             * The left position as the horizontal axis. If it's a number, it is
             * interpreted as pixel position relative to the chart.
             *
             * Since Highcharts v5.0.13: If it's a percentage string, it is
             * interpreted as percentages of the plot width, offset from plot area
             * left.
             *
             * @sample {highcharts} highcharts/xaxis/axis-position-properties
             *         Different axis position properties
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption xAxis.left
             */
            /**
             * The top position as the vertical axis. If it's a number, it is
             * interpreted as pixel position relative to the chart.
             *
             * Since Highcharts 2: If it's a percentage string, it is interpreted
             * as percentages of the plot height, offset from plot area top.
             *
             * @sample {highcharts} highcharts/xaxis/axis-position-properties
             *         Different axis position properties
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption xAxis.top
             */
            /**
             * Index of another axis that this axis is linked to. When an axis is
             * linked to a master axis, it will take the same extremes as
             * the master, but as assigned by min or max or by setExtremes.
             * It can be used to show additional info, or to ease reading the
             * chart by duplicating the scales.
             *
             * @sample {highcharts} highcharts/xaxis/linkedto/
             *         Different string formats of the same date
             * @sample {highcharts} highcharts/yaxis/linkedto/
             *         Y values on both sides
             *
             * @type      {number}
             * @since     2.0.2
             * @product   highcharts highstock gantt
             * @apioption xAxis.linkedTo
             */
            /**
             * The maximum value of the axis. If `null`, the max value is
             * automatically calculated.
             *
             * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value
             * might be rounded up.
             *
             * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
             * beyond the set max in order to reach the given number of ticks. The
             * same may happen in a chart with multiple axes, determined by [chart.
             * alignTicks](#chart), where a `tickAmount` is applied internally.
             *
             * @sample {highcharts} highcharts/yaxis/max-200/
             *         Y axis max of 200
             * @sample {highcharts} highcharts/yaxis/max-logarithmic/
             *         Y axis max on logarithmic axis
             * @sample {highstock} stock/xaxis/min-max/
             *         Fixed min and max on X axis
             *
             * @type      {number|null}
             * @apioption xAxis.max
             */
            /**
             * Padding of the max value relative to the length of the axis. A
             * padding of 0.05 will make a 100px axis 5px longer. This is useful
             * when you don't want the highest data value to appear on the edge
             * of the plot area. When the axis' `max` option is set or a max extreme
             * is set using `axis.setExtremes()`, the maxPadding will be ignored.
             *
             * @productdesc {highstock}
             * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
             * are ignored. Use [overscroll](#xAxis.overscroll) instead.
             *
             * @sample {highcharts} highcharts/yaxis/maxpadding/
             *         Max padding of 0.25 on y axis
             * @sample {highstock} stock/xaxis/minpadding-maxpadding/
             *         Greater min- and maxPadding
             * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
             *         Add some padding
             *
             * @default   {highcharts} 0.01
             * @default   {highstock|highmaps} 0
             * @since     1.2.0
             */
            maxPadding: 0.01,
            /**
             * Deprecated. Use `minRange` instead.
             *
             * @deprecated
             * @type      {number}
             * @product   highcharts highstock
             * @apioption xAxis.maxZoom
             */
            /**
             * The minimum value of the axis. If `null` the min value is
             * automatically calculated.
             *
             * If the [startOnTick](#yAxis.startOnTick) option is true (default),
             * the `min` value might be rounded down.
             *
             * The automatically calculated minimum value is also affected by
             * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
             * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
             * as well as [series.threshold](#plotOptions.series.threshold)
             * and [series.softThreshold](#plotOptions.series.softThreshold).
             *
             * @sample {highcharts} highcharts/yaxis/min-startontick-false/
             *         -50 with startOnTick to false
             * @sample {highcharts} highcharts/yaxis/min-startontick-true/
             *         -50 with startOnTick true by default
             * @sample {highstock} stock/xaxis/min-max/
             *         Set min and max on X axis
             *
             * @type      {number|null}
             * @apioption xAxis.min
             */
            /**
             * The dash or dot style of the minor grid lines. For possible values,
             * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
             *
             * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/
             *         Long dashes on minor grid lines
             * @sample {highstock} stock/xaxis/minorgridlinedashstyle/
             *         Long dashes on minor grid lines
             *
             * @type      {Highcharts.DashStyleValue}
             * @since     1.2
             */
            minorGridLineDashStyle: 'Solid',
            /**
             * Specific tick interval in axis units for the minor ticks. On a linear
             * axis, if `"auto"`, the minor tick interval is calculated as a fifth
             * of the tickInterval. If `undefined`, minor ticks are not shown.
             *
             * On logarithmic axes, the unit is the power of the value. For example,
             * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,
             * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks
             * between 1 and 10, 10 and 100 etc.
             *
             * If user settings dictate minor ticks to become too dense, they don't
             * make sense, and will be ignored to prevent performance problems.
             *
             * @sample {highcharts} highcharts/yaxis/minortickinterval-null/
             *         Undefined by default
             * @sample {highcharts} highcharts/yaxis/minortickinterval-5/ 5 units
             * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/
             *         "auto"
             * @sample {highcharts} highcharts/yaxis/minortickinterval-log/ 0.1
             * @sample {highstock} stock/demo/basic-line/ Null by default
             * @sample {highstock} stock/xaxis/minortickinterval-auto/ "auto"
             *
             * @type      {number|'auto'}
             * @apioption xAxis.minorTickInterval
             */
            /**
             * The pixel length of the minor tick marks.
             *
             * @sample {highcharts} highcharts/yaxis/minorticklength/
             *         10px on Y axis
             * @sample {highstock} stock/xaxis/minorticks/
             *         10px on Y axis
             */
            minorTickLength: 2,
            /**
             * The position of the minor tick marks relative to the axis line.
             *  Can be one of `inside` and `outside`.
             *
             * @sample {highcharts} highcharts/yaxis/minortickposition-outside/
             *         Outside by default
             * @sample {highcharts} highcharts/yaxis/minortickposition-inside/
             *         Inside
             * @sample {highstock} stock/xaxis/minorticks/
             *         Inside
             *
             * @validvalue ["inside", "outside"]
             */
            minorTickPosition: 'outside',
            /**
             * Enable or disable minor ticks. The interval between the minor ticks
             * can be controlled either by the
             * [minorTicksPerMajor](#xAxis.minorTicksPerMajor) setting, or as an
             * absolute [minorTickInterval](#xAxis.minorTickInterval) value.
             *
             * On a logarithmic axis, minor ticks are laid out based on a best
             * guess, attempting to enter an approximate number of minor ticks
             * between each major tick based on
             * [minorTicksPerMajor](#xAxis.minorTicksPerMajor).
             *
             * Prior to v6.0.0, ticks were enabled in auto layout by setting
             * `minorTickInterval` to `"auto"`.
             *
             * @productdesc {highcharts} On axes using
             * [categories](#xAxis.categories), minor ticks are not supported.
             *
             * @sample {highcharts} highcharts/yaxis/minorticks-true/ Enabled on
             *         linear Y axis
             *
             * @type      {boolean}
             * @default   false
             * @since     6.0.0
             * @apioption xAxis.minorTicks
             */
            /**
             * The number of minor ticks per major tick. Works for `linear`,
             * `logarithmic` and `datetime` axes.
             *
             * @sample {highcharts} highcharts/yaxis/minortickspermajor/
             *         2 minor ticks per major tick on Y axis
             *
             * @since  11.0.0
             *
             * @type {number}
             */
            minorTicksPerMajor: 5,
            /**
             * The pixel width of the minor tick mark.
             *
             * @sample {highcharts} highcharts/yaxis/minortickwidth/
             *         3px width
             * @sample {highstock} stock/xaxis/minorticks/
             *         1px width
             *
             * @type      {number}
             * @default   0
             * @apioption xAxis.minorTickWidth
             */
            /**
             * Padding of the min value relative to the length of the axis. A
             * padding of 0.05 will make a 100px axis 5px longer. This is useful
             * when you don't want the lowest data value to appear on the edge
             * of the plot area. When the axis' `min` option is set or a min extreme
             * is set using `axis.setExtremes()`, the minPadding will be ignored.
             *
             * @productdesc {highstock}
             * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
             * are ignored. Use [overscroll](#xAxis.overscroll) instead.
             *
             * @sample {highcharts} highcharts/yaxis/minpadding/
             *         Min padding of 0.2
             * @sample {highstock} stock/xaxis/minpadding-maxpadding/
             *         Greater min- and maxPadding
             * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
             *         Add some padding
             *
             * @default    {highcharts} 0.01
             * @default    {highstock|highmaps} 0
             * @since      1.2.0
             * @product    highcharts highstock gantt
             */
            minPadding: 0.01,
            /**
             * The minimum range to display on this axis. The entire axis will not
             * be allowed to span over a smaller interval than this. For example,
             * for a datetime axis the main unit is milliseconds. If minRange is
             * set to 3600000, you can't zoom in more than to one hour.
             *
             * The default minRange for the x axis is five times the smallest
             * interval between any of the data points.
             *
             * On a logarithmic axis, the unit for the minimum range is the power.
             * So a minRange of 1 means that the axis can be zoomed to 10-100,
             * 100-1000, 1000-10000 etc.
             *
             * **Note**: The `minPadding`, `maxPadding`, `startOnTick` and
             * `endOnTick` settings also affect how the extremes of the axis
             * are computed.
             *
             * @sample {highcharts} highcharts/xaxis/minrange/
             *         Minimum range of 5
             * @sample {highstock} stock/xaxis/minrange/
             *         Max zoom of 6 months overrides user selections
             *
             * @type      {number}
             * @apioption xAxis.minRange
             */
            /**
             * The minimum tick interval allowed in axis values. For example on
             * zooming in on an axis with daily data, this can be used to prevent
             * the axis from showing hours. Defaults to the closest distance between
             * two points on the axis.
             *
             * @type      {number}
             * @since     2.3.0
             * @apioption xAxis.minTickInterval
             */
            /**
             * The distance in pixels from the plot area to the axis line.
             * A positive offset moves the axis with it's line, labels and ticks
             * away from the plot area. This is typically used when two or more
             * axes are displayed on the same side of the plot. With multiple
             * axes the offset is dynamically adjusted to avoid collision, this
             * can be overridden by setting offset explicitly.
             *
             * @sample {highcharts} highcharts/yaxis/offset/
             *         Y axis offset of 70
             * @sample {highcharts} highcharts/yaxis/offset-centered/
             *         Axes positioned in the center of the plot
             * @sample {highstock} stock/xaxis/offset/
             *         Y axis offset by 70 px
             *
             * @type {number}
             */
            offset: void 0,
            /**
             * Whether to display the axis on the opposite side of the normal. The
             * normal is on the left side for vertical axes and bottom for
             * horizontal, so the opposite sides will be right and top respectively.
             * This is typically used with dual or multiple axes.
             *
             * @sample {highcharts} highcharts/yaxis/opposite/
             *         Secondary Y axis opposite
             * @sample {highstock} stock/xaxis/opposite/
             *         Y axis on left side
             *
             * @default   {highcharts|highstock|highmaps} false
             * @default   {gantt} true
             * @type      Boolean
             * @apioption xAxis.opposite
             */
            /**
             * In an ordinal axis, the points are equally spaced in the chart
             * regardless of the actual time or x distance between them. This means
             * that missing data periods (e.g. nights or weekends for a stock chart)
             * will not take up space in the chart.
             * Having `ordinal: false` will show any gaps created by the `gapSize`
             * setting proportionate to their duration.
             *
             * In stock charts the X axis is ordinal by default, unless
             * the boost module is used and at least one of the series' data length
             * exceeds the [boostThreshold](#series.line.boostThreshold).
             *
             * For an ordinal axis, `minPadding` and `maxPadding` are ignored. Use
             * [overscroll](#xAxis.overscroll) instead.
             *
             * @sample {highstock} stock/xaxis/ordinal-true/
             *         True by default
             * @sample {highstock} stock/xaxis/ordinal-false/
             *         False
             *
             * @see [overscroll](#xAxis.overscroll)
             *
             * @type      {boolean}
             * @default   true
             * @since     1.1
             * @product   highstock
             * @apioption xAxis.ordinal
             */
            /**
             * Additional range on the right side of the xAxis. Works similar to
             * `xAxis.maxPadding`, but the value is set in terms of axis values,
             * percentage or pixels.
             *
             * If it's a number, it is interpreted as axis values, which in a
             * datetime axis equals milliseconds.
             *
             * If it's a percentage string, is interpreted as percentages of axis
             * length. An overscroll of 50% will make a 100px axis 50px longer.
             *
             * If it's a pixel string, it is interpreted as a fixed pixel value, but
             * limited to 90% of the axis length.
             *
             * @sample {highstock} stock/xaxis/overscroll/ One minute overscroll
             *         with live data
             * @sample {highstock} stock/xaxis/overscroll-percent/ Overscroll set in
             *         percentage
             * @sample {highstock} stock/xaxis/overscroll-pixel/ Overscroll set in
             *         pixels
             *
             * @type      {number | string}
             * @default   0
             * @since     6.0.0
             * @product   highstock
             * @apioption xAxis.overscroll
             */
            /**
             * Refers to the index in the [panes](#panes) array. Used for circular
             * gauges and polar charts. When the option is not set then first pane
             * will be used.
             *
             * @sample highcharts/demo/gauge-vu-meter
             *         Two gauges with different center
             *
             * @type      {number}
             * @product   highcharts
             * @apioption xAxis.pane
             */
            /**
             * The zoomed range to display when only defining one or none of `min`
             * or `max`. For example, to show the latest month, a range of one month
             * can be set.
             *
             * @sample {highstock} stock/xaxis/range/
             *         Setting a zoomed range when the rangeSelector is disabled
             *
             * @type      {number}
             * @product   highstock
             * @apioption xAxis.range
             */
            /**
             * Whether to reverse the axis so that the highest number is closest
             * to the origin. If the chart is inverted, the x axis is reversed by
             * default.
             *
             * @sample {highcharts} highcharts/yaxis/reversed/
             *         Reversed Y axis
             * @sample {highstock} stock/xaxis/reversed/
             *         Reversed Y axis
             *
             * @type      {boolean}
             * @default   undefined
             * @apioption xAxis.reversed
             */
            reversed: void 0,
            /**
             * This option determines how stacks should be ordered within a group.
             * For example reversed xAxis also reverses stacks, so first series
             * comes last in a group. To keep order like for non-reversed xAxis
             * enable this option.
             *
             * @sample {highcharts} highcharts/xaxis/reversedstacks/
             *         Reversed stacks comparison
             * @sample {highstock} highcharts/xaxis/reversedstacks/
             *         Reversed stacks comparison
             *
             * @since     6.1.1
             * @product   highcharts highstock
             */
            reversedStacks: false,
            /**
             * An optional scrollbar to display on the X axis in response to
             * limiting the minimum and maximum of the axis values.
             *
             * In styled mode, all the presentational options for the scrollbar are
             * replaced by the classes `.highcharts-scrollbar-thumb`,
             * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
             * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
             *
             * @sample {highstock} stock/yaxis/heatmap-scrollbars/
             *         Heatmap with both scrollbars
             *
             * @extends   scrollbar
             * @since     4.2.6
             * @product   highstock
             * @apioption xAxis.scrollbar
             */
            /**
             * Whether to show the axis line and title when the axis has no data.
             *
             * @sample {highcharts} highcharts/yaxis/showempty/
             *         When clicking the legend to hide series, one axis preserves
             *         line and title, the other doesn't
             * @sample {highstock} highcharts/yaxis/showempty/
             *         When clicking the legend to hide series, one axis preserves
             *         line and title, the other doesn't
             *
             * @since     1.1
             */
            showEmpty: true,
            /**
             * Whether to show the first tick label.
             *
             * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/
             *         Set to false on X axis
             * @sample {highstock} stock/xaxis/showfirstlabel/
             *         Labels below plot lines on Y axis
             */
            showFirstLabel: true,
            /**
             * Whether to show the last tick label. Defaults to `true` on cartesian
             * charts, and `false` on polar charts.
             *
             * @sample {highcharts} highcharts/xaxis/showlastlabel-true/
             *         Set to true on X axis
             * @sample {highstock} stock/xaxis/showfirstlabel/
             *         Labels below plot lines on Y axis
             *
             * @type    {boolean}
             * @default undefined
             * @product highcharts highstock gantt
             */
            showLastLabel: true,
            /**
             * A soft maximum for the axis. If the series data maximum is less than
             * this, the axis will stay at this maximum, but if the series data
             * maximum is higher, the axis will flex to show all data.
             *
             * @sample highcharts/yaxis/softmin-softmax/
             *         Soft min and max
             *
             * @type      {number}
             * @since     5.0.1
             * @product   highcharts highstock gantt
             * @apioption xAxis.softMax
             */
            /**
             * A soft minimum for the axis. If the series data minimum is greater
             * than this, the axis will stay at this minimum, but if the series
             * data minimum is lower, the axis will flex to show all data.
             *
             * @sample highcharts/yaxis/softmin-softmax/
             *         Soft min and max
             *
             * @type      {number}
             * @since     5.0.1
             * @product   highcharts highstock gantt
             * @apioption xAxis.softMin
             */
            /**
             * For datetime axes, this decides where to put the tick between weeks.
             *  0 = Sunday, 1 = Monday.
             *
             * @sample {highcharts} highcharts/xaxis/startofweek-monday/
             *         Monday by default
             * @sample {highcharts} highcharts/xaxis/startofweek-sunday/
             *         Sunday
             * @sample {highstock} stock/xaxis/startofweek-1
             *         Monday by default
             * @sample {highstock} stock/xaxis/startofweek-0
             *         Sunday
             *
             * @product highcharts highstock gantt
             */
            startOfWeek: 1,
            /**
             * Whether to force the axis to start on a tick. Use this option with
             * the `minPadding` option to control the axis start.
             *
             * @productdesc {highstock}
             * In Highcharts Stock, `startOnTick` is always `false` when
             * the navigator is enabled, to prevent jumpy scrolling.
             *
             * @sample {highcharts} highcharts/xaxis/startontick-false/
             *         False by default
             * @sample {highcharts} highcharts/xaxis/startontick-true/
             *         True
             *
             * @since 1.2.0
             */
            startOnTick: false,
            /**
             * The amount of ticks to draw on the axis. This opens up for aligning
             * the ticks of multiple charts or panes within a chart. This option
             * overrides the `tickPixelInterval` option.
             *
             * This option only has an effect on linear axes. Datetime, logarithmic
             * or category axes are not affected.
             *
             * @sample {highcharts} highcharts/yaxis/tickamount/
             *         8 ticks on Y axis
             * @sample {highstock} highcharts/yaxis/tickamount/
             *         8 ticks on Y axis
             *
             * @type      {number}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.tickAmount
             */
            /**
             * The interval of the tick marks in axis units. When `undefined`, the
             * tick interval is computed to approximately follow the
             * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime
             * axes. On categorized axes, a `undefined` tickInterval will default to
             * 1, one category. Note that datetime axes are based on milliseconds,
             * so for example an interval of one day is expressed as
             * `24 * 3600 * 1000`.
             *
             * On logarithmic axes, the tickInterval is based on powers, so a
             * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A
             * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval
             * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,
             * 40 etc.
             *
             *
             * If the tickInterval is too dense for labels to be drawn, Highcharts
             * may remove ticks.
             *
             * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)
             * option may interfere with the `tickInterval` setting.
             *
             * @see [tickPixelInterval](#xAxis.tickPixelInterval)
             * @see [tickPositions](#xAxis.tickPositions)
             * @see [tickPositioner](#xAxis.tickPositioner)
             *
             * @sample {highcharts} highcharts/xaxis/tickinterval-5/
             *         Tick interval of 5 on a linear axis
             * @sample {highstock} stock/xaxis/tickinterval/
             *         Tick interval of 0.01 on Y axis
             *
             * @type      {number}
             * @apioption xAxis.tickInterval
             */
            /**
             * The pixel length of the main tick marks.
             *
             * @sample {highcharts} highcharts/xaxis/ticklength/
             *         20 px tick length on the X axis
             * @sample {highstock} stock/xaxis/ticks/
             *         Formatted ticks on X axis
             */
            tickLength: 10,
            /**
             * If tickInterval is `null` this option sets the approximate pixel
             * interval of the tick marks. Not applicable to categorized axis.
             *
             * The tick interval is also influenced by the [minTickInterval](
             * #xAxis.minTickInterval) option, that, by default prevents ticks from
             * being denser than the data points.
             *
             * @see [tickInterval](#xAxis.tickInterval)
             * @see [tickPositioner](#xAxis.tickPositioner)
             * @see [tickPositions](#xAxis.tickPositions)
             *
             * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
             *         50 px on X axis
             * @sample {highstock} stock/xaxis/tickpixelinterval/
             *         200 px on X axis
             */
            tickPixelInterval: 100,
            /**
             * For categorized axes only. If `on` the tick mark is placed in the
             * center of the category, if `between` the tick mark is placed between
             * categories. The default is `between` if the `tickInterval` is 1, else
             * `on`. In order to render tick marks on a category axis it is necessary
             * to provide a [tickWidth](#xAxis.tickWidth).
             *
             * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/
             *         "between" by default
             * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/
             *         "on"
             *
             * @product    highcharts gantt
             * @validvalue ["on", "between"]
             */
            tickmarkPlacement: 'between',
            /**
             * The position of the major tick marks relative to the axis line.
             * Can be one of `inside` and `outside`.
             *
             * @sample {highcharts} highcharts/xaxis/tickposition-outside/
             *         "outside" by default
             * @sample {highcharts} highcharts/xaxis/tickposition-inside/
             *         "inside"
             * @sample {highstock} stock/xaxis/ticks/
             *         Formatted ticks on X axis
             *
             * @validvalue ["inside", "outside"]
             */
            tickPosition: 'outside',
            /**
             * A callback function returning array defining where the ticks are
             * laid out on the axis. This overrides the default behaviour of
             * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](
             * #xAxis.tickInterval). The automatic tick positions are accessible
             * through `this.tickPositions` and can be modified by the callback.
             *
             * @see [tickPositions](#xAxis.tickPositions)
             *
             * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
             *         Demo of tickPositions and tickPositioner
             * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
             *         Demo of tickPositions and tickPositioner
             *
             * @type      {Highcharts.AxisTickPositionerCallbackFunction}
             * @apioption xAxis.tickPositioner
             */
            /**
             * An array defining where the ticks are laid out on the axis. This
             * overrides the default behaviour of [tickPixelInterval](
             * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).
             *
             * @see [tickPositioner](#xAxis.tickPositioner)
             *
             * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
             *         Demo of tickPositions and tickPositioner
             * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
             *         Demo of tickPositions and tickPositioner
             *
             * @type      {Array<number>}
             * @apioption xAxis.tickPositions
             */
            /**
             * The pixel width of the major tick marks. Defaults to 0 on category
             * axes, otherwise 1.
             *
             * In styled mode, the stroke width is given in the `.highcharts-tick`
             * class, but in order for the element to be generated on category axes,
             * the option must be explicitly set to 1.
             *
             * @sample {highcharts} highcharts/xaxis/tickwidth/
             *         10 px width
             * @sample {highcharts} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/ticks/
             *         Formatted ticks on X axis
             * @sample {highstock} highcharts/css/axis-grid/
             *         Styled mode
             *
             * @type      {undefined|number}
             * @default   {highstock} 1
             * @default   {highmaps} 0
             * @apioption xAxis.tickWidth
             */
            /**
             * The axis title, showing next to the axis line.
             *
             * @productdesc {highmaps}
             * In Highmaps, the axis is hidden by default, but adding an axis title
             * is still possible. X axis and Y axis titles will appear at the bottom
             * and left by default.
             */
            title: {
                /**
                 * Alignment of the title relative to the axis values. Possible
                 * values are "low", "middle" or "high".
                 *
                 * @sample {highcharts} highcharts/xaxis/title-align-low/
                 *         "low"
                 * @sample {highcharts} highcharts/xaxis/title-align-center/
                 *         "middle" by default
                 * @sample {highcharts} highcharts/xaxis/title-align-high/
                 *         "high"
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Place the Y axis title on top of the axis
                 * @sample {highstock} stock/xaxis/title-align/
                 *         Aligned to "high" value
                 *
                 * @type {Highcharts.AxisTitleAlignValue}
                 */
                align: 'middle',
                /**
                 * Deprecated. Set the `text` to `undefined` to disable the title.
                 *
                 * @deprecated
                 * @type      {boolean}
                 * @product   highcharts
                 * @apioption xAxis.title.enabled
                 */
                /**
                 * The pixel distance between the axis labels or line and the title.
                 * Defaults to 0 for horizontal axes, 10 for vertical
                 *
                 * @sample {highcharts} highcharts/xaxis/title-margin/
                 *         Y axis title margin of 60
                 *
                 * @type      {number}
                 * @apioption xAxis.title.margin
                 */
                /**
                 * The distance of the axis title from the axis line. By default,
                 * this distance is computed from the offset width of the labels,
                 * the labels' distance from the axis and the title's margin.
                 * However when the offset option is set, it overrides all this.
                 *
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Place the axis title on top of the axis
                 * @sample {highstock} highcharts/yaxis/title-offset/
                 *         Place the axis title on top of the Y axis
                 *
                 * @type      {number}
                 * @since     2.2.0
                 * @apioption xAxis.title.offset
                 */
                /**
                 * Whether to reserve space for the title when laying out the axis.
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     5.0.11
                 * @product   highcharts highstock gantt
                 * @apioption xAxis.title.reserveSpace
                 */
                /**
                 * The rotation of the text in degrees. 0 is horizontal, 270 is
                 * vertical reading from bottom to top. Defaults to 0 for horizontal
                 * axes, 270 for left-side axes and 90 for right-side axes.
                 *
                 * @sample    {highcharts} highcharts/yaxis/title-offset/
                 *            Horizontal
                 *
                 * @type      {number}
                 * @default   undefined
                 * @apioption xAxis.title.rotation
                 */
                /**
                 * The actual text of the axis title. It can contain basic HTML tags
                 * like `b`, `i` and `span` with style.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-text/
                 *         Custom HTML
                 * @sample {highstock} stock/xaxis/title-text/
                 *         Titles for both axes
                 *
                 * @type      {string|null}
                 * @apioption xAxis.title.text
                 */
                /**
                 * Alignment of the text, can be `"left"`, `"right"` or `"center"`.
                 * Default alignment depends on the
                 * [title.align](xAxis.title.align):
                 *
                 * Horizontal axes:
                 * - for `align` = `"low"`, `textAlign` is set to `left`
                 * - for `align` = `"middle"`, `textAlign` is set to `center`
                 * - for `align` = `"high"`, `textAlign` is set to `right`
                 *
                 * Vertical axes:
                 * - for `align` = `"low"` and `opposite` = `true`, `textAlign` is
                 *   set to `right`
                 * - for `align` = `"low"` and `opposite` = `false`, `textAlign` is
                 *   set to `left`
                 * - for `align` = `"middle"`, `textAlign` is set to `center`
                 * - for `align` = `"high"` and `opposite` = `true` `textAlign` is
                 *   set to `left`
                 * - for `align` = `"high"` and `opposite` = `false` `textAlign` is
                 *   set to `right`
                 *
                 * @type      {Highcharts.AlignValue}
                 * @apioption xAxis.title.textAlign
                 */
                /**
                 * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
                 * to render the axis title.
                 *
                 * @product   highcharts highstock gantt
                 */
                useHTML: false,
                /**
                 * Horizontal pixel offset of the title position.
                 *
                 * @since     4.1.6
                 * @product   highcharts highstock gantt
                 */
                x: 0,
                /**
                 * Vertical pixel offset of the title position.
                 *
                 * @product   highcharts highstock gantt
                 */
                y: 0,
                /**
                 * CSS styles for the title. If the title text is longer than the
                 * axis length, it will wrap to multiple lines by default. This can
                 * be customized by setting `textOverflow: 'ellipsis'`, by
                 * setting a specific `width` or by setting `whiteSpace: 'nowrap'`.
                 *
                 * In styled mode, the stroke width is given in the
                 * `.highcharts-axis-title` class.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-style/
                 *         Red
                 * @sample {highcharts} highcharts/css/axis/
                 *         Styled mode
                 *
                 * @type    {Highcharts.CSSObject}
                 */
                style: {
                    /** @internal */
                    color: "#666666" /* Palette.neutralColor60 */,
                    /** @internal */
                    fontSize: '0.8em'
                }
            },
            /**
             * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
             * or `category`. In a datetime axis, the numbers are given in
             * milliseconds, and tick marks are placed on appropriate values like
             * full hours or days. In a category axis, the
             * [point names](#series.line.data.name) of the chart's series are used
             * for categories, if not a [categories](#xAxis.categories) array is
             * defined.
             *
             * @sample {highcharts} highcharts/xaxis/type-linear/
             *         Linear
             * @sample {highcharts} highcharts/yaxis/type-log/
             *         Logarithmic
             * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
             *         Logarithmic with minor grid lines
             * @sample {highcharts} highcharts/xaxis/type-log-both/
             *         Logarithmic on two axes
             * @sample {highcharts} highcharts/yaxis/type-log-negative/
             *         Logarithmic with extension to emulate negative values
             *
             * @type    {Highcharts.AxisTypeValue}
             * @default linear
             * @product highcharts gantt
             * @apioption xAxis.type
             */
            /**
             * If there are multiple axes on the same side of the chart, the pixel
             * margin between the axes. Defaults to 0 on vertical axes, 15 on
             * horizontal axes.
             *
             * @type      {number}
             * @since     7.0.3
             * @apioption xAxis.margin
             */
            /**
             * Applies only when the axis `type` is `category`. When `uniqueNames`
             * is true, points are placed on the X axis according to their names.
             * If the same point name is repeated in the same or another series,
             * the point is placed on the same X position as other points of the
             * same name. When `uniqueNames` is false, the points are laid out in
             * increasing X positions regardless of their names, and the X axis
             * category will take the name of the last point in each position.
             *
             * @sample {highcharts} highcharts/xaxis/uniquenames-true/
             *         True by default
             * @sample {highcharts} highcharts/xaxis/uniquenames-false/
             *         False
             *
             * @since     4.2.7
             * @product   highcharts gantt
             * @type      {boolean}
             * @default   true
             */
            /**
             * Datetime axis only. An array determining what time intervals the
             * ticks are allowed to fall on. Each array item is an array where the
             * first value is the time unit and the second value another array of
             * allowed multiples.
             *
             * Defaults to:
             * ```js
             * units: [[
             *     'millisecond', // unit name
             *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
             * ], [
             *     'second',
             *     [1, 2, 5, 10, 15, 30]
             * ], [
             *     'minute',
             *     [1, 2, 5, 10, 15, 30]
             * ], [
             *     'hour',
             *     [1, 2, 3, 4, 6, 8, 12]
             * ], [
             *     'day',
             *     [1, 2]
             * ], [
             *     'week',
             *     [1, 2]
             * ], [
             *     'month',
             *     [1, 2, 3, 4, 6]
             * ], [
             *     'year',
             *     null
             * ]]
             * ```
             *
             * @sample {highcharts} highcharts/xaxis/units/
             *         Axis units demonstrated
             *
             * @type      {Array<Array<string,(Array<number>|null)>>}
             * @product   highcharts highstock gantt
             * @apioption xAxis.units
             */
            /**
             * Whether axis, including axis title, line, ticks and labels, should
             * be visible.
             *
             * @since     4.1.9
             * @product   highcharts highstock gantt
             */
            visible: true,
            /**
             * Color of the minor, secondary grid lines.
             *
             * In styled mode, the stroke width is given in the
             * `.highcharts-minor-grid-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/
             *         Bright grey lines from Y axis
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/minorgridlinecolor/
             *         Bright grey lines from Y axis
             *
             * @type    {Highcharts.ColorType}
             * @default #f2f2f2
             */
            minorGridLineColor: "#f2f2f2" /* Palette.neutralColor5 */,
            /**
             * Width of the minor, secondary grid lines.
             *
             * In styled mode, the stroke width is given in the
             * `.highcharts-grid-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/
             *         2px lines from Y axis
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/minorgridlinewidth/
             *         2px lines from Y axis
             */
            minorGridLineWidth: 1,
            /**
             * Color for the minor tick marks.
             *
             * @sample {highcharts} highcharts/yaxis/minortickcolor/
             *         Black tick marks on Y axis
             * @sample {highstock} stock/xaxis/minorticks/
             *         Black tick marks on Y axis
             *
             * @type    {Highcharts.ColorType}
             * @default #999999
             */
            minorTickColor: "#999999" /* Palette.neutralColor40 */,
            /**
             * The color of the line marking the axis itself.
             *
             * In styled mode, the line stroke is given in the
             * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/linecolor/
             *         A red line on Y axis
             * @sample {highcharts|highstock} highcharts/css/axis/
             *         Axes in styled mode
             * @sample {highstock} stock/xaxis/linecolor/
             *         A red line on X axis
             *
             * @type    {Highcharts.ColorType}
             */
            lineColor: "#333333" /* Palette.neutralColor80 */,
            /**
             * The width of the line marking the axis itself.
             *
             * In styled mode, the stroke width is given in the
             * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/linecolor/
             *         A 1px line on Y axis
             * @sample {highcharts|highstock} highcharts/css/axis/
             *         Axes in styled mode
             * @sample {highstock} stock/xaxis/linewidth/
             *         A 2px line on X axis
             *
             * @default {highcharts|highstock} 1
             * @default {highmaps} 0
             */
            lineWidth: 1,
            /**
             * Color of the grid lines extending the ticks across the plot area.
             *
             * In styled mode, the stroke is given in the `.highcharts-grid-line`
             * class.
             *
             * @productdesc {highmaps}
             * In Highmaps, the grid lines are hidden by default.
             *
             * @sample {highcharts} highcharts/yaxis/gridlinecolor/
             *         Green lines
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/gridlinecolor/
             *         Green lines
             *
             * @type    {Highcharts.ColorType}
             * @default #e6e6e6
             */
            gridLineColor: "#e6e6e6" /* Palette.neutralColor10 */,
            /**
             * The width of the grid lines extending the ticks across the plot area.
             * Defaults to 1 on the Y axis and 0 on the X axis, except for 3d
             * charts.
             *
             * In styled mode, the stroke width is given in the
             * `.highcharts-grid-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/gridlinewidth/
             *         2px lines
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/gridlinewidth/
             *         2px lines
             *
             * @type      {number}
             * @apioption xAxis.gridLineWidth
             */
            gridLineWidth: void 0,
            /**
             * The height as the vertical axis. If it's a number, it is
             * interpreted as pixels.
             *
             * Since Highcharts 2: If it's a percentage string, it is interpreted
             * as percentages of the total plot height.
             *
             * @sample {highcharts} highcharts/xaxis/axis-position-properties
             *         Different axis position properties
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption xAxis.height
             */
            /**
             * The width as the horizontal axis. If it's a number, it is interpreted
             * as pixels.
             *
             * Since Highcharts v5.0.13: If it's a percentage string, it is
             * interpreted as percentages of the total plot width.
             *
             * @sample {highcharts} highcharts/xaxis/axis-position-properties
             *         Different axis position properties
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption xAxis.width
             */
            /**
             * Color for the main tick marks.
             *
             * In styled mode, the stroke is given in the `.highcharts-tick`
             * class.
             *
             * @sample {highcharts} highcharts/xaxis/tickcolor/
             *         Red ticks on X axis
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/ticks/
             *         Formatted ticks on X axis
             *
             * @type    {Highcharts.ColorType}
             */
            tickColor: "#333333" /* Palette.neutralColor80 */
            // `tickWidth: 1`
        };
        /**
         * The Z axis or depth axis for 3D plots.
         *
         * See the [Axis class](/class-reference/Highcharts.Axis) for programmatic
         * access to the axis.
         *
         * @sample {highcharts} highcharts/3d/scatter-zaxis-categories/
         *         Z-Axis with Categories
         * @sample {highcharts} highcharts/3d/scatter-zaxis-grid/
         *         Z-Axis with styling
         *
         * @type      {*|Array<*>}
         * @extends   xAxis
         * @since     5.0.0
         * @product   highcharts
         * @excluding breaks, crosshair, height, left, lineColor, lineWidth,
         *            nameToX, showEmpty, top, width
         * @apioption zAxis
         */
        /**
         * The Y axis or value axis. Normally this is the vertical axis,
         * though if the chart is inverted this is the horizontal axis.
         * In case of multiple axes, the yAxis node is an array of
         * configuration objects.
         *
         * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic
         * access to the axis.
         *
         * @type         {*|Array<*>}
         * @extends      xAxis
         * @excluding    currentDateIndicator,ordinal,overscroll
         * @optionparent yAxis
         */
        AxisDefaults.yAxis = {
            /**
             * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`,
             * `category` or `treegrid`. Defaults to `treegrid` for Gantt charts,
             * `linear` for other chart types.
             *
             * In a datetime axis, the numbers are given in milliseconds, and tick
             * marks are placed on appropriate values, like full hours or days. In a
             * category or treegrid axis, the [point names](#series.line.data.name)
             * of the chart's series are used for categories, if a
             * [categories](#xAxis.categories) array is not defined.
             *
             * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
             *         Logarithmic with minor grid lines
             * @sample {highcharts} highcharts/yaxis/type-log-negative/
             *         Logarithmic with extension to emulate negative values
             * @sample {gantt} gantt/treegrid-axis/demo
             *         Treegrid axis
             *
             * @type      {Highcharts.AxisTypeValue}
             * @default   {highcharts} linear
             * @default   {gantt} treegrid
             * @product   highcharts gantt
             * @apioption yAxis.type
             */
            /**
             * The height of the Y axis. If it's a number, it is interpreted as
             * pixels.
             *
             * Since Highcharts 2: If it's a percentage string, it is interpreted as
             * percentages of the total plot height.
             *
             * @see [yAxis.top](#yAxis.top)
             *
             * @sample {highstock} stock/demo/candlestick-and-volume/
             *         Percentage height panes
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption yAxis.height
             */
            /**
             * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
             * to represent the maximum value of the Y axis.
             *
             * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
             *         Min and max colors
             *
             * @type      {Highcharts.ColorType}
             * @default   #003399
             * @since     4.0
             * @product   highcharts
             * @apioption yAxis.maxColor
             */
            /**
             * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
             * to represent the minimum value of the Y axis.
             *
             * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
             *         Min and max color
             *
             * @type      {Highcharts.ColorType}
             * @default   #e6ebf5
             * @since     4.0
             * @product   highcharts
             * @apioption yAxis.minColor
             */
            /**
             * Whether to reverse the axis so that the highest number is closest
             * to the origin.
             *
             * @sample {highcharts} highcharts/yaxis/reversed/
             *         Reversed Y axis
             * @sample {highstock} stock/xaxis/reversed/
             *         Reversed Y axis
             *
             * @type      {boolean}
             * @default   {highcharts} false
             * @default   {highstock} false
             * @default   {highmaps} true
             * @default   {gantt} true
             * @apioption yAxis.reversed
             */
            /**
             * If `true`, the first series in a stack will be drawn on top in a
             * positive, non-reversed Y axis. If `false`, the first series is in
             * the base of the stack.
             *
             * @sample {highcharts} highcharts/yaxis/reversedstacks-false/
             *         Non-reversed stacks
             * @sample {highstock} highcharts/yaxis/reversedstacks-false/
             *         Non-reversed stacks
             *
             * @type      {boolean}
             * @default   true
             * @since     3.0.10
             * @product   highcharts highstock
             * @apioption yAxis.reversedStacks
             */
            reversedStacks: true,
            /**
             * Solid gauge series only. Color stops for the solid gauge. Use this
             * in cases where a linear gradient between a `minColor` and `maxColor`
             * is not sufficient. The stops is an array of tuples, where the first
             * item is a float between 0 and 1 assigning the relative position in
             * the gradient, and the second item is the color.
             *
             * For solid gauges, the Y axis also inherits the concept of
             * [data classes](https://api.highcharts.com/highmaps#colorAxis.dataClasses)
             * from the Highmaps color axis.
             *
             * @sample {highcharts} highcharts/demo/gauge-solid/
             *         Gauge with stops
             *
             * @see [minColor](#yAxis.minColor)
             * @see [maxColor](#yAxis.maxColor)
             *
             * @type      {Array<Array<number,Highcharts.ColorType>>}
             * @since     4.0
             * @product   highcharts
             * @apioption yAxis.stops
             */
            /**
             * The pixel width of the major tick marks.
             *
             * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width
             * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
             *
             * @type      {number}
             * @default   0
             * @product   highcharts highstock gantt
             * @apioption yAxis.tickWidth
             */
            /**
             * Whether to force the axis to end on a tick. Use this option with
             * the `maxPadding` option to control the axis end.
             *
             * This option is always disabled, when panning type is
             * either `y` or `xy`.
             *
             * @see [type](#chart.panning.type)
             *
             *
             * @sample {highcharts} highcharts/yaxis/endontick/
             *         True by default
             * @sample {highcharts} highcharts/yaxis/endontick-false/
             *         False
             * @sample {highstock} stock/demo/basic-line/
             *         True by default
             * @sample {highstock} stock/xaxis/endontick/
             *         False for Y axis
             *
             * @since 1.2.0
             */
            endOnTick: true,
            /**
             * Padding of the max value relative to the length of the axis. A
             * padding of 0.05 will make a 100px axis 5px longer. This is useful
             * when you don't want the highest data value to appear on the edge
             * of the plot area. When the axis' `max` option is set or a max extreme
             * is set using `axis.setExtremes()`, the maxPadding will be ignored.
             *
             * Also the `softThreshold` option takes precedence over `maxPadding`,
             * so if the data is tangent to the threshold, `maxPadding` may not
             * apply unless `softThreshold` is set to false.
             *
             * @sample {highcharts} highcharts/yaxis/maxpadding-02/
             *         Max padding of 0.2
             * @sample {highstock} stock/xaxis/minpadding-maxpadding/
             *         Greater min- and maxPadding
             *
             * @since   1.2.0
             * @product highcharts highstock gantt
             */
            maxPadding: 0.05,
            /**
             * Padding of the min value relative to the length of the axis. A
             * padding of 0.05 will make a 100px axis 5px longer. This is useful
             * when you don't want the lowest data value to appear on the edge
             * of the plot area. When the axis' `min` option is set or a max extreme
             * is set using `axis.setExtremes()`, the maxPadding will be ignored.
             *
             * Also the `softThreshold` option takes precedence over `minPadding`,
             * so if the data is tangent to the threshold, `minPadding` may not
             * apply unless `softThreshold` is set to false.
             *
             * @sample {highcharts} highcharts/yaxis/minpadding/
             *         Min padding of 0.2
             * @sample {highstock} stock/xaxis/minpadding-maxpadding/
             *         Greater min- and maxPadding
             *
             * @since   1.2.0
             * @product highcharts highstock gantt
             */
            minPadding: 0.05,
            /**
             * @productdesc {highstock}
             * In Highcharts Stock 1.x, the Y axis was placed
             * on the left side by default.
             *
             * @sample {highcharts} highcharts/yaxis/opposite/
             *         Secondary Y axis opposite
             * @sample {highstock} stock/xaxis/opposite/
             *         Y axis on left side
             *
             * @type      {boolean}
             * @default   {highstock} true
             * @default   {highcharts} false
             * @product   highstock highcharts gantt
             * @apioption yAxis.opposite
             */
            /**
             * @see [tickInterval](#xAxis.tickInterval)
             * @see [tickPositioner](#xAxis.tickPositioner)
             * @see [tickPositions](#xAxis.tickPositions)
             */
            tickPixelInterval: 72,
            /**
             * Whether to show the last tick label.
             *
             * @productdesc {highcharts|gantt}
             * Defaults to `true` on cartesian charts, and `false` on polar charts.
             *
             * @productdesc {highstock}
             * Defaults to `true` for categorized yAxis and `false` for other types
             * of yAxis.
             *
             * @default undefined
             */
            showLastLabel: true,
            /**
             * @extends xAxis.labels
             */
            labels: {
                /**
                 * The label's pixel distance from the perimeter of the plot area.
                 * On cartesian charts, this is overridden if the `labels.y` setting
                 * is set.
                 *
                 * On polar charts, if it's a percentage string, it is interpreted
                 * the same as [series.radius](#plotOptions.gauge.radius), so the
                 * label can be aligned under the gauge's shape.
                 *
                 * @sample {highcharts} highcharts/yaxis/labels-distance/
                 *         Polar chart, labels centered under the arc
                 *
                 * @type      {number|string}
                 * @product   highcharts
                 * @apioption yAxis.labels.distance
                 */
                /**
                 * The y position offset of all labels relative to the tick
                 * positions on the axis. For polar and radial axis consider the use
                 * of the [distance](#yAxis.labels.distance) option.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         Y axis labels placed on grid lines
                 *
                 * @type      {number}
                 * @default   {highcharts} 3
                 * @default   {highstock} -2
                 * @default   {highmaps} 3
                 * @apioption yAxis.labels.y
                 */
                /**
                 * What part of the string the given position is anchored to. Can
                 * be one of `"left"`, `"center"` or `"right"`. The exact position
                 * also depends on the `labels.x` setting.
                 *
                 * Angular gauges and solid gauges defaults to `"center"`.
                 * Solid gauges with two labels have additional option `"auto"`
                 * for automatic horizontal and vertical alignment.
                 *
                 * @sample {highcharts} highcharts/yaxis/labels-align-left/
                 *         Left
                 * @sample {highcharts} highcharts/series-solidgauge/labels-auto-aligned/
                 *         Solid gauge labels auto aligned
                 *
                 * @type       {Highcharts.AlignValue}
                 * @default    {highstock} right
                 * @apioption  yAxis.labels.align
                 */
                /**
                 * The x position offset of all labels relative to the tick
                 * positions on the axis. Defaults to -15 for left axis, 15 for
                 * right axis.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         Y axis labels placed on grid lines
                 *
                 * @type {number}
                 */
                x: void 0
            },
            /**
             * @sample {highcharts} highcharts/yaxis/max-200/
             *         Y axis max of 200
             * @sample {highcharts} highcharts/yaxis/max-logarithmic/
             *         Y axis max on logarithmic axis
             * @sample {highstock} stock/yaxis/min-max/
             *         Fixed min and max on Y axis
             *
             * @apioption yAxis.max
             */
            /**
             * @sample {highcharts} highcharts/yaxis/min-startontick-false/
             *         -50 with startOnTick to false
             * @sample {highcharts} highcharts/yaxis/min-startontick-true/
             *         -50 with startOnTick true by default
             * @sample {highstock} stock/yaxis/min-max/
             *         Fixed min and max on Y axis
             *
             * @apioption yAxis.min
             */
            /**
             * An optional scrollbar to display on the Y axis in response to
             * limiting the minimum an maximum of the axis values.
             *
             * In styled mode, all the presentational options for the scrollbar
             * are replaced by the classes `.highcharts-scrollbar-thumb`,
             * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
             * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
             *
             * @sample {highstock} stock/yaxis/scrollbar/
             *         Scrollbar on the Y axis
             *
             * @extends   scrollbar
             * @since     4.2.6
             * @product   highstock
             * @excluding height
             * @apioption yAxis.scrollbar
             */
            /**
             * Enable the scrollbar on the Y axis.
             *
             * @sample {highstock} stock/yaxis/scrollbar/
             *         Enabled on Y axis
             *
             * @type      {boolean}
             * @default   false
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.enabled
             */
            /**
             * Pixel margin between the scrollbar and the axis elements.
             *
             * @type      {number}
             * @default   10
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.margin
             */
            /* eslint-disable highcharts/doclet-apioption-last */
            /**
             * Defines the position of the scrollbar. By default, it is positioned
             * on the opposite of the main axis (right side of the chart).
             * However, in the case of RTL languages could be set to `false`
             * which positions the scrollbar on the left.
             *
             * Works only for vertical axes.
             * This means yAxis in a non-inverted chart and xAxis in the inverted.
             *
             * @sample stock/yaxis/scrollbar-opposite/
             *         A scrollbar not on the opposite side
             *
             * @type      {boolean}
             * @default   true
             * @since 9.3.0
             *
             * @apioption yAxis.scrollbar.opposite
             * @apioption xAxis.scrollbar.opposite
             *
             */
            /* eslint-enable highcharts/doclet-apioption-last */
            /**
             * Whether to show the scrollbar when it is fully zoomed out at max
             * range. Setting it to `false` on the Y axis makes the scrollbar stay
             * hidden until the user zooms in, like common in browsers.
             *
             * @type      {boolean}
             * @default   true
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.showFull
             */
            /**
             * The width of a vertical scrollbar or height of a horizontal
             * scrollbar. Defaults to 20 on touch devices.
             *
             * @type      {number}
             * @default   14
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.size
             */
            /**
             * Z index of the scrollbar elements.
             *
             * @type      {number}
             * @default   3
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.zIndex
             */
            /**
             * A soft maximum for the axis. If the series data maximum is less
             * than this, the axis will stay at this maximum, but if the series
             * data maximum is higher, the axis will flex to show all data.
             *
             * **Note**: The [series.softThreshold](
             * #plotOptions.series.softThreshold) option takes precedence over this
             * option.
             *
             * @sample highcharts/yaxis/softmin-softmax/
             *         Soft min and max
             *
             * @type      {number}
             * @since     5.0.1
             * @product   highcharts highstock gantt
             * @apioption yAxis.softMax
             */
            /**
             * A soft minimum for the axis. If the series data minimum is greater
             * than this, the axis will stay at this minimum, but if the series
             * data minimum is lower, the axis will flex to show all data.
             *
             * **Note**: The [series.softThreshold](
             * #plotOptions.series.softThreshold) option takes precedence over this
             * option.
             *
             * @sample highcharts/yaxis/softmin-softmax/
             *         Soft min and max
             *
             * @type      {number}
             * @since     5.0.1
             * @product   highcharts highstock gantt
             * @apioption yAxis.softMin
             */
            /**
             * Defines the horizontal alignment of the stack total label. Can be one
             * of `"left"`, `"center"` or `"right"`. The default value is calculated
             * at runtime and depends on orientation and whether the stack is
             * positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/
             *         Aligned to the left
             * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/
             *         Aligned in center
             * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/
             *         Aligned to the right
             *
             * @type      {Highcharts.AlignValue}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.align
             */
            /**
             * A format string for the data label. Available variables are the same
             * as for `formatter`.
             *
             * @type      {string}
             * @default   {total}
             * @since     3.0.2
             * @product   highcharts highstock
             * @apioption yAxis.stackLabels.format
             */
            /**
             * Rotation of the labels in degrees.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/
             *         Labels rotated 45°
             *
             * @type      {number}
             * @default   0
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.rotation
             */
            /**
             * The text alignment for the label. While `align` determines where the
             * texts anchor point is placed with regards to the stack, `textAlign`
             * determines how the text is aligned against its anchor point. Possible
             * values are `"left"`, `"center"` and `"right"`. The default value is
             * calculated at runtime and depends on orientation and whether the
             * stack is positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/
             *         Label in center position but text-aligned left
             *
             * @type      {Highcharts.AlignValue}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.textAlign
             */
            /**
             * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the labels.
             *
             * @type      {boolean}
             * @default   false
             * @since     3.0
             * @product   highcharts highstock
             * @apioption yAxis.stackLabels.useHTML
             */
            /**
             * Defines the vertical alignment of the stack total label. Can be one
             * of `"top"`, `"middle"` or `"bottom"`. The default value is calculated
             * at runtime and depends on orientation and whether the stack is
             * positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/
             *         Vertically aligned top
             * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/
             *         Vertically aligned middle
             * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/
             *         Vertically aligned bottom
             *
             * @type      {Highcharts.VerticalAlignValue}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.verticalAlign
             */
            /**
             * The x position offset of the label relative to the left of the
             * stacked bar. The default value is calculated at runtime and depends
             * on orientation and whether the stack is positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-x/
             *         Stack total labels with x offset
             *
             * @type      {number}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.x
             */
            /**
             * The y position offset of the label relative to the tick position
             * on the axis. The default value is calculated at runtime and depends
             * on orientation and whether the stack is positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-y/
             *         Stack total labels with y offset
             *
             * @type      {number}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.y
             */
            /**
             * Whether to force the axis to start on a tick. Use this option with
             * the `maxPadding` option to control the axis start.
             *
             * This option is always disabled, when panning type is
             * either `y` or `xy`.
             *
             * @see [type](#chart.panning.type)
             *
             * @sample {highcharts} highcharts/xaxis/startontick-false/
             *         False by default
             * @sample {highcharts} highcharts/xaxis/startontick-true/
             *         True
             * @sample {highstock} stock/xaxis/endontick/
             *         False for Y axis
             *
             * @since   1.2.0
             * @product highcharts highstock gantt
             */
            startOnTick: true,
            title: {
                /**
                 * The pixel distance between the axis labels and the title.
                 * Positive values are outside the axis line, negative are inside.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-margin/
                 *         Y axis title margin of 60
                 *
                 * @type      {number}
                 * @default   40
                 * @apioption yAxis.title.margin
                 */
                /**
                 * The actual text of the axis title. Horizontal texts can contain
                 * HTML, but rotated texts are painted using vector techniques and
                 * must be clean text. The Y axis title is disabled by setting the
                 * `text` option to `undefined`.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-text/
                 *         Custom HTML
                 *
                 * @type    {string|null}
                 * @default {highcharts} Values
                 * @default {highstock} undefined
                 * @product highcharts highstock gantt
                 */
                text: 'Values'
            },
            /**
             * The top position of the Y axis. If it's a number, it is interpreted
             * as pixel position relative to the chart.
             *
             * Since Highcharts 2: If it's a percentage string, it is interpreted as
             * percentages of the plot height, offset from plot area top.
             *
             * @see [yAxis.height](#yAxis.height)
             *
             * @sample {highstock} stock/demo/candlestick-and-volume/
             *         Percentage height panes
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption yAxis.top
             */
            /**
             * The stack labels show the total value for each bar in a stacked
             * column or bar chart. The label will be placed on top of positive
             * columns and below negative columns. In case of an inverted column
             * chart or a bar chart the label is placed to the right of positive
             * bars and to the left of negative bars.
             *
             * @product highcharts
             */
            stackLabels: {
                /**
                 * Enable or disable the initial animation when a series is
                 * displayed for the `stackLabels`. The animation can also be set as
                 * a configuration object. Please note that this option only
                 * applies to the initial animation.
                 * For other animations, see [chart.animation](#chart.animation)
                 * and the animation parameter under the API methods.
                 * The following properties are supported:
                 *
                 * - `defer`: The animation delay time in milliseconds.
                 *
                 * @sample {highcharts} highcharts/plotoptions/animation-defer/
                 *          Animation defer settings
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @since 8.2.0
                 * @apioption yAxis.stackLabels.animation
                 */
                animation: {},
                /**
                 * The animation delay time in milliseconds.
                 * Set to `0` renders stackLabel immediately.
                 * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
                 *
                 * @type      {number}
                 * @since 8.2.0
                 * @apioption yAxis.stackLabels.animation.defer
                 */
                /**
                 * Allow the stack labels to overlap.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
                 *         Default false
                 *
                 * @since   5.0.13
                 * @product highcharts
                 */
                allowOverlap: false,
                /**
                 * The background color or gradient for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {Highcharts.ColorType}
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.backgroundColor
                 */
                /**
                 * The border color for the stack label. Defaults to `undefined`.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {Highcharts.ColorType}
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderColor
                 */
                /**
                 * The border radius in pixels for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {number}
                 * @default   0
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderRadius
                 */
                /**
                 * The border width in pixels for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {number}
                 * @default   0
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderWidth
                 */
                /**
                 * Enable or disable the stack total labels.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/
                 *         Enabled stack total labels
                 * @sample {highcharts} highcharts/yaxis/stacklabels-enabled-waterfall/
                 *         Enabled stack labels in waterfall chart
                 *
                 * @since   2.1.5
                 * @product highcharts
                 */
                enabled: false,
                /**
                 * Whether to hide stack labels that are outside the plot area.
                 * By default, the stack label is moved
                 * inside the plot area according to the
                 * [overflow](/highcharts/#yAxis/stackLabels/overflow)
                 * option.
                 *
                 * @type  {boolean}
                 * @since 7.1.3
                 */
                crop: true,
                /**
                 * How to handle stack total labels that flow outside the plot area.
                 * The default is set to `"justify"`,
                 * which aligns them inside the plot area.
                 * For columns and bars, this means it will be moved inside the bar.
                 * To display stack labels outside the plot area,
                 * set `crop` to `false` and `overflow` to `"allow"`.
                 *
                 * @sample highcharts/yaxis/stacklabels-overflow/
                 *         Stack labels flows outside the plot area.
                 *
                 * @type  {Highcharts.DataLabelsOverflowValue}
                 * @since 7.1.3
                 */
                overflow: 'justify',
                /* eslint-disable valid-jsdoc */
                /**
                 * Callback JavaScript function to format the label. The value is
                 * given by `this.total`.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/
                 *         Added units to stack total value
                 *
                 * @type    {Highcharts.FormatterCallbackFunction<Highcharts.StackItemObject>}
                 * @since   2.1.5
                 * @product highcharts
                 */
                formatter: function () {
                    const { numberFormatter } = this.axis.chart;
                    /* eslint-enable valid-jsdoc */
                    return numberFormatter(this.total || 0, -1);
                },
                /**
                 * CSS styles for the label.
                 *
                 * In styled mode, the styles are set in the
                 * `.highcharts-stack-label` class.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-style/
                 *         Red stack total labels
                 *
                 * @type    {Highcharts.CSSObject}
                 * @since   2.1.5
                 * @product highcharts
                 */
                style: {
                    /** @internal */
                    color: "#000000" /* Palette.neutralColor100 */,
                    /** @internal */
                    fontSize: '0.7em',
                    /** @internal */
                    fontWeight: 'bold',
                    /** @internal */
                    textOutline: '1px contrast'
                }
            },
            gridLineWidth: 1,
            lineWidth: 0
        };
    })(AxisDefaults || (AxisDefaults = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var AxisDefaults$1 = AxisDefaults;

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  API Options
     *
     * */
    /**
     * General options for the chart.
     *
     * @optionparent chart
     */
    const ChartDefaults = {
        /**
         * Default `mapData` for all series, in terms of a GeoJSON or TopoJSON
         * object. If set to a string, it functions as an index into the
         * `Highcharts.maps` array.
         *
         * For picking out individual shapes and geometries to use for each series
         * of the map, see [series.mapData](#series.map.mapData).
         *
         * @sample    maps/demo/geojson
         *            Loading GeoJSON data
         * @sample    maps/chart/topojson
         *            Loading TopoJSON data
         *
         * @type      {string|Array<*>|Highcharts.GeoJSON|Highcharts.TopoJSON}
         * @since     5.0.0
         * @product   highmaps
         * @apioption chart.map
         */
        /**
         * Set lat/lon transformation definitions for the chart. If not defined,
         * these are extracted from the map data.
         *
         * @type      {*}
         * @since     5.0.0
         * @product   highmaps
         * @apioption chart.mapTransforms
         */
        /**
         * When using multiple axes, the ticks of two or more opposite axes
         * will automatically be aligned by adding ticks to the axis or axes
         * with the least ticks, as if `tickAmount` were specified.
         *
         * This can be prevented by setting `alignTicks` to false. If the grid
         * lines look messy, it's a good idea to hide them for the secondary
         * axis by setting `gridLineWidth` to 0.
         *
         * If `startOnTick` or `endOnTick` in the axis options are set to false,
         * then the `alignTicks ` will be disabled for the axis.
         *
         * Disabled for logarithmic axes.
         *
         * @sample {highcharts} highcharts/chart/alignticks-true/
         *         True by default
         * @sample {highcharts} highcharts/chart/alignticks-false/
         *         False
         * @sample {highstock} stock/chart/alignticks-true/
         *         True by default
         * @sample {highstock} stock/chart/alignticks-false/
         *         False
         *
         * @type      {boolean}
         * @default   true
         * @product   highcharts highstock gantt
         * @apioption chart.alignTicks
         */
        /**
         * When using multiple axes, align the thresholds. When this is true, other
         * ticks will also be aligned.
         *
         * Note that for line series and some other series types, the `threshold`
         * option is set to `null` by default. This will in turn cause their y-axis
         * to not have a threshold. In order to avoid that, set the series
         * `threshold` to 0 or another number.
         *
         * If `startOnTick` or `endOnTick` in the axis options are set to false, or
         * if the axis is logarithmic, the threshold will not be aligned.
         *
         * @sample {highcharts} highcharts/chart/alignthresholds/ Set to true
         *
         * @since 10.0.0
         * @product   highcharts highstock gantt
         * @apioption chart.alignThresholds
         */
        alignThresholds: false,
        /**
         * Set the overall animation for all chart updating. Animation can be
         * disabled throughout the chart by setting it to false here. It can
         * be overridden for each individual API method as a function parameter.
         * The only animation not affected by this option is the initial series
         * animation, see [plotOptions.series.animation](
         * #plotOptions.series.animation).
         *
         * The animation can either be set as a boolean or a configuration
         * object. If `true`, it will use the 'swing' jQuery easing and a
         * duration of 500 ms. If used as a configuration object, the following
         * properties are supported:
         *
         * - `defer`: The animation delay time in milliseconds.
         *
         * - `duration`: The duration of the animation in milliseconds.
         *
         * - `easing`: A string reference to an easing function set on the
         *   `Math` object. See
         *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
         *
         * When zooming on a series with less than 100 points, the chart redraw
         * will be done with animation, but in case of more data points, it is
         * necessary to set this option to ensure animation on zoom.
         *
         * @sample {highcharts} highcharts/chart/animation-none/
         *         Updating with no animation
         * @sample {highcharts} highcharts/chart/animation-duration/
         *         With a longer duration
         * @sample {highcharts} highcharts/chart/animation-easing/
         *         With a jQuery UI easing
         * @sample {highmaps} maps/chart/animation-none/
         *         Updating with no animation
         * @sample {highmaps} maps/chart/animation-duration/
         *         With a longer duration
         *
         * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
         * @default   true
         * @apioption chart.animation
         */
        /**
         * A CSS class name to apply to the charts container `div`, allowing
         * unique CSS styling for each chart.
         *
         * @type      {string}
         * @apioption chart.className
         */
        /**
         * Event listeners for the chart.
         *
         * @apioption chart.events
         */
        /**
         * Fires when a series is added to the chart after load time, using the
         * `addSeries` method. One parameter, `event`, is passed to the
         * function, containing common event information. Through
         * `event.options` you can access the series options that were passed to
         * the `addSeries` method. Returning false prevents the series from
         * being added.
         *
         * @sample {highcharts} highcharts/chart/events-addseries/
         *         Alert on add series
         * @sample {highstock} stock/chart/events-addseries/
         *         Alert on add series
         *
         * @type      {Highcharts.ChartAddSeriesCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Chart
         * @apioption chart.events.addSeries
         */
        /**
         * Fires when clicking on the plot background. One parameter, `event`,
         * is passed to the function, containing common event information.
         *
         * Information on the clicked spot can be found through `event.xAxis`
         * and `event.yAxis`, which are arrays containing the axes of each
         * dimension and each axis' value at the clicked spot. The primary axes
         * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
         * datetime axis is milliseconds since 1970-01-01 00:00:00.
         *
         * ```js
         * click: function(e) {
         *     console.log(
         *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
         *         e.yAxis[0].value
         *     )
         * }
         * ```
         *
         * @sample {highcharts} highcharts/chart/events-click/
         *         Alert coordinates on click
         * @sample {highcharts} highcharts/chart/events-container/
         *         Alternatively, attach event to container
         * @sample {highstock} stock/chart/events-click/
         *         Alert coordinates on click
         * @sample {highstock} highcharts/chart/events-container/
         *         Alternatively, attach event to container
         * @sample {highmaps} maps/chart/events-click/
         *         Record coordinates on click
         * @sample {highmaps} highcharts/chart/events-container/
         *         Alternatively, attach event to container
         *
         * @type      {Highcharts.ChartClickCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Chart
         * @apioption chart.events.click
         */
        /**
         * Fires when the chart is finished loading. Since v4.2.2, it also waits
         * for images to be loaded, for example from point markers. One
         * parameter, `event`, is passed to the function, containing common
         * event information.
         *
         * There is also a second parameter to the chart constructor where a
         * callback function can be passed to be executed on chart.load.
         *
         * @sample {highcharts} highcharts/chart/events-load/
         *         Alert on chart load
         * @sample {highcharts} highcharts/chart/events-render/
         *         Load vs Redraw vs Render
         * @sample {highstock} stock/chart/events-load/
         *         Alert on chart load
         * @sample {highmaps} maps/chart/events-load/
         *         Add series on chart load
         *
         * @type      {Highcharts.ChartLoadCallbackFunction}
         * @context   Highcharts.Chart
         * @apioption chart.events.load
         */
        /**
         * Fires when the chart is redrawn, either after a call to
         * `chart.redraw()` or after an axis, series or point is modified with
         * the `redraw` option set to `true`. One parameter, `event`, is passed
         * to the function, containing common event information.
         *
         * @sample {highcharts} highcharts/chart/events-redraw/
         *         Alert on chart redraw
         * @sample {highcharts} highcharts/chart/events-render/
         *         Load vs Redraw vs Render
         * @sample {highstock} stock/chart/events-redraw/
         *         Alert on chart redraw when adding a series or moving the
         *         zoomed range
         * @sample {highmaps} maps/chart/events-redraw/
         *         Set subtitle on chart redraw
         *
         * @type      {Highcharts.ChartRedrawCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Chart
         * @apioption chart.events.redraw
         */
        /**
         * Fires after initial load of the chart (directly after the `load`
         * event), and after each redraw (directly after the `redraw` event).
         *
         * @sample {highcharts} highcharts/chart/events-render/
         *         Load vs Redraw vs Render
         *
         * @type      {Highcharts.ChartRenderCallbackFunction}
         * @since     5.0.7
         * @context   Highcharts.Chart
         * @apioption chart.events.render
         */
        /**
         * Fires when an area of the chart has been selected. Selection is
         * enabled by setting the chart's zoomType. One parameter, `event`, is
         * passed to the function, containing common event information. The
         * default action for the selection event is to zoom the chart to the
         * selected area. It can be prevented by calling
         * `event.preventDefault()` or return false.
         *
         * Information on the selected area can be found through `event.xAxis`
         * and `event.yAxis`, which are arrays containing the axes of each
         * dimension and each axis' min and max values. The primary axes are
         * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
         * datetime axis is milliseconds since 1970-01-01 00:00:00.
         *
         * ```js
         * selection: function(event) {
         *     // log the min and max of the primary, datetime x-axis
         *     console.log(
         *         Highcharts.dateFormat(
         *             '%Y-%m-%d %H:%M:%S',
         *             event.xAxis[0].min
         *         ),
         *         Highcharts.dateFormat(
         *             '%Y-%m-%d %H:%M:%S',
         *             event.xAxis[0].max
         *         )
         *     );
         *     // log the min and max of the y axis
         *     console.log(event.yAxis[0].min, event.yAxis[0].max);
         * }
         * ```
         *
         * @sample {highcharts} highcharts/chart/events-selection/
         *         Report on selection and reset
         * @sample {highcharts} highcharts/chart/events-selection-points/
         *         Select a range of points through a drag selection
         * @sample {highstock} stock/chart/events-selection/
         *         Report on selection and reset
         * @sample {highstock} highcharts/chart/events-selection-points/
         *         Select a range of points through a drag selection
         *         (Highcharts)
         *
         * @type      {Highcharts.ChartSelectionCallbackFunction}
         * @apioption chart.events.selection
         */
        /**
         * The margin between the outer edge of the chart and the plot area.
         * The numbers in the array designate top, right, bottom and left
         * respectively. Use the options `marginTop`, `marginRight`,
         * `marginBottom` and `marginLeft` for shorthand setting of one option.
         *
         * By default there is no margin. The actual space is dynamically
         * calculated from the offset of axis labels, axis title, title,
         * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
         * `spacingBottom` and `spacingLeft` options.
         *
         * @sample {highcharts} highcharts/chart/margins-zero/
         *         Zero margins
         * @sample {highstock} stock/chart/margin-zero/
         *         Zero margins
         *
         * @type      {number|Array<number>}
         * @apioption chart.margin
         */
        /**
         * The margin between the bottom outer edge of the chart and the plot
         * area. Use this to set a fixed pixel value for the margin as opposed
         * to the default dynamic margin. See also `spacingBottom`.
         *
         * @sample {highcharts} highcharts/chart/marginbottom/
         *         100px bottom margin
         * @sample {highstock} stock/chart/marginbottom/
         *         100px bottom margin
         * @sample {highmaps} maps/chart/margin/
         *         100px margins
         *
         * @type      {number}
         * @since     2.0
         * @apioption chart.marginBottom
         */
        /**
         * The margin between the left outer edge of the chart and the plot
         * area. Use this to set a fixed pixel value for the margin as opposed
         * to the default dynamic margin. See also `spacingLeft`.
         *
         * @sample {highcharts} highcharts/chart/marginleft/
         *         150px left margin
         * @sample {highstock} stock/chart/marginleft/
         *         150px left margin
         * @sample {highmaps} maps/chart/margin/
         *         100px margins
         *
         * @type      {number}
         * @since     2.0
         * @apioption chart.marginLeft
         */
        /**
         * The margin between the right outer edge of the chart and the plot
         * area. Use this to set a fixed pixel value for the margin as opposed
         * to the default dynamic margin. See also `spacingRight`.
         *
         * @sample {highcharts} highcharts/chart/marginright/
         *         100px right margin
         * @sample {highstock} stock/chart/marginright/
         *         100px right margin
         * @sample {highmaps} maps/chart/margin/
         *         100px margins
         *
         * @type      {number}
         * @since     2.0
         * @apioption chart.marginRight
         */
        /**
         * The margin between the top outer edge of the chart and the plot area.
         * Use this to set a fixed pixel value for the margin as opposed to
         * the default dynamic margin. See also `spacingTop`.
         *
         * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
         * @sample {highstock} stock/chart/margintop/
         *         100px top margin
         * @sample {highmaps} maps/chart/margin/
         *         100px margins
         *
         * @type      {number}
         * @since     2.0
         * @apioption chart.marginTop
         */
        /**
         * Callback function to override the default function that formats all
         * the numbers in the chart. Returns a string with the formatted number.
         *
         * @sample highcharts/members/highcharts-numberformat
         *      Arabic digits in Highcharts
         * @type {Highcharts.NumberFormatterCallbackFunction}
         * @since 8.0.0
         * @apioption chart.numberFormatter
         */
        /**
         * When a chart with an x and a y-axis is rendered, we first pre-render the
         * labels of both in order to measure them. Then, if either of the axis
         * labels take up so much space that it significantly affects the length of
         * the other axis, we repeat the process.
         *
         * By default we stop at two axis layout runs, but it may be that the second
         * run also alter the space required by either axis, for example if it
         * causes the labels to rotate. In this situation, a subsequent redraw of
         * the chart may cause the tick and label placement to change for apparently
         * no reason.
         *
         * Use the `axisLayoutRuns` option to set the maximum allowed number of
         * repetitions. But keep in mind that the default value of 2 is set because
         * every run costs performance time.
         *
         * **Note:** Changing that option to higher than the default might decrease
         * performance significantly, especially with bigger sets of data.
         *
         * @type      {number}
         * @default   2
         * @since     11.3.0
         * @apioption chart.axisLayoutRuns
         */
        /**
         * Allows setting a key to switch between zooming and panning. Can be
         * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
         * key on Windows) or `shift`. The keys are mapped directly to the key
         * properties of the click event argument (`event.altKey`,
         * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
         *
         * @type       {string}
         * @since      4.0.3
         * @product    highcharts gantt
         * @validvalue ["alt", "ctrl", "meta", "shift"]
         * @apioption  chart.panKey
         */
        /**
         * Allow panning in a chart. Best used with [panKey](#chart.panKey)
         * to combine zooming and panning.
         *
         * On touch devices, when the [tooltip.followTouchMove](
         * #tooltip.followTouchMove) option is `true` (default), panning
         * requires two fingers. To allow panning with one finger, set
         * `followTouchMove` to `false`.
         *
         * @sample  {highcharts} highcharts/chart/pankey/ Zooming and panning
         * @sample  {highstock} stock/chart/panning/ Zooming and xy panning
         */
        panning: {
            /**
             * Enable or disable chart panning.
             *
             * @type      {boolean}
             * @default   {highcharts} false
             * @default   {highstock|highmaps} true
             */
            enabled: false,
            /**
             * Decides in what dimensions the user can pan the chart. Can be
             * one of `x`, `y`, or `xy`.
             *
             * When this option is set to `y` or `xy`, [yAxis.startOnTick](#yAxis.startOnTick)
             * and [yAxis.endOnTick](#yAxis.endOnTick) are overwritten to `false`.
             *
             * @sample {highcharts} highcharts/chart/panning-type
             *         Zooming and xy panning
             *
             * @declare    Highcharts.OptionsChartPanningTypeValue
             * @type       {string}
             * @validvalue ["x", "y", "xy"]
             * @default    {highcharts|highstock} x
             * @product    highcharts highstock gantt
             */
            type: 'x'
        },
        /**
         * Equivalent to [zoomType](#chart.zoomType), but for multitouch
         * gestures only. By default, the `pinchType` is the same as the
         * `zoomType` setting. However, pinching can be enabled separately in
         * some cases, for example in stock charts where a mouse drag pans the
         * chart, while pinching is enabled. When [tooltip.followTouchMove](
         * #tooltip.followTouchMove) is true, pinchType only applies to
         * two-finger touches.
         *
         * @type       {string}
         * @default    {highcharts} undefined
         * @default    {highstock} undefined
         * @since      3.0
         * @product    highcharts highstock gantt
         * @deprecated
         * @validvalue ["x", "y", "xy"]
         * @apioption  chart.pinchType
         */
        /**
         * Whether to apply styled mode. When in styled mode, no presentational
         * attributes or CSS are applied to the chart SVG. Instead, CSS rules
         * are required to style the chart. The default style sheet is
         * available from `https://code.highcharts.com/css/highcharts.css`.
         *
         * [Read more in the docs](https://www.highcharts.com/docs/chart-design-and-style/style-by-css)
         * on what classes and variables are available.
         *
         * @sample highcharts/css/colors
         *         Color theming with CSS
         * @sample highcharts/css/prefers-color-scheme
         *         Dynamic theme based on system settings
         * @type       {boolean}
         * @default    false
         * @since      7.0
         * @apioption  chart.styledMode
         */
        styledMode: false,
        /**
         * The corner radius of the outer chart border.
         *
         * @sample {highcharts} highcharts/chart/borderradius/
         *         20px radius
         * @sample {highstock} stock/chart/border/
         *         10px radius
         * @sample {highmaps} maps/chart/border/
         *         Border options
         *
         */
        borderRadius: 0,
        /**
         * In styled mode, this sets how many colors the class names
         * should rotate between. With ten colors, series (or points) are
         * given class names like `highcharts-color-0`, `highcharts-color-1`
         * [...] `highcharts-color-9`. The equivalent in non-styled mode
         * is to set colors using the [colors](#colors) setting.
         *
         * @since      5.0.0
         */
        colorCount: 10,
        /**
         * By default, (because of memory and performance reasons) the chart does
         * not copy the data but keeps it as a reference. In some cases, this might
         * result in mutating the original data source. In order to prevent that,
         * set that property to false. Please note that changing that might decrease
         * performance, especially with bigger sets of data.
         *
         * @type       {boolean}
         * @since 10.1.0
         */
        allowMutatingData: true,
        /**
         * If true, the axes will scale to the remaining visible series once
         * one series is hidden. If false, hiding and showing a series will
         * not affect the axes or the other series. For stacks, once one series
         * within the stack is hidden, the rest of the stack will close in
         * around it even if the axis is not affected.
         *
         * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
         *         True by default
         * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
         *         False
         * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
         *         True with stack
         * @sample {highstock} stock/chart/ignorehiddenseries-true/
         *         True by default
         * @sample {highstock} stock/chart/ignorehiddenseries-false/
         *         False
         *
         * @since   1.2.0
         * @product highcharts highstock gantt
         */
        ignoreHiddenSeries: true,
        /**
         * Whether to invert the axes so that the x axis is vertical and y axis
         * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
         * by default.
         *
         * @productdesc {highcharts}
         * If a bar series is present in the chart, it will be inverted
         * automatically. Inverting the chart doesn't have an effect if there
         * are no cartesian series in the chart.
         *
         * @sample {highcharts} highcharts/chart/inverted/
         *         Inverted line
         * @sample {highstock} stock/navigator/inverted/
         *         Inverted stock chart
         *
         * @type      {boolean}
         * @default   false
         * @product   highcharts highstock gantt
         * @apioption chart.inverted
         */
        /**
         * The distance between the outer edge of the chart and the content,
         * like title or legend, or axis title and labels if present. The
         * numbers in the array designate top, right, bottom and left
         * respectively. Use the options spacingTop, spacingRight, spacingBottom
         * and spacingLeft options for shorthand setting of one option.
         *
         * @type    {Array<number>}
         * @see     [chart.margin](#chart.margin)
         * @default [10, 10, 15, 10]
         * @since   3.0.6
         */
        spacing: [10, 10, 15, 10],
        /**
         * The button that appears after a selection zoom, allowing the user
         * to reset zoom. This option is deprecated in favor of
         * [zooming](#chart.zooming).
         *
         * @since      2.2
         * @deprecated 10.2.1
         */
        resetZoomButton: {
            /**
             * What frame the button placement should be related to. Can be
             * either `plotBox` or `spacingBox`.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
             *         Relative to the chart
             * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
             *         Relative to the chart
             *
             * @type      {Highcharts.ButtonRelativeToValue}
             * @apioption chart.resetZoomButton.relativeTo
             */
            /**
             * A collection of attributes for the button. The object takes SVG
             * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
             * border radius. The theme also supports `style`, a collection of
             * CSS properties for the text. Equivalent attributes for the hover
             * state are given in `theme.states.hover`.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
             *         Theming the button
             * @sample {highstock} highcharts/chart/resetzoombutton-theme/
             *         Theming the button
             *
             * @type {Highcharts.SVGAttributes}
             */
            theme: {
            /**
             * The z-index of the button.
             *
             * @type {number}
             * @apioption chart.resetZoomButton.theme.zIndex
             */
            },
            /**
             * The position of the button.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             * @sample {highstock} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             * @sample {highmaps} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             *
             * @type {Highcharts.AlignObject}
             */
            position: {
            /**
             * The horizontal alignment of the button.
             *
             * @type {number}
             * @apioption chart.resetZoomButton.position.align
             */
            /**
             * The horizontal offset of the button.
             *
             * @type {number}
             * @apioption chart.resetZoomButton.position.x
             */
            /**
             * The vertical alignment of the button.
             *
             * @type      {Highcharts.VerticalAlignValue}
             * @apioption chart.resetZoomButton.position.verticalAlign
             */
            /**
             * The vertical offset of the button.
             *
             * @type {number}
             * @apioption chart.resetZoomButton.position.y
             */
            }
        },
        /**
         * The pixel width of the plot area border.
         *
         * @sample {highcharts} highcharts/chart/plotborderwidth/
         *         1px border
         * @sample {highstock} stock/chart/plotborder/
         *         2px border
         * @sample {highmaps} maps/chart/plotborder/
         *         Plot border options
         *
         * @type      {number}
         * @default   0
         * @apioption chart.plotBorderWidth
         */
        /**
         * Whether to apply a drop shadow to the plot area. Requires that
         * plotBackgroundColor be set. The shadow can be an object configuration
         * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
         *
         * @sample {highcharts} highcharts/chart/plotshadow/
         *         Plot shadow
         * @sample {highstock} stock/chart/plotshadow/
         *         Plot shadow
         * @sample {highmaps} maps/chart/plotborder/
         *         Plot border options
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @apioption chart.plotShadow
         */
        /**
         * When true, cartesian charts like line, spline, area and column are
         * transformed into the polar coordinate system. This produces _polar
         * charts_, also known as _radar charts_.
         *
         * @sample {highcharts} highcharts/demo/polar/
         *         Polar chart
         * @sample {highcharts} highcharts/demo/polar-wind-rose/
         *         Wind rose, stacked polar column chart
         * @sample {highcharts} highcharts/demo/polar-spider/
         *         Spider web chart
         * @sample {highcharts} highcharts/parallel-coordinates/polar/
         *         Star plot, multivariate data in a polar chart
         *
         * @type      {boolean}
         * @default   false
         * @since     2.3.0
         * @product   highcharts
         * @requires  highcharts-more
         * @apioption chart.polar
         */
        /**
         * Whether to reflow the chart to fit the width of the container div
         * on resizing the window.
         *
         * @sample {highcharts} highcharts/chart/reflow-true/
         *         True by default
         * @sample {highcharts} highcharts/chart/reflow-false/
         *         False
         * @sample {highstock} stock/chart/reflow-true/
         *         True by default
         * @sample {highstock} stock/chart/reflow-false/
         *         False
         * @sample {highmaps} maps/chart/reflow-true/
         *         True by default
         * @sample {highmaps} maps/chart/reflow-false/
         *         False
         *
         * @since     2.1
         */
        reflow: true,
        /**
         * The HTML element where the chart will be rendered. If it is a string,
         * the element by that id is used. The HTML element can also be passed
         * by direct reference, or as the first argument of the chart
         * constructor, in which case the option is not needed.
         *
         * @sample {highcharts} highcharts/chart/reflow-true/
         *         String
         * @sample {highcharts} highcharts/chart/renderto-object/
         *         Object reference
         * @sample {highstock} stock/chart/renderto-string/
         *         String
         * @sample {highstock} stock/chart/renderto-object/
         *         Object reference
         *
         * @type      {string|Highcharts.HTMLDOMElement}
         * @apioption chart.renderTo
         */
        /**
         * The background color of the marker square when selecting (zooming
         * in on) an area of the chart.
         *
         * @see In styled mode, the selection marker fill is set with the
         *      `.highcharts-selection-marker` class.
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @default   rgba(51,92,173,0.25)
         * @since     2.1.7
         * @apioption chart.selectionMarkerFill
         */
        /**
         * Whether to apply a drop shadow to the global series group. This causes
         * all the series to have the same shadow. Contrary to the `series.shadow`
         * option, this prevents items from casting shadows on each other, like for
         * others series in a stack. The shadow can be an object configuration
         * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
         *
         * @sample highcharts/chart/seriesgroupshadow/ Shadow
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @apioption chart.shadow
         */
        /**
         * Whether to apply a drop shadow to the outer chart area. Requires
         * that backgroundColor be set. The shadow can be an object
         * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
         * `width`.
         *
         * @sample {highcharts} highcharts/chart/shadow/
         *         Shadow
         * @sample {highstock} stock/chart/shadow/
         *         Shadow
         * @sample {highmaps} maps/chart/border/
         *         Chart border and shadow
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @apioption chart.shadow
         */
        /**
         * Whether to show the axes initially. This only applies to empty charts
         * where series are added dynamically, as axes are automatically added
         * to cartesian series.
         *
         * @sample {highcharts} highcharts/chart/showaxes-false/
         *         False by default
         * @sample {highcharts} highcharts/chart/showaxes-true/
         *         True
         *
         * @type      {boolean}
         * @since     1.2.5
         * @product   highcharts gantt
         * @apioption chart.showAxes
         */
        /**
         * The space between the bottom edge of the chart and the content (plot
         * area, axis title and labels, title, subtitle or legend in top
         * position).
         *
         * @sample {highcharts} highcharts/chart/spacingbottom/
         *         Spacing bottom set to 100
         * @sample {highstock} stock/chart/spacingbottom/
         *         Spacing bottom set to 100
         * @sample {highmaps} maps/chart/spacing/
         *         Spacing 100 all around
         *
         * @type      {number}
         * @default   15
         * @since     2.1
         * @apioption chart.spacingBottom
         */
        /**
         * The space between the left edge of the chart and the content (plot
         * area, axis title and labels, title, subtitle or legend in top
         * position).
         *
         * @sample {highcharts} highcharts/chart/spacingleft/
         *         Spacing left set to 100
         * @sample {highstock} stock/chart/spacingleft/
         *         Spacing left set to 100
         * @sample {highmaps} maps/chart/spacing/
         *         Spacing 100 all around
         *
         * @type      {number}
         * @default   10
         * @since     2.1
         * @apioption chart.spacingLeft
         */
        /**
         * The space between the right edge of the chart and the content (plot
         * area, axis title and labels, title, subtitle or legend in top
         * position).
         *
         * @sample {highcharts} highcharts/chart/spacingright-100/
         *         Spacing set to 100
         * @sample {highcharts} highcharts/chart/spacingright-legend/
         *         Legend in right position with default spacing
         * @sample {highstock} stock/chart/spacingright/
         *         Spacing set to 100
         * @sample {highmaps} maps/chart/spacing/
         *         Spacing 100 all around
         *
         * @type      {number}
         * @default   10
         * @since     2.1
         * @apioption chart.spacingRight
         */
        /**
         * The space between the top edge of the chart and the content (plot
         * area, axis title and labels, title, subtitle or legend in top
         * position).
         *
         * @sample {highcharts} highcharts/chart/spacingtop-100/
         *         A top spacing of 100
         * @sample {highcharts} highcharts/chart/spacingtop-10/
         *         Floating chart title makes the plot area align to the default
         *         spacingTop of 10.
         * @sample {highstock} stock/chart/spacingtop/
         *         A top spacing of 100
         * @sample {highmaps} maps/chart/spacing/
         *         Spacing 100 all around
         *
         * @type      {number}
         * @default   10
         * @since     2.1
         * @apioption chart.spacingTop
         */
        /**
         * Additional CSS styles to apply inline to the container `div` and the root
         * SVG.
         *
         * According to the CSS syntax documentation, it is recommended to quote
         * font family names that contain white space, digits, or punctuation
         * characters other than hyphens. In such cases, wrap the fontFamily
         * name as follows: `fontFamily: '"Font name"'`.
         *
         * Since v11, the root font size is 1rem by default, and all child element
         * are given a relative `em` font size by default. This allows implementers
         * to control all the chart's font sizes by only setting the root level.
         *
         * @see    In styled mode, general chart styles can be set with the
         *         `.highcharts-root` class.
         * @sample {highcharts} highcharts/chart/style-serif-font/
         *         Using a serif type font
         * @sample {highcharts} highcharts/chart/style-special-font/
         *         Using a font with special character in name
         * @sample {highcharts} highcharts/members/relative-font-size/
         *         Relative font sizes
         * @sample {highcharts} highcharts/css/em/
         *         Styled mode with relative font sizes
         * @sample {highstock} stock/chart/style/
         *         Using a serif type font
         * @sample {highmaps} maps/chart/style-serif-font/
         *         Using a serif type font
         *
         * @type      {Highcharts.CSSObject}
         * @default   {"fontFamily": Helvetica, Arial, sans-serif","fontSize":"1rem"}
         * @apioption chart.style
         */
        /**
         * The default series type for the chart. Can be any of the chart types
         * listed under [plotOptions](#plotOptions) and [series](#series) or can
         * be a series provided by an additional module.
         *
         * In TypeScript this option has no effect in sense of typing and
         * instead the `type` option must always be set in the series.
         *
         * @sample {highcharts} highcharts/chart/type-bar/
         *         Bar
         * @sample {highstock} stock/chart/type/
         *         Areaspline
         * @sample {highmaps} maps/chart/type-mapline/
         *         Mapline
         *
         * @type       {string}
         * @default    {highcharts} line
         * @default    {highstock} line
         * @default    {highmaps} map
         * @since      2.1.0
         * @apioption  chart.type
         */
        type: 'line',
        /**
         * Decides in what dimensions the user can zoom by dragging the mouse.
         * Can be one of `x`, `y` or `xy`.
         *
         * @see [panKey](#chart.panKey)
         *
         * @sample {highcharts} highcharts/chart/zoomtype-none/
         *         None by default
         * @sample {highcharts} highcharts/chart/zoomtype-x/
         *         X
         * @sample {highcharts} highcharts/chart/zoomtype-y/
         *         Y
         * @sample {highcharts} highcharts/chart/zoomtype-xy/
         *         Xy
         * @sample {highcharts} highcharts/chart/zoomtype-polar/
         *         Zoom on polar chart
         * @sample {highstock} stock/demo/basic-line/
         *         None by default
         * @sample {highstock} stock/chart/zoomtype-x/
         *         X
         * @sample {highstock} stock/chart/zoomtype-y/
         *         Y
         * @sample {highstock} stock/chart/zoomtype-xy/
         *         Xy
         * @sample {highmaps} maps/chart/zoomtype-xy/
         *         Map with selection zoom
         *
         * @type       {string}
         * @validvalue ["x", "y", "xy"]
         * @deprecated
         * @apioption  chart.zoomType
         */
        /**
         * Enables zooming by a single touch, in combination with
         * [chart.zoomType](#chart.zoomType). When enabled, two-finger pinch
         * will still work as set up by [chart.pinchType](#chart.pinchType).
         * However, `zoomBySingleTouch` will interfere with touch-dragging the
         * chart to read the tooltip. And especially when vertical zooming is
         * enabled, it will make it hard to scroll vertically on the page.
         * @since      9.0.0
         * @sample     highcharts/chart/zoombysingletouch
         *             Zoom by single touch enabled, with buttons to toggle
         * @product    highcharts highstock gantt
         * @deprecated
         */
        /**
         * Chart zooming options.
         * @since 10.2.1
         */
        zooming: {
            /**
             * Equivalent to [type](#chart.zooming.type), but for multitouch
             * gestures only. By default, the `pinchType` is the same as the
             * `type` setting. However, pinching can be enabled separately in
             * some cases, for example in stock charts where a mouse drag pans the
             * chart, while pinching is enabled. When [tooltip.followTouchMove](
             * #tooltip.followTouchMove) is true, pinchType only applies to
             * two-finger touches.
             *
             * @type       {string}
             * @default    {highcharts} undefined
             * @default    {highstock} x
             * @product    highcharts highstock gantt
             * @validvalue ["x", "y", "xy"]
             * @apioption  chart.zooming.pinchType
             */
            /**
             * Decides in what dimensions the user can zoom by dragging the mouse.
             * Can be one of `x`, `y` or `xy`.
             *
             * @declare    Highcharts.OptionsChartZoomingTypeValue
             * @type       {string}
             * @default    {highcharts} undefined
             * @product    highcharts highstock gantt
             * @validvalue ["x", "y", "xy"]
             * @apioption  chart.zooming.type
             */
            /**
             * Set a key to hold when dragging to zoom the chart. This is useful to
             * avoid zooming while moving points. Should be set different than
             * [chart.panKey](#chart.panKey).
             *
             * @type       {string}
             * @default    {highcharts} undefined
             * @validvalue ["alt", "ctrl", "meta", "shift"]
             * @requires   modules/draggable-points
             * @apioption  chart.zooming.key
             */
            /**
             * Enables zooming by a single touch, in combination with
             * [chart.zooming.type](#chart.zooming.type). When enabled, two-finger
             * pinch will still work as set up by [chart.zooming.pinchType]
             * (#chart.zooming.pinchType). However, `singleTouch` will interfere
             * with touch-dragging the chart to read the tooltip. And especially
             * when vertical zooming is enabled, it will make it hard to scroll
             * vertically on the page.
             *
             * @sample  highcharts/chart/zoombysingletouch
             *          Zoom by single touch enabled, with buttons to toggle
             *
             * @product highcharts highstock gantt
             */
            singleTouch: false,
            /**
             * The button that appears after a selection zoom, allowing the user
             * to reset zoom.
             */
            resetButton: {
                /**
                 * What frame the button placement should be related to. Can be
                 * either `plotBox` or `spacingBox`.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
                 *         Relative to the chart
                 * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
                 *         Relative to the chart
                 *
                 * @type      {Highcharts.ButtonRelativeToValue}
                 * @default   plot
                 * @apioption chart.zooming.resetButton.relativeTo
                 */
                /**
                 * A collection of attributes for the button. The object takes SVG
                 * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
                 * border radius. The theme also supports `style`, a collection of
                 * CSS properties for the text. Equivalent attributes for the hover
                 * state are given in `theme.states.hover`.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
                 *         Theming the button
                 * @sample {highstock} highcharts/chart/resetzoombutton-theme/
                 *         Theming the button
                 *
                 * @type  {Highcharts.SVGAttributes}
                 * @since 10.2.1
                 */
                theme: {
                    /** @internal */
                    zIndex: 6
                },
                /**
                 * The position of the button.
                 *
                 * Note: Adjusting position values might cause overlap with chart
                 * elements. Ensure coordinates do not obstruct other components or
                 * data visibility.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 * @sample {highstock} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 * @sample {highmaps} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 *
                 * @type  {Highcharts.AlignObject}
                 * @since 10.2.1
                 */
                position: {
                    /**
                     * The horizontal alignment of the button.
                     */
                    align: 'right',
                    /**
                     * The horizontal offset of the button.
                     */
                    x: -10,
                    /**
                     * The vertical alignment of the button.
                     *
                     * @type       {Highcharts.VerticalAlignValue}
                     * @default    top
                     * @apioption  chart.zooming.resetButton.position.verticalAlign
                     */
                    /**
                     * The vertical offset of the button.
                     */
                    y: 10
                }
            }
        },
        /**
         * An explicit width for the chart. By default (when `null`) the width
         * is calculated from the offset width of the containing element.
         *
         * @sample {highcharts} highcharts/chart/width/
         *         800px wide
         * @sample {highstock} stock/chart/width/
         *         800px wide
         * @sample {highmaps} maps/chart/size/
         *         Chart with explicit size
         *
         * @type {null|number|string}
         */
        width: null,
        /**
         * An explicit height for the chart. If a _number_, the height is
         * given in pixels. If given a _percentage string_ (for example
         * `'56%'`), the height is given as the percentage of the actual chart
         * width. This allows for preserving the aspect ratio across responsive
         * sizes.
         *
         * By default (when `null`) the height is calculated from the offset
         * height of the containing element, or 400 pixels if the containing
         * element's height is 0.
         *
         * @sample {highcharts} highcharts/chart/height/
         *         Forced 200px height
         * @sample {highstock} stock/chart/height/
         *         300px height
         * @sample {highmaps} maps/chart/size/
         *         Chart with explicit size
         * @sample highcharts/chart/height-percent/
         *         Highcharts with percentage height
         * @sample highcharts/chart/height-inherited/
         *         Chart with inherited height
         *
         * @type {null|number|string}
         */
        height: null,
        /**
         * The color of the outer chart border.
         *
         * @see In styled mode, the stroke is set with the
         *      `.highcharts-background` class.
         *
         * @sample {highcharts} highcharts/chart/bordercolor/
         *         Brown border
         * @sample {highstock} stock/chart/border/
         *         Brown border
         * @sample {highmaps} maps/chart/border/
         *         Border options
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        borderColor: "#334eff" /* Palette.highlightColor80 */,
        /**
         * The pixel width of the outer chart border.
         *
         * @see In styled mode, the stroke is set with the
         *      `.highcharts-background` class.
         *
         * @sample {highcharts} highcharts/chart/borderwidth/
         *         5px border
         * @sample {highstock} stock/chart/border/
         *         2px border
         * @sample {highmaps} maps/chart/border/
         *         Border options
         *
         * @type      {number}
         * @default   0
         * @apioption chart.borderWidth
         */
        /**
         * The background color or gradient for the outer chart area.
         *
         * @see In styled mode, the background is set with the
         *      `.highcharts-background` class.
         *
         * @sample {highcharts} highcharts/chart/backgroundcolor-color/
         *         Color
         * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/
         *         Gradient
         * @sample {highstock} stock/chart/backgroundcolor-color/
         *         Color
         * @sample {highstock} stock/chart/backgroundcolor-gradient/
         *         Gradient
         * @sample {highmaps} maps/chart/backgroundcolor-color/
         *         Color
         * @sample {highmaps} maps/chart/backgroundcolor-gradient/
         *         Gradient
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        backgroundColor: "#ffffff" /* Palette.backgroundColor */,
        /**
         * The background color or gradient for the plot area.
         *
         * @see In styled mode, the plot background is set with the
         *      `.highcharts-plot-background` class.
         *
         * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
         *         Color
         * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
         *         Gradient
         * @sample {highstock} stock/chart/plotbackgroundcolor-color/
         *         Color
         * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
         *         Gradient
         * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
         *         Color
         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
         *         Gradient
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption chart.plotBackgroundColor
         */
        /**
         * The URL for an image to use as the plot background. To set an image
         * as the background for the entire chart, set a CSS background image
         * to the container element. Note that for the image to be applied to
         * exported charts, its URL needs to be accessible by the export server.
         *
         * @see In styled mode, a plot background image can be set with the
         *      `.highcharts-plot-background` class and a [custom pattern](
         *      https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns).
         *
         * @sample {highcharts} highcharts/chart/plotbackgroundimage/
         *         Skies
         * @sample {highstock} stock/chart/plotbackgroundimage/
         *         Skies
         *
         * @type      {string}
         * @apioption chart.plotBackgroundImage
         */
        /**
         * The color of the inner chart or plot area border.
         *
         * @see In styled mode, a plot border stroke can be set with the
         *      `.highcharts-plot-border` class.
         *
         * @sample {highcharts} highcharts/chart/plotbordercolor/
         *         Blue border
         * @sample {highstock} stock/chart/plotborder/
         *         Blue border
         * @sample {highmaps} maps/chart/plotborder/
         *         Plot border options
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        plotBorderColor: "#cccccc" /* Palette.neutralColor20 */
    };

    /*
     * Series palettes for Highcharts. Series colors are defined in highcharts.css.
     * **Do not edit this file!** This file is generated using the 'gulp palette' task.
     */
    const SeriesPalettes = {
        /**
         * Colors for data series and points
         */
        colors: [
            '#2caffe',
            '#544fc5',
            '#00e272',
            '#fe6a35',
            '#6b8abc',
            '#d568fb',
            '#2ee0ca',
            '#fa4b42',
            '#feb56a',
            '#91e8e1'
        ],
    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { win: win$6 } = H;
    const { defined: defined$9, error: error$4, extend: extend$d, isNumber: isNumber$a, isObject: isObject$5, merge: merge$c, objectEach: objectEach$9, pad, pick: pick$d, splat: splat$4, timeUnits } = Utilities;
    /* *
     *
     *  Constants
     *
     * */
    const hasNewSafariBug = H.isSafari &&
        win$6.Intl &&
        win$6.Intl.DateTimeFormat.prototype.formatRange;
    // To do: Remove this when we no longer need support for Safari < v14.1
    const hasOldSafariBug = H.isSafari &&
        win$6.Intl &&
        !win$6.Intl.DateTimeFormat.prototype.formatRange;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * The Time class. Time settings are applied in general for each page using
     * `Highcharts.setOptions`, or individually for each Chart item through the
     * [time](https://api.highcharts.com/highcharts/time) options set.
     *
     * The Time object is available from {@link Highcharts.Chart#time},
     * which refers to  `Highcharts.time` if no individual time settings are
     * applied.
     *
     * @example
     * // Apply time settings globally
     * Highcharts.setOptions({
     *     time: {
     *         timezone: 'Europe/London'
     *     }
     * });
     *
     * // Apply time settings by instance
     * let chart = Highcharts.chart('container', {
     *     time: {
     *         timezone: 'America/New_York'
     *     },
     *     series: [{
     *         data: [1, 4, 3, 5]
     *     }]
     * });
     *
     * // Use the Time object
     * console.log(
     *        'Current time in New York',
     *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
     * );
     *
     * @since 6.0.5
     *
     * @class
     * @name Highcharts.Time
     *
     * @param {Highcharts.TimeOptions} [options]
     * Time options as defined in [chart.options.time](/highcharts/time).
     */
    class Time {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(options) {
            /* *
             *
             *  Properties
             *
             * */
            this.options = {};
            this.useUTC = false;
            this.variableTimezone = false;
            this.Date = win$6.Date;
            /**
             * Get the time zone offset based on the current timezone information as
             * set in the global options.
             *
             * @function Highcharts.Time#getTimezoneOffset
             *
             * @param {number} timestamp
             *        The JavaScript timestamp to inspect.
             *
             * @return {number}
             *         The timezone offset in minutes compared to UTC.
             */
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.update(options);
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Time units used in `Time.get` and `Time.set`
         *
         * @typedef {"Date"|"Day"|"FullYear"|"Hours"|"Milliseconds"|"Minutes"|"Month"|"Seconds"} Highcharts.TimeUnitValue
         */
        /**
         * Get the value of a date object in given units, and subject to the Time
         * object's current timezone settings. This function corresponds directly to
         * JavaScripts `Date.getXXX / Date.getUTCXXX`, so instead of calling
         * `date.getHours()` or `date.getUTCHours()` we will call
         * `time.get('Hours')`.
         *
         * @function Highcharts.Time#get
         *
         * @param {Highcharts.TimeUnitValue} unit
         * @param {Date} date
         *
         * @return {number}
         *        The given time unit
         */
        get(unit, date) {
            if (this.variableTimezone || this.timezoneOffset) {
                const realMs = date.getTime();
                const ms = realMs - this.getTimezoneOffset(date);
                date.setTime(ms); // Temporary adjust to timezone
                const ret = date['getUTC' + unit]();
                date.setTime(realMs); // Reset
                return ret;
            }
            // UTC time with no timezone handling
            if (this.useUTC) {
                return date['getUTC' + unit]();
            }
            // Else, local time
            return date['get' + unit]();
        }
        /**
         * Set the value of a date object in given units, and subject to the Time
         * object's current timezone settings. This function corresponds directly to
         * JavaScripts `Date.setXXX / Date.setUTCXXX`, so instead of calling
         * `date.setHours(0)` or `date.setUTCHours(0)` we will call
         * `time.set('Hours', 0)`.
         *
         * @function Highcharts.Time#set
         *
         * @param {Highcharts.TimeUnitValue} unit
         * @param {Date} date
         * @param {number} value
         *
         * @return {number}
         *        The epoch milliseconds of the updated date
         */
        set(unit, date, value) {
            // UTC time with timezone handling
            if (this.variableTimezone || this.timezoneOffset) {
                // For lower order time units, just set it directly using UTC
                // time
                if (unit === 'Milliseconds' ||
                    unit === 'Seconds' ||
                    (unit === 'Minutes' &&
                        this.getTimezoneOffset(date) % 3600000 === 0) // #13961
                ) {
                    return date['setUTC' + unit](value);
                }
                // Higher order time units need to take the time zone into
                // account
                // Adjust by timezone
                const offset = this.getTimezoneOffset(date);
                let ms = date.getTime() - offset;
                date.setTime(ms);
                date['setUTC' + unit](value);
                const newOffset = this.getTimezoneOffset(date);
                ms = date.getTime() + newOffset;
                return date.setTime(ms);
            }
            // UTC time with no timezone handling
            if (this.useUTC ||
                // Leap calculation in UTC only
                (hasNewSafariBug && unit === 'FullYear')) {
                return date['setUTC' + unit](value);
            }
            // Else, local time
            return date['set' + unit](value);
        }
        /**
         * Update the Time object with current options. It is called internally on
         * initializing Highcharts, after running `Highcharts.setOptions` and on
         * `Chart.update`.
         *
         * @private
         * @function Highcharts.Time#update
         *
         * @param {Highcharts.TimeOptions} [options]
         *
         */
        update(options = {}) {
            const useUTC = pick$d(options.useUTC, true);
            this.options = options = merge$c(true, this.options, options);
            // Allow using a different Date class
            this.Date = options.Date || win$6.Date || Date;
            this.useUTC = useUTC;
            this.timezoneOffset = (useUTC && options.timezoneOffset) || void 0;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            /*
             * The time object has options allowing for variable time zones, meaning
             * the axis ticks or series data needs to consider this.
             */
            this.variableTimezone = useUTC && !!(options.getTimezoneOffset ||
                options.timezone);
        }
        /**
         * Make a time and returns milliseconds. Interprets the inputs as UTC time,
         * local time or a specific timezone time depending on the current time
         * settings.
         *
         * @function Highcharts.Time#makeTime
         *
         * @param {number} year
         *        The year
         *
         * @param {number} month
         *        The month. Zero-based, so January is 0.
         *
         * @param {number} [date=1]
         *        The day of the month
         *
         * @param {number} [hours=0]
         *        The hour of the day, 0-23.
         *
         * @param {number} [minutes=0]
         *        The minutes
         *
         * @param {number} [seconds=0]
         *        The seconds
         *
         * @return {number}
         *         The time in milliseconds since January 1st 1970.
         */
        makeTime(year, month, date, hours, minutes, seconds) {
            let d, offset, newOffset;
            if (this.useUTC) {
                d = this.Date.UTC.apply(0, arguments);
                offset = this.getTimezoneOffset(d);
                d += offset;
                newOffset = this.getTimezoneOffset(d);
                if (offset !== newOffset) {
                    d += newOffset - offset;
                    // A special case for transitioning from summer time to winter time.
                    // When the clock is set back, the same time is repeated twice, i.e.
                    // 02:30 am is repeated since the clock is set back from 3 am to
                    // 2 am. We need to make the same time as local Date does.
                }
                else if (offset - 36e5 === this.getTimezoneOffset(d - 36e5) &&
                    !hasOldSafariBug) {
                    d -= 36e5;
                }
            }
            else {
                d = new this.Date(year, month, pick$d(date, 1), pick$d(hours, 0), pick$d(minutes, 0), pick$d(seconds, 0)).getTime();
            }
            return d;
        }
        /**
         * Sets the getTimezoneOffset function. If the `timezone` option is set, a
         * default getTimezoneOffset function with that timezone is returned. If
         * a `getTimezoneOffset` option is defined, it is returned. If neither are
         * specified, the function using the `timezoneOffset` option or 0 offset is
         * returned.
         *
         * @private
         * @function Highcharts.Time#timezoneOffsetFunction
         *
         * @return {Function}
         *         A getTimezoneOffset function
         */
        timezoneOffsetFunction() {
            const time = this, options = this.options, getTimezoneOffset = options.getTimezoneOffset;
            if (!this.useUTC) {
                return (timestamp) => new Date(timestamp.toString()).getTimezoneOffset() * 60000;
            }
            if (options.timezone) {
                return (timestamp) => {
                    try {
                        // Cache the DateTimeFormat instances for performance
                        // (#20720)
                        const cacheKey = `shortOffset,${options.timezone || ''}`, dateTimeFormat = Time.formatCache[cacheKey] = (Time.formatCache[cacheKey] ||
                            // eslint-disable-next-line new-cap
                            Intl.DateTimeFormat('en', {
                                timeZone: options.timezone,
                                timeZoneName: 'shortOffset'
                            }));
                        // eslint-disable-next-line @typescript-eslint/no-unused-vars
                        const [date, gmt, hours, colon, minutes = 0] = dateTimeFormat
                            .format(timestamp)
                            .split(/(GMT|:)/)
                            .map(Number), offset = -(hours + minutes / 60) * 60 * 60000;
                        // Possible future NaNs stop here
                        if (isNumber$a(offset)) {
                            return offset;
                        }
                    }
                    catch (e) {
                        error$4(34);
                    }
                    return 0;
                };
            }
            // If not timezone is set, look for the getTimezoneOffset callback
            if (this.useUTC && getTimezoneOffset) {
                return (timestamp) => getTimezoneOffset(timestamp.valueOf()) * 60000;
            }
            // Last, use the `timezoneOffset` option if set
            return () => (time.timezoneOffset || 0) * 60000;
        }
        /**
         * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970)
         * into a human readable date string. The available format keys are listed
         * below. Additional formats can be given in the
         * {@link Highcharts.dateFormats} hook.
         *
         * Supported format keys:
         * - `%a`: Short weekday, like 'Mon'
         * - `%A`: Long weekday, like 'Monday'
         * - `%d`: Two digit day of the month, 01 to 31
         * - `%e`: Day of the month, 1 through 31
         * - `%w`: Day of the week, 0 through 6
         * - `%b`: Short month, like 'Jan'
         * - `%B`: Long month, like 'January'
         * - `%m`: Two digit month number, 01 through 12
         * - `%y`: Two digits year, like 09 for 2009
         * - `%Y`: Four digits year, like 2009
         * - `%H`: Two digits hours in 24h format, 00 through 23
         * - `%k`: Hours in 24h format, 0 through 23
         * - `%I`: Two digits hours in 12h format, 00 through 11
         * - `%l`: Hours in 12h format, 1 through 12
         * - `%M`: Two digits minutes, 00 through 59
         * - `%p`: Upper case AM or PM
         * - `%P`: Lower case AM or PM
         * - `%S`: Two digits seconds, 00 through 59
         * - `%L`: Milliseconds (naming from Ruby)
         *
         * @example
         * const time = new Highcharts.Time();
         * const s = time.dateFormat('%Y-%m-%d %H:%M:%S', Date.UTC(2020, 0, 1));
         * console.log(s); // => 2020-01-01 00:00:00
         *
         * @function Highcharts.Time#dateFormat
         *
         * @param {string} format
         *        The desired format where various time representations are
         *        prefixed with %.
         *
         * @param {number} [timestamp]
         *        The JavaScript timestamp.
         *
         * @param {boolean} [capitalize=false]
         *        Upper case first letter in the return.
         *
         * @return {string}
         *         The formatted date.
         */
        dateFormat(format, timestamp, capitalize) {
            if (!defined$9(timestamp) || isNaN(timestamp)) {
                return (H.defaultOptions.lang &&
                    H.defaultOptions.lang.invalidDate ||
                    '');
            }
            format = pick$d(format, '%Y-%m-%d %H:%M:%S');
            const time = this, date = new this.Date(timestamp), 
            // Get the basic time values
            hours = this.get('Hours', date), day = this.get('Day', date), dayOfMonth = this.get('Date', date), month = this.get('Month', date), fullYear = this.get('FullYear', date), lang = H.defaultOptions.lang, langWeekdays = (lang && lang.weekdays), shortWeekdays = (lang && lang.shortWeekdays), 
            // List all format keys. Custom formats can be added from the
            // outside.
            replacements = extend$d({
                // Day
                // Short weekday, like 'Mon'
                a: shortWeekdays ?
                    shortWeekdays[day] :
                    langWeekdays[day].substr(0, 3),
                // Long weekday, like 'Monday'
                A: langWeekdays[day],
                // Two digit day of the month, 01 to 31
                d: pad(dayOfMonth),
                // Day of the month, 1 through 31
                e: pad(dayOfMonth, 2, ' '),
                // Day of the week, 0 through 6
                w: day,
                // Week (none implemented)
                // 'W': weekNumber(),
                // Month
                // Short month, like 'Jan'
                b: lang.shortMonths[month],
                // Long month, like 'January'
                B: lang.months[month],
                // Two digit month number, 01 through 12
                m: pad(month + 1),
                // Month number, 1 through 12 (#8150)
                o: month + 1,
                // Year
                // Two digits year, like 09 for 2009
                y: fullYear.toString().substr(2, 2),
                // Four digits year, like 2009
                Y: fullYear,
                // Time
                // Two digits hours in 24h format, 00 through 23
                H: pad(hours),
                // Hours in 24h format, 0 through 23
                k: hours,
                // Two digits hours in 12h format, 00 through 11
                I: pad((hours % 12) || 12),
                // Hours in 12h format, 1 through 12
                l: (hours % 12) || 12,
                // Two digits minutes, 00 through 59
                M: pad(this.get('Minutes', date)),
                // Upper case AM or PM
                p: hours < 12 ? 'AM' : 'PM',
                // Lower case AM or PM
                P: hours < 12 ? 'am' : 'pm',
                // Two digits seconds, 00 through 59
                S: pad(this.get('Seconds', date)),
                // Milliseconds (naming from Ruby)
                L: pad(Math.floor(timestamp % 1000), 3)
            }, H.dateFormats);
            // Do the replaces
            objectEach$9(replacements, function (val, key) {
                // Regex would do it in one line, but this is faster
                while (format.indexOf('%' + key) !== -1) {
                    format = format.replace('%' + key, typeof val === 'function' ? val.call(time, timestamp) : val);
                }
            });
            // Optionally capitalize the string and return
            return capitalize ?
                (format.substr(0, 1).toUpperCase() +
                    format.substr(1)) :
                format;
        }
        /**
         * Resolve legacy formats of dateTimeLabelFormats (strings and arrays) into
         * an object.
         * @private
         * @param {string|Array<T>|Highcharts.Dictionary<T>} f
         * General format description
         * @return {Highcharts.Dictionary<T>}
         * The object definition
         */
        resolveDTLFormat(f) {
            if (!isObject$5(f, true)) { // Check for string or array
                f = splat$4(f);
                return {
                    main: f[0],
                    from: f[1],
                    to: f[2]
                };
            }
            return f;
        }
        /**
         * Return an array with time positions distributed on round time values
         * right and right after min and max. Used in datetime axes as well as for
         * grouping data on a datetime axis.
         *
         * @function Highcharts.Time#getTimeTicks
         *
         * @param {Highcharts.TimeNormalizedObject} normalizedInterval
         *        The interval in axis values (ms) and the count
         *
         * @param {number} [min]
         *        The minimum in axis values
         *
         * @param {number} [max]
         *        The maximum in axis values
         *
         * @param {number} [startOfWeek=1]
         *
         * @return {Highcharts.AxisTickPositionsArray}
         * Time positions
         */
        getTimeTicks(normalizedInterval, min, max, startOfWeek) {
            const time = this, Date = time.Date, tickPositions = [], higherRanks = {}, 
            // When crossing DST, use the max. Resolves #6278.
            minDate = new Date(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count || 1;
            let i, minYear, // Used in months and years as a basis for Date.UTC()
            variableDayLength, minDay;
            startOfWeek = pick$d(startOfWeek, 1);
            if (defined$9(min)) { // #1300
                time.set('Milliseconds', minDate, interval >= timeUnits.second ?
                    0 : // #3935
                    count * Math.floor(time.get('Milliseconds', minDate) / count)); // #3652, #3654
                if (interval >= timeUnits.second) { // Second
                    time.set('Seconds', minDate, interval >= timeUnits.minute ?
                        0 : // #3935
                        count * Math.floor(time.get('Seconds', minDate) / count));
                }
                if (interval >= timeUnits.minute) { // Minute
                    time.set('Minutes', minDate, interval >= timeUnits.hour ?
                        0 :
                        count * Math.floor(time.get('Minutes', minDate) / count));
                }
                if (interval >= timeUnits.hour) { // Hour
                    time.set('Hours', minDate, interval >= timeUnits.day ?
                        0 :
                        count * Math.floor(time.get('Hours', minDate) / count));
                }
                if (interval >= timeUnits.day) { // Day
                    time.set('Date', minDate, interval >= timeUnits.month ?
                        1 :
                        Math.max(1, count * Math.floor(time.get('Date', minDate) / count)));
                }
                if (interval >= timeUnits.month) { // Month
                    time.set('Month', minDate, interval >= timeUnits.year ? 0 :
                        count * Math.floor(time.get('Month', minDate) / count));
                    minYear = time.get('FullYear', minDate);
                }
                if (interval >= timeUnits.year) { // Year
                    minYear -= minYear % count;
                    time.set('FullYear', minDate, minYear);
                }
                // Week is a special case that runs outside the hierarchy
                if (interval === timeUnits.week) {
                    // Get start of current week, independent of count
                    minDay = time.get('Day', minDate);
                    time.set('Date', minDate, (time.get('Date', minDate) -
                        minDay + startOfWeek +
                        // We don't want to skip days that are before
                        // startOfWeek (#7051)
                        (minDay < startOfWeek ? -7 : 0)));
                }
                // Get basics for variable time spans
                minYear = time.get('FullYear', minDate);
                const minMonth = time.get('Month', minDate), minDateDate = time.get('Date', minDate), minHours = time.get('Hours', minDate);
                // Redefine min to the floored/rounded minimum time (#7432)
                min = minDate.getTime();
                // Handle local timezone offset
                if ((time.variableTimezone || !time.useUTC) && defined$9(max)) {
                    // Detect whether we need to take the DST crossover into
                    // consideration. If we're crossing over DST, the day length may
                    // be 23h or 25h and we need to compute the exact clock time for
                    // each tick instead of just adding hours. This comes at a cost,
                    // so first we find out if it is needed (#4951).
                    variableDayLength = (
                    // Long range, assume we're crossing over.
                    max - min > 4 * timeUnits.month ||
                        // Short range, check if min and max are in different time
                        // zones.
                        time.getTimezoneOffset(min) !==
                            time.getTimezoneOffset(max));
                }
                // Iterate and add tick positions at appropriate values
                let t = minDate.getTime();
                i = 1;
                while (t < max) {
                    tickPositions.push(t);
                    // If the interval is years, use Date.UTC to increase years
                    if (interval === timeUnits.year) {
                        t = time.makeTime(minYear + i * count, 0);
                        // If the interval is months, use Date.UTC to increase months
                    }
                    else if (interval === timeUnits.month) {
                        t = time.makeTime(minYear, minMonth + i * count);
                        // If we're using global time, the interval is not fixed as it
                        // jumps one hour at the DST crossover
                    }
                    else if (variableDayLength &&
                        (interval === timeUnits.day || interval === timeUnits.week)) {
                        t = time.makeTime(minYear, minMonth, minDateDate +
                            i * count * (interval === timeUnits.day ? 1 : 7));
                    }
                    else if (variableDayLength &&
                        interval === timeUnits.hour &&
                        count > 1) {
                        // Make sure higher ranks are preserved across DST (#6797,
                        // #7621)
                        t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);
                        // Else, the interval is fixed and we use simple addition
                    }
                    else {
                        t += interval * count;
                    }
                    i++;
                }
                // Push the last time
                tickPositions.push(t);
                // Handle higher ranks. Mark new days if the time is on midnight
                // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold
                // to prevent looping over dense data grouping (#6156).
                if (interval <= timeUnits.hour && tickPositions.length < 10000) {
                    tickPositions.forEach(function (t) {
                        if (
                        // Speed optimization, no need to run dateFormat unless
                        // we're on a full or half hour
                        t % 1800000 === 0 &&
                            // Check for local or global midnight
                            time.dateFormat('%H%M%S%L', t) === '000000000') {
                            higherRanks[t] = 'day';
                        }
                    });
                }
            }
            // Record information on the chosen unit - for dynamic label formatter
            tickPositions.info = extend$d(normalizedInterval, {
                higherRanks,
                totalRange: interval * count
            });
            return tickPositions;
        }
        /**
         * Get the optimal date format for a point, based on a range.
         *
         * @private
         * @function Highcharts.Time#getDateFormat
         *
         * @param {number} range
         *        The time range
         *
         * @param {number} timestamp
         *        The timestamp of the date
         *
         * @param {number} startOfWeek
         *        An integer representing the first day of the week, where 0 is
         *        Sunday.
         *
         * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats
         *        A map of time units to formats.
         *
         * @return {string}
         *         The optimal date format for a point.
         */
        getDateFormat(range, timestamp, startOfWeek, dateTimeLabelFormats) {
            const dateStr = this.dateFormat('%m-%d %H:%M:%S.%L', timestamp), blank = '01-01 00:00:00.000', strpos = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
            };
            let n = 'millisecond', 
            // For sub-millisecond data, #4223
            lastN = n;
            for (n in timeUnits) { // eslint-disable-line guard-for-in
                // If the range is exactly one week and we're looking at a
                // Sunday/Monday, go for the week format
                if (range === timeUnits.week &&
                    +this.dateFormat('%w', timestamp) === startOfWeek &&
                    dateStr.substr(6) === blank.substr(6)) {
                    n = 'week';
                    break;
                }
                // The first format that is too great for the range
                if (timeUnits[n] > range) {
                    n = lastN;
                    break;
                }
                // If the point is placed every day at 23:59, we need to show
                // the minutes as well. #2637.
                if (strpos[n] &&
                    dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
                    break;
                }
                // Weeks are outside the hierarchy, only apply them on
                // Mondays/Sundays like in the first condition
                if (n !== 'week') {
                    lastN = n;
                }
            }
            return this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
        }
    }
    Time.formatCache = {};

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { isTouchDevice } = H;
    const { fireEvent: fireEvent$8, merge: merge$b } = Utilities;
    /* *
     *
     *  API Options
     *
     * */
    /**
     * Global default settings.
     *
     * @name Highcharts.defaultOptions
     * @type {Highcharts.Options}
     */ /**
    * @optionparent
    * @private
    */
    const defaultOptions$7 = {
        /**
         * An array containing the default colors for the chart's series. When
         * all colors are used, new colors are pulled from the start again.
         *
         * Default colors can also be set on a series or series.type basis,
         * see [column.colors](#plotOptions.column.colors),
         * [pie.colors](#plotOptions.pie.colors).
         *
         * In styled mode, the colors option doesn't exist. Instead, colors
         * are defined in CSS and applied either through series or point class
         * names, or through the [chart.colorCount](#chart.colorCount) option.
         *
         * @sample {highcharts} highcharts/chart/colors/
         *         Assign a global color theme
         * @sample highcharts/members/theme-v10/
         *         Latest release styled like version 10
         *
         * @type    {Array<(Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject)>}
         * @default [
         *     "#2caffe",
         *     "#544fc5",
         *     "#00e272",
         *     "#fe6a35",
         *     "#6b8abc",
         *     "#d568fb",
         *     "#2ee0ca",
         *     "#fa4b42",
         *     "#feb56a",
         *     "#91e8e1"
         * ]
         */
        colors: SeriesPalettes.colors,
        /**
         * Styled mode only. Configuration object for adding SVG definitions for
         * reusable elements. See [gradients, shadows and
         * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
         * for more information and code examples.
         *
         * @type      {*}
         * @since     5.0.0
         * @apioption defs
         */
        /**
         * @ignore-option
         */
        symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
        /**
         * The language object is global and it can't be set on each chart
         * initialization. Instead, use `Highcharts.setOptions` to set it before any
         * chart is initialized.
         *
         * ```js
         * Highcharts.setOptions({
         *     lang: {
         *         months: [
         *             'Janvier', 'Février', 'Mars', 'Avril',
         *             'Mai', 'Juin', 'Juillet', 'Août',
         *             'Septembre', 'Octobre', 'Novembre', 'Décembre'
         *         ],
         *         weekdays: [
         *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
         *             'Jeudi', 'Vendredi', 'Samedi'
         *         ]
         *     }
         * });
         * ```
         */
        lang: {
            /**
             * The loading text that appears when the chart is set into the loading
             * state following a call to `chart.showLoading`.
             */
            loading: 'Loading...',
            /**
             * An array containing the months names. Corresponds to the `%B` format
             * in `Highcharts.dateFormat()`.
             *
             * @type    {Array<string>}
             * @default ["January", "February", "March", "April", "May", "June",
             *          "July", "August", "September", "October", "November",
             *          "December"]
             */
            months: [
                'January', 'February', 'March', 'April', 'May', 'June', 'July',
                'August', 'September', 'October', 'November', 'December'
            ],
            /**
             * An array containing the months names in abbreviated form. Corresponds
             * to the `%b` format in `Highcharts.dateFormat()`.
             *
             * @type    {Array<string>}
             * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
             *          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
             */
            shortMonths: [
                'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
                'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
            ],
            /**
             * An array containing the weekday names.
             *
             * @type    {Array<string>}
             * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
             *          "Friday", "Saturday"]
             */
            weekdays: [
                'Sunday', 'Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday', 'Saturday'
            ],
            /**
             * Short week days, starting Sunday. If not specified, Highcharts uses
             * the first three letters of the `lang.weekdays` option.
             *
             * @sample highcharts/lang/shortweekdays/
             *         Finnish two-letter abbreviations
             *
             * @type      {Array<string>}
             * @since     4.2.4
             * @apioption lang.shortWeekdays
             */
            /**
             * What to show in a date field for invalid dates. Defaults to an empty
             * string.
             *
             * @type      {string}
             * @since     4.1.8
             * @product   highcharts highstock
             * @apioption lang.invalidDate
             */
            /**
             * The title appearing on hovering the zoom in button. The text itself
             * defaults to "+" and can be changed in the button options.
             *
             * @type      {string}
             * @default   Zoom in
             * @product   highmaps
             * @apioption lang.zoomIn
             */
            /**
             * The title appearing on hovering the zoom out button. The text itself
             * defaults to "-" and can be changed in the button options.
             *
             * @type      {string}
             * @default   Zoom out
             * @product   highmaps
             * @apioption lang.zoomOut
             */
            /**
             * The default decimal point used in the `Highcharts.numberFormat`
             * method unless otherwise specified in the function arguments.
             *
             * @since 1.2.2
             */
            decimalPoint: '.',
            /**
             * [Metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix) used
             * to shorten high numbers in axis labels. Replacing any of the
             * positions with `null` causes the full number to be written. Setting
             * `numericSymbols` to `undefined` disables shortening altogether.
             *
             * @sample {highcharts} highcharts/lang/numericsymbols/
             *         Replacing the symbols with text
             * @sample {highstock} highcharts/lang/numericsymbols/
             *         Replacing the symbols with text
             *
             * @type    {Array<string>}
             * @default ["k", "M", "G", "T", "P", "E"]
             * @since   2.3.0
             */
            numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'],
            /**
             * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
             * Use 10000 for Japanese, Korean and various Chinese locales, which
             * use symbols for 10^4, 10^8 and 10^12.
             *
             * @sample highcharts/lang/numericsymbolmagnitude/
             *         10000 magnitude for Japanese
             *
             * @type      {number}
             * @default   1000
             * @since     5.0.3
             * @apioption lang.numericSymbolMagnitude
             */
            /**
             * The text for the label appearing when a chart is zoomed.
             *
             * @since 1.2.4
             */
            resetZoom: 'Reset zoom',
            /**
             * The tooltip title for the label appearing when a chart is zoomed.
             *
             * @since 1.2.4
             */
            resetZoomTitle: 'Reset zoom level 1:1',
            /**
             * The default thousands separator used in the `Highcharts.numberFormat`
             * method unless otherwise specified in the function arguments. Defaults
             * to a single space character, which is recommended in
             * [ISO 31-0](https://en.wikipedia.org/wiki/ISO_31-0#Numbers) and works
             * across Anglo-American and continental European languages.
             *
             * @default \u0020
             * @since   1.2.2
             */
            thousandsSep: ' '
        },
        /**
         * Global options that don't apply to each chart. These options, like
         * the `lang` options, must be set using the `Highcharts.setOptions`
         * method.
         *
         * ```js
         * Highcharts.setOptions({
         *     global: {
         *         buttonTheme: {
         *             fill: '#d0d0d0'
         *         }
         *     }
         * });
         * ```
         */
        global: {
            /**
             * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\.
             * Use the [libURL](#exporting.libURL) option to configure exporting._
             *
             * The URL to the additional file to lazy load for Android 2.x devices.
             * These devices don't support SVG, so we download a helper file that
             * contains [canvg](https://github.com/canvg/canvg), its dependency
             * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to
             * our site, you can install canvas-tools.js on your own server and
             * change this option accordingly.
             *
             * @deprecated
             *
             * @type      {string}
             * @default   https://code.highcharts.com/{version}/modules/canvas-tools.js
             * @product   highcharts highmaps
             * @apioption global.canvasToolsURL
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.useUTC](#time.useUTC) that supports individual time settings
             * per chart.
             *
             * @deprecated
             *
             * @type      {boolean}
             * @apioption global.useUTC
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.Date](#time.Date) that supports individual time settings
             * per chart.
             *
             * @deprecated
             *
             * @type      {Function}
             * @product   highcharts highstock
             * @apioption global.Date
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports
             * individual time settings per chart.
             *
             * @deprecated
             *
             * @type      {Function}
             * @product   highcharts highstock
             * @apioption global.getTimezoneOffset
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.timezone](#time.timezone) that supports individual time
             * settings per chart.
             *
             * @deprecated
             *
             * @type      {string}
             * @product   highcharts highstock
             * @apioption global.timezone
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.timezoneOffset](#time.timezoneOffset) that supports individual
             * time settings per chart.
             *
             * @deprecated
             *
             * @type      {number}
             * @product   highcharts highstock
             * @apioption global.timezoneOffset
             */
            /**
             * General theme for buttons. This applies to the zoom button, exporting
             * context menu, map navigation, range selector buttons and custom
             * buttons generated using the `SVGRenderer.button` function. However,
             * each of these may be overridden with more specific options.
             *
             * @sample highcharts/global/buttontheme
             *         General button theme
             * @since 11.4.2
             */
            buttonTheme: {
                /**
                 * The fill color for buttons
                 */
                fill: "#f7f7f7" /* Palette.neutralColor3 */,
                /**
                 * The padding of buttons
                 */
                padding: 8,
                /**
                 * The border radius for buttons
                 */
                r: 2,
                /**
                 * The stroke color for buttons
                 */
                stroke: "#cccccc" /* Palette.neutralColor20 */,
                /**
                 * The stroke width for buttons
                 */
                'stroke-width': 1,
                /**
                 * CSS styling for the buttons' text
                 */
                style: {
                    color: "#333333" /* Palette.neutralColor80 */,
                    cursor: 'pointer',
                    fontSize: '0.8em',
                    fontWeight: 'normal'
                },
                /**
                 * State overrides for the buttons
                 */
                states: {
                    /**
                     * Hover state overrides for the buttons are applied in addition
                     * to the normal state options
                     */
                    hover: {
                        fill: "#e6e6e6" /* Palette.neutralColor10 */
                    },
                    /**
                     * Select state overrides for the buttons are applied in
                     * addition to the normal state options
                     */
                    select: {
                        fill: "#e6e9ff" /* Palette.highlightColor10 */,
                        style: {
                            color: "#000000" /* Palette.neutralColor100 */,
                            fontWeight: 'bold'
                        }
                    },
                    /**
                     * Disabled state overrides for the buttons are applied in
                     * addition to the normal state options
                     */
                    disabled: {
                        /**
                         * Disabled state CSS style overrides for the buttons' text
                         */
                        style: {
                            color: "#cccccc" /* Palette.neutralColor20 */
                        }
                    }
                }
            }
        },
        /**
         * Time options that can apply globally or to individual charts. These
         * settings affect how `datetime` axes are laid out, how tooltips are
         * formatted, how series
         * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
         * the Highcharts Stock range selector handles time.
         *
         * The common use case is that all charts in the same Highcharts object
         * share the same time settings, in which case the global settings are set
         * using `setOptions`.
         *
         * ```js
         * // Apply time settings globally
         * Highcharts.setOptions({
         *     time: {
         *         timezone: 'Europe/London'
         *     }
         * });
         * // Apply time settings by instance
         * let chart = Highcharts.chart('container', {
         *     time: {
         *         timezone: 'America/New_York'
         *     },
         *     series: [{
         *         data: [1, 4, 3, 5]
         *     }]
         * });
         *
         * // Use the Time object
         * console.log(
         *        'Current time in New York',
         *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
         * );
         * ```
         *
         * Since v6.0.5, the time options were moved from the `global` object to the
         * `time` object, and time options can be set on each individual chart.
         *
         * @sample {highcharts|highstock}
         *         highcharts/time/timezone/
         *         Set the timezone globally
         * @sample {highcharts}
         *         highcharts/time/individual/
         *         Set the timezone per chart instance
         * @sample {highstock}
         *         stock/time/individual/
         *         Set the timezone per chart instance
         *
         * @since     6.0.5
         * @optionparent time
         */
        time: {
            /**
             * A custom `Date` class for advanced date handling. For example,
             * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
             * handle Jalali dates.
             *
             * @type      {*}
             * @since     4.0.4
             * @product   highcharts highstock gantt
             */
            Date: void 0,
            /**
             * A callback to return the time zone offset for a given datetime. It
             * takes the timestamp in terms of milliseconds since January 1 1970,
             * and returns the timezone offset in minutes. This provides a hook
             * for drawing time based charts in specific time zones using their
             * local DST crossover dates, with the help of external libraries.
             *
             * This option is deprecated as of v11.4.1 and will be removed in a
             * future release. Use the [time.timezone](#time.timezone) option
             * instead.
             *
             * @sample {highcharts|highstock} highcharts/time/gettimezoneoffset/
             *         Use moment.js to draw Oslo time regardless of browser locale
             *
             * @type      {Highcharts.TimezoneOffsetCallbackFunction}
             * @since     4.1.0
             * @deprecated 11.4.2
             * @product   highcharts highstock gantt
             */
            getTimezoneOffset: void 0,
            /**
             * A named time zone. Supported time zone names rely on the browser
             * implementations, as described in the [mdn
             * docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#timezone).
             * If the given time zone is not recognized by the browser, Highcharts
             * provides a warning and falls back to returning a 0 offset,
             * corresponding to the UTC time zone.
             *
             * Until v11.2.0, this option depended on moment.js.
             *
             * @sample {highcharts|highstock} highcharts/time/timezone/ Europe/Oslo
             *
             * @type      {string}
             * @since     5.0.7
             * @product   highcharts highstock gantt
             */
            timezone: void 0,
            /**
             * The timezone offset in minutes. Positive values are west, negative
             * values are east of UTC, as in the ECMAScript
             * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
             * method. Use this to display UTC based data in a predefined time zone.
             *
             * This option is deprecated as of v11.4.1 and will be removed in a
             * future release. Use the [time.timezone](#time.timezone) option
             * instead.
             *
             * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
             *
             * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
             *         Timezone offset
             *
             * @since     3.0.8
             * @deprecated 11.4.2
             * @product   highcharts highstock gantt
             */
            timezoneOffset: 0,
            /**
             * Whether to use UTC time for axis scaling, tickmark placement and
             * time display in `Highcharts.dateFormat`. Advantages of using UTC
             * is that the time displays equally regardless of the user agent's
             * time zone settings. Local time can be used when the data is loaded
             * in real time or when correct Daylight Saving Time transitions are
             * required.
             *
             * @sample {highcharts} highcharts/time/useutc-true/
             *         True by default
             * @sample {highcharts} highcharts/time/useutc-false/
             *         False
             */
            useUTC: true
        },
        chart: ChartDefaults,
        /**
         * The chart's main title.
         *
         * @sample {highmaps} maps/title/title/
         *         Title options demonstrated
         */
        title: {
            /**
             * When the title is floating, the plot area will not move to make space
             * for it.
             *
             * @sample {highcharts} highcharts/chart/zoomtype-none/
             *         False by default
             * @sample {highcharts} highcharts/title/floating/
             *         True - title on top of the plot area
             * @sample {highstock} stock/chart/title-floating/
             *         True - title on top of the plot area
             *
             * @type      {boolean}
             * @default   false
             * @since     2.1
             * @apioption title.floating
             */
            /**
             * Whether to
             * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the text.
             *
             * @type      {boolean}
             * @default   false
             * @apioption title.useHTML
             */
            /**
             * The vertical alignment of the title. Can be one of `"top"`,
             * `"middle"` and `"bottom"`. When a value is given, the title behaves
             * as if [floating](#title.floating) were `true`.
             *
             * @sample {highcharts} highcharts/title/verticalalign/
             *         Chart title in bottom right corner
             * @sample {highstock} stock/chart/title-verticalalign/
             *         Chart title in bottom right corner
             *
             * @type      {Highcharts.VerticalAlignValue}
             * @since     2.1
             * @apioption title.verticalAlign
             */
            /**
             * The x position of the title relative to the alignment within
             * `chart.spacingLeft` and `chart.spacingRight`.
             *
             * @sample {highcharts} highcharts/title/align/
             *         Aligned to the plot area (x = 70px = margin left - spacing
             *         left)
             * @sample {highstock} stock/chart/title-align/
             *         Aligned to the plot area (x = 50px = margin left - spacing
             *         left)
             *
             * @type      {number}
             * @default   0
             * @since     2.0
             * @apioption title.x
             */
            /**
             * The y position of the title relative to the alignment within
             * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
             * #chart.spacingBottom). By default it depends on the font size.
             *
             * @sample {highcharts} highcharts/title/y/
             *         Title inside the plot area
             * @sample {highstock} stock/chart/title-verticalalign/
             *         Chart title in bottom right corner
             *
             * @type      {number}
             * @since     2.0
             * @apioption title.y
             */
            /**
             * CSS styles for the title. Use this for font styling, but use `align`,
             * `x` and `y` for text alignment.
             *
             * In styled mode, the title style is given in the `.highcharts-title`
             * class.
             *
             * @sample {highcharts} highcharts/title/style/
             *         Custom color and weight
             * @sample {highstock} stock/chart/title-style/
             *         Custom color and weight
             * @sample highcharts/css/titles/
             *         Styled mode
             *
             * @type      {Highcharts.CSSObject}
             * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
             * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
             */
            style: {
                color: "#333333" /* Palette.neutralColor80 */,
                fontWeight: 'bold'
            },
            /**
             * The title of the chart. To disable the title, set the `text` to
             * `undefined`.
             *
             * @sample {highcharts} highcharts/title/text/
             *         Custom title
             * @sample {highstock} stock/chart/title-text/
             *         Custom title
             *
             * @default {highcharts|highmaps} Chart title
             * @default {highstock} undefined
             */
            text: 'Chart title',
            /**
             * The horizontal alignment of the title. Can be one of "left", "center"
             * and "right".
             *
             * @sample {highcharts} highcharts/title/align/
             *         Aligned to the plot area (x = 70px = margin left - spacing
             *         left)
             * @sample {highstock} stock/chart/title-align/
             *         Aligned to the plot area (x = 50px = margin left - spacing
             *         left)
             *
             * @type  {Highcharts.AlignValue}
             * @since 2.0
             */
            align: 'center',
            /**
             * The margin between the title and the plot area, or if a subtitle
             * is present, the margin between the subtitle and the plot area.
             *
             * @sample {highcharts} highcharts/title/margin-50/
             *         A chart title margin of 50
             * @sample {highcharts} highcharts/title/margin-subtitle/
             *         The same margin applied with a subtitle
             * @sample {highstock} stock/chart/title-margin/
             *         A chart title margin of 50
             *
             * @since 2.1
             */
            margin: 15,
            /**
             * Adjustment made to the title width, normally to reserve space for
             * the exporting burger menu.
             *
             * @sample highcharts/title/widthadjust/
             *         Wider menu, greater padding
             *
             * @since 4.2.5
             */
            widthAdjust: -44
        },
        /**
         * The chart's subtitle. This can be used both to display a subtitle below
         * the main title, and to display random text anywhere in the chart. The
         * subtitle can be updated after chart initialization through the
         * `Chart.setTitle` method.
         *
         * @sample {highmaps} maps/title/subtitle/
         *         Subtitle options demonstrated
         */
        subtitle: {
            /**
             * When the subtitle is floating, the plot area will not move to make
             * space for it.
             *
             * @sample {highcharts} highcharts/subtitle/floating/
             *         Floating title and subtitle
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote floating at bottom right of plot area
             *
             * @type      {boolean}
             * @default   false
             * @since     2.1
             * @apioption subtitle.floating
             */
            /**
             * CSS styles for the title.
             *
             * In styled mode, the subtitle style is given in the
             * `.highcharts-subtitle` class.
             *
             * @sample {highcharts} highcharts/subtitle/style/
             *         Custom color and weight
             * @sample {highcharts} highcharts/css/titles/
             *         Styled mode
             * @sample {highstock} stock/chart/subtitle-style
             *         Custom color and weight
             * @sample {highstock} highcharts/css/titles/
             *         Styled mode
             * @sample {highmaps} highcharts/css/titles/
             *         Styled mode
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"color": "#666666"}
             * @apioption subtitle.style
             */
            /**
             * Whether to
             * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the text.
             *
             * @type      {boolean}
             * @default   false
             * @apioption subtitle.useHTML
             */
            /**
             * The vertical alignment of the title. Can be one of `"top"`,
             * `"middle"` and `"bottom"`. When middle, the subtitle behaves as
             * floating.
             *
             * @sample {highcharts} highcharts/subtitle/verticalalign/
             *         Footnote at the bottom right of plot area
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote at the bottom right of plot area
             *
             * @type      {Highcharts.VerticalAlignValue}
             * @since     2.1
             * @apioption subtitle.verticalAlign
             */
            /**
             * The x position of the subtitle relative to the alignment within
             * `chart.spacingLeft` and `chart.spacingRight`.
             *
             * @sample {highcharts} highcharts/subtitle/align/
             *         Footnote at right of plot area
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote at the bottom right of plot area
             *
             * @type      {number}
             * @default   0
             * @since     2.0
             * @apioption subtitle.x
             */
            /**
             * The y position of the subtitle relative to the alignment within
             * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
             * is laid out below the title unless the title is floating.
             *
             * @sample {highcharts} highcharts/subtitle/verticalalign/
             *         Footnote at the bottom right of plot area
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote at the bottom right of plot area
             *
             * @type      {number}
             * @since     2.0
             * @apioption subtitle.y
             */
            /**
             * CSS styles for the title.
             *
             * In styled mode, the subtitle style is given in the
             * `.highcharts-subtitle` class.
             *
             * @sample {highcharts} highcharts/subtitle/style/
             *         Custom color and weight
             * @sample {highcharts} highcharts/css/titles/
             *         Styled mode
             * @sample {highstock} stock/chart/subtitle-style
             *         Custom color and weight
             * @sample {highstock} highcharts/css/titles/
             *         Styled mode
             * @sample {highmaps} highcharts/css/titles/
             *         Styled mode
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"color": "#666666"}
             */
            style: {
                color: "#666666" /* Palette.neutralColor60 */,
                fontSize: '0.8em'
            },
            /**
             * The subtitle of the chart.
             *
             * @sample {highcharts|highstock} highcharts/subtitle/text/
             *         Custom subtitle
             * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
             *         Formatted and linked text.
             */
            text: '',
            /**
             * The horizontal alignment of the subtitle. Can be one of "left",
             *  "center" and "right".
             *
             * @sample {highcharts} highcharts/subtitle/align/
             *         Footnote at right of plot area
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote at bottom right of plot area
             *
             * @type  {Highcharts.AlignValue}
             * @since 2.0
             */
            align: 'center',
            /**
             * Adjustment made to the subtitle width, normally to reserve space
             * for the exporting burger menu.
             *
             * @see [title.widthAdjust](#title.widthAdjust)
             *
             * @sample highcharts/title/widthadjust/
             *         Wider menu, greater padding
             *
             * @since 4.2.5
             */
            widthAdjust: -44
        },
        /**
         * The chart's caption, which will render below the chart and will be part
         * of exported charts. The caption can be updated after chart initialization
         * through the `Chart.update` or `Chart.caption.update` methods.
         *
         * @sample highcharts/caption/text/
         *         A chart with a caption
         * @since  7.2.0
         */
        caption: {
            /**
             * When the caption is floating, the plot area will not move to make
             * space for it.
             *
             * @type      {boolean}
             * @default   false
             * @apioption caption.floating
             */
            /**
             * The margin between the caption and the plot area.
             */
            margin: 15,
            /**
             * Whether to
             * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the text.
             *
             * @type      {boolean}
             * @default   false
             * @apioption caption.useHTML
             */
            /**
             * The x position of the caption relative to the alignment within
             * `chart.spacingLeft` and `chart.spacingRight`.
             *
             * @type      {number}
             * @default   0
             * @apioption caption.x
             */
            /**
             * The y position of the caption relative to the alignment within
             * `chart.spacingTop` and `chart.spacingBottom`.
             *
             * @type      {number}
             * @apioption caption.y
             */
            /**
             * CSS styles for the caption.
             *
             * In styled mode, the caption style is given in the
             * `.highcharts-caption` class.
             *
             * @sample {highcharts} highcharts/css/titles/
             *         Styled mode
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"color": "#666666"}
             */
            style: {
                color: "#666666" /* Palette.neutralColor60 */,
                fontSize: '0.8em'
            },
            /**
             * The caption text of the chart.
             *
             * @sample {highcharts} highcharts/caption/text/
             *         Custom caption
             */
            text: '',
            /**
             * The horizontal alignment of the caption. Can be one of "left",
             *  "center" and "right".
             *
             * @type  {Highcharts.AlignValue}
             */
            align: 'left',
            /**
             * The vertical alignment of the caption. Can be one of `"top"`,
             * `"middle"` and `"bottom"`. When middle, the caption behaves as
             * floating.
             *
             * @type      {Highcharts.VerticalAlignValue}
             */
            verticalAlign: 'bottom'
        },
        /**
         * The plotOptions is a wrapper object for config objects for each series
         * type. The config objects for each series can also be overridden for
         * each series item as given in the series array.
         *
         * Configuration options for the series are given in three levels. Options
         * for all series in a chart are given in the [plotOptions.series](
         * #plotOptions.series) object. Then options for all series of a specific
         * type are given in the plotOptions of that type, for example
         * `plotOptions.line`. Next, options for one single series are given in
         * [the series array](#series).
         */
        plotOptions: {},
        /**
         * The legend is a box containing a symbol and name for each series
         * item or point item in the chart. Each series (or points in case
         * of pie charts) is represented by a symbol and its name in the legend.
         *
         * It is possible to override the symbol creator function and create
         * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
         *
         * @productdesc {highmaps}
         * A Highmaps legend by default contains one legend item per series, but if
         * a `colorAxis` is defined, the axis will be displayed in the legend.
         * Either as a gradient, or as multiple legend items for `dataClasses`.
         */
        legend: {
            /**
             * The background color of the legend.
             *
             * @see In styled mode, the legend background fill can be applied with
             *      the `.highcharts-legend-box` class.
             *
             * @sample {highcharts} highcharts/legend/backgroundcolor/
             *         Yellowish background
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption legend.backgroundColor
             */
            /**
             * The width of the drawn border around the legend.
             *
             * @see In styled mode, the legend border stroke width can be applied
             *      with the `.highcharts-legend-box` class.
             *
             * @sample {highcharts} highcharts/legend/borderwidth/
             *         2px border width
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             *
             * @type      {number}
             * @default   0
             * @apioption legend.borderWidth
             */
            /**
             * Enable or disable the legend. There is also a series-specific option,
             * [showInLegend](#plotOptions.series.showInLegend), that can hide the
             * series from the legend. In some series types this is `false` by
             * default, so it must set to `true` in order to show the legend for the
             * series.
             *
             * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
             * @sample {highstock} stock/legend/align/ Various legend options
             * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
             *
             * @default {highstock} false
             * @default {highmaps} true
             * @default {gantt} false
             */
            enabled: true,
            /**
             * The horizontal alignment of the legend box within the chart area.
             * Valid values are `left`, `center` and `right`.
             *
             * In the case that the legend is aligned in a corner position, the
             * `layout` option will determine whether to place it above/below
             * or on the side of the plot area.
             *
             * @sample {highcharts} highcharts/legend/align/
             *         Legend at the right of the chart
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/alignment/
             *         Legend alignment
             *
             * @type  {Highcharts.AlignValue}
             * @since 2.0
             */
            align: 'center',
            /**
             * If the [layout](legend.layout) is `horizontal` and the legend items
             * span over two lines or more, whether to align the items into vertical
             * columns. Setting this to `false` makes room for more items, but will
             * look more messy.
             *
             * @since 6.1.0
             */
            alignColumns: true,
            /**
             * A CSS class name to apply to the legend group.
             */
            className: 'highcharts-no-tooltip',
            /**
             * General event handlers for the legend. These event hooks can
             * also be attached to the legend at run time using the
             * `Highcharts.addEvent` function.
             *
             * @declare Highcharts.LegendEventsOptionsObject
             *
             * @private
             */
            events: {},
            /**
             * Fires when the legend item belonging to the series is clicked. One
             * parameter, `event`, is passed to the function. The default action
             * is to toggle the visibility of the series, point or data class. This
             * can be prevented by returning `false` or calling
             * `event.preventDefault()`.
             *
             * @sample {highcharts} highcharts/legend/itemclick/
             *         Confirm hiding and showing
             * @sample {highcharts} highcharts/legend/pie-legend-itemclick/
             *         Confirm toggle visibility of pie slices
             *
             * @type      {Highcharts.LegendItemClickCallbackFunction}
             * @context   Highcharts.Legend
             * @apioption legend.events.itemClick
             */
            /**
             * When the legend is floating, the plot area ignores it and is allowed
             * to be placed below it.
             *
             * @sample {highcharts} highcharts/legend/floating-false/
             *         False by default
             * @sample {highcharts} highcharts/legend/floating-true/
             *         True
             * @sample {highmaps} maps/legend/alignment/
             *         Floating legend
             *
             * @type      {boolean}
             * @default   false
             * @since     2.1
             * @apioption legend.floating
             */
            /**
             * The layout of the legend items. Can be one of `horizontal` or
             * `vertical` or `proximate`. When `proximate`, the legend items will be
             * placed as close as possible to the graphs they're representing,
             * except in inverted charts or when the legend position doesn't allow
             * it.
             *
             * @sample {highcharts} highcharts/legend/layout-horizontal/
             *         Horizontal by default
             * @sample {highcharts} highcharts/legend/layout-vertical/
             *         Vertical
             * @sample highcharts/legend/layout-proximate
             *         Labels proximate to the data
             * @sample {highstock} stock/legend/layout-horizontal/
             *         Horizontal by default
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Vertical with data classes
             * @sample {highmaps} maps/legend/layout-vertical/
             *         Vertical with color axis gradient
             *
             * @validvalue ["horizontal", "vertical", "proximate"]
             */
            layout: 'horizontal',
            /**
             * In a legend with horizontal layout, the itemDistance defines the
             * pixel distance between each item.
             *
             * @sample {highcharts} highcharts/legend/layout-horizontal/
             *         50px item distance
             * @sample {highstock} highcharts/legend/layout-horizontal/
             *         50px item distance
             *
             * @type      {number}
             * @default   {highcharts} 20
             * @default   {highstock} 20
             * @default   {highmaps} 8
             * @since     3.0.3
             * @apioption legend.itemDistance
             */
            /**
             * The pixel bottom margin for each legend item.
             *
             * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             *
             * @since     2.2.0
             */
            itemMarginBottom: 2,
            /**
             * The pixel top margin for each legend item.
             *
             * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             *
             * @since     2.2.0
             */
            itemMarginTop: 2,
            /**
             * The width for each legend item. By default the items are laid out
             * successively. In a [horizontal layout](legend.layout), if the items
             * are laid out across two rows or more, they will be vertically aligned
             * depending on the [legend.alignColumns](legend.alignColumns) option.
             *
             * @sample {highcharts} highcharts/legend/itemwidth-default/
             *         Undefined by default
             * @sample {highcharts} highcharts/legend/itemwidth-80/
             *         80 for aligned legend items
             *
             * @type      {number}
             * @since     2.0
             * @apioption legend.itemWidth
             */
            /**
             * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * for each legend label. Available variables relates to properties on
             * the series, or the point in case of pies.
             *
             * @type      {string}
             * @default   {name}
             * @since     1.3
             * @apioption legend.labelFormat
             */
            /* eslint-disable valid-jsdoc */
            /**
             * Callback function to format each of the series' labels. The `this`
             * keyword refers to the series object, or the point object in case of
             * pie charts. By default the series or point name is printed.
             *
             * @productdesc {highmaps}
             * In Highmaps the context can also be a data class in case of a
             * `colorAxis`.
             *
             * @sample {highcharts} highcharts/legend/labelformatter/
             *         Add text
             * @sample {highmaps} maps/legend/labelformatter/
             *         Data classes with label formatter
             *
             * @type {Highcharts.FormatterCallbackFunction<Point|Series>}
             */
            labelFormatter: function () {
                // eslint-enable valid-jsdoc
                return this.name;
            },
            /**
             * Line height for the legend items. Deprecated as of 2.1\. Instead,
             * the line height for each item can be set using
             * `itemStyle.lineHeight`, and the padding between items using
             * `itemMarginTop` and `itemMarginBottom`.
             *
             * @sample {highcharts} highcharts/legend/lineheight/
             *         Setting padding
             *
             * @deprecated
             *
             * @type      {number}
             * @default   16
             * @since     2.0
             * @product   highcharts gantt
             * @apioption legend.lineHeight
             */
            /**
             * If the plot area sized is calculated automatically and the legend is
             * not floating, the legend margin is the space between the legend and
             * the axis labels or plot area.
             *
             * @sample {highcharts} highcharts/legend/margin-default/
             *         12 pixels by default
             * @sample {highcharts} highcharts/legend/margin-30/
             *         30 pixels
             *
             * @type      {number}
             * @default   12
             * @since     2.1
             * @apioption legend.margin
             */
            /**
             * Maximum pixel height for the legend. When the maximum height is
             * extended, navigation will show.
             *
             * @type      {number}
             * @since     2.3.0
             * @apioption legend.maxHeight
             */
            /**
             * The color of the drawn border around the legend.
             *
             * @see In styled mode, the legend border stroke can be applied with the
             *      `.highcharts-legend-box` class.
             *
             * @sample {highcharts} highcharts/legend/bordercolor/
             *         Brown border
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            borderColor: "#999999" /* Palette.neutralColor40 */,
            /**
             * The border corner radius of the legend.
             *
             * @sample {highcharts} highcharts/legend/borderradius-default/
             *         Square by default
             * @sample {highcharts} highcharts/legend/borderradius-round/
             *         5px rounded
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             */
            borderRadius: 0,
            /**
             * Options for the paging or navigation appearing when the legend is
             * overflown. Navigation works well on screen, but not in static
             * exported images. One way of working around that is to
             * [increase the chart height in
             * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
             *
             * @sample highcharts/legend/scrollable-vertical/
             *         Legend with vertical scrollable extension
             * @sample highcharts/legend/scrollable-horizontal/
             *         Legend with horizontal scrollable extension
             *
             */
            navigation: {
                /**
                 * How to animate the pages when navigating up or down. A value of
                 * `true` applies the default navigation given in the
                 * `chart.animation` option. Additional options can be given as an
                 * object containing values for easing and duration.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @default   true
                 * @since     2.2.4
                 * @apioption legend.navigation.animation
                 */
                /**
                 * The pixel size of the up and down arrows in the legend paging
                 * navigation.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {number}
                 * @default   12
                 * @since     2.2.4
                 * @apioption legend.navigation.arrowSize
                 */
                /**
                 * Whether to enable the legend navigation. In most cases, disabling
                 * the navigation results in an unwanted overflow.
                 *
                 * See also the
                 * [adapt chart to legend](https://github.com/highcharts/adapt-chart-to-legend)
                 * plugin for a solution to extend the chart height to make room for
                 * the legend, optionally in exported charts only.
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     4.2.4
                 * @apioption legend.navigation.enabled
                 */
                /**
                 * Text styles for the legend page navigation.
                 *
                 * @see In styled mode, the navigation items are styled with the
                 *      `.highcharts-legend-navigation` class.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {Highcharts.CSSObject}
                 * @since     2.2.4
                 * @apioption legend.navigation.style
                 */
                style: {
                    fontSize: '0.8em'
                },
                /**
                 * The color for the active up or down arrow in the legend page
                 * navigation.
                 *
                 * @see In styled mode, the active arrow be styled with the
                 *      `.highcharts-legend-nav-active` class.
                 *
                 * @sample  {highcharts} highcharts/legend/navigation/
                 *          Legend page navigation demonstrated
                 * @sample  {highstock} highcharts/legend/navigation/
                 *          Legend page navigation demonstrated
                 *
                 * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since 2.2.4
                 */
                activeColor: "#0022ff" /* Palette.highlightColor100 */,
                /**
                 * The color of the inactive up or down arrow in the legend page
                 * navigation. .
                 *
                 * @see In styled mode, the inactive arrow be styled with the
                 *      `.highcharts-legend-nav-inactive` class.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since 2.2.4
                 */
                inactiveColor: "#cccccc" /* Palette.neutralColor20 */
            },
            /**
             * The inner padding of the legend box.
             *
             * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             *
             * @type      {number}
             * @default   8
             * @since     2.2.0
             * @apioption legend.padding
             */
            /**
             * Whether to reverse the order of the legend items compared to the
             * order of the series or points as defined in the configuration object.
             *
             * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
             *      [series.legendIndex](#series.legendIndex)
             *
             * @sample {highcharts} highcharts/legend/reversed/
             *         Stacked bar with reversed legend
             *
             * @type      {boolean}
             * @default   false
             * @since     1.2.5
             * @apioption legend.reversed
             */
            /**
             * Whether to show the symbol on the right side of the text rather than
             * the left side. This is common in Arabic and Hebrew.
             *
             * @sample {highcharts} highcharts/legend/rtl/
             *         Symbol to the right
             *
             * @type      {boolean}
             * @default   false
             * @since     2.2
             * @apioption legend.rtl
             */
            /**
             * CSS styles for the legend area. In the 1.x versions the position
             * of the legend area was determined by CSS. In 2.x, the position is
             * determined by properties like `align`, `verticalAlign`, `x` and `y`,
             * but the styles are still parsed for backwards compatibility.
             *
             * @deprecated
             *
             * @type      {Highcharts.CSSObject}
             * @product   highcharts highstock
             * @apioption legend.style
             */
            /**
             * CSS styles for each legend item. Only a subset of CSS is supported,
             * notably those options related to text. The default `textOverflow`
             * property makes long texts truncate. Set it to `undefined` to wrap
             * text instead. A `width` property can be added to control the text
             * width.
             *
             * @see In styled mode, the legend items can be styled with the
             *      `.highcharts-legend-item` class.
             *
             * @sample {highcharts} highcharts/legend/itemstyle/
             *         Bold black text
             * @sample {highmaps} maps/legend/itemstyle/
             *         Item text styles
             *
             * @type    {Highcharts.CSSObject}
             * @default {"color": "#333333", "cursor": "pointer", "fontSize": "0.8em", "fontWeight": "bold", "textOverflow": "ellipsis"}
             */
            itemStyle: {
                /**
                 * @ignore
                 */
                color: "#333333" /* Palette.neutralColor80 */,
                /**
                 * @ignore
                 */
                cursor: 'pointer',
                /**
                 * @ignore
                 */
                fontSize: '0.8em',
                /**
                 * @ignore
                 */
                textDecoration: 'none',
                /**
                 * @ignore
                 */
                textOverflow: 'ellipsis'
            },
            /**
             * CSS styles for each legend item in hover mode. Only a subset of
             * CSS is supported, notably those options related to text. Properties
             * are inherited from `style` unless overridden here.
             *
             * @see In styled mode, the hovered legend items can be styled with
             *      the `.highcharts-legend-item:hover` pseudo-class.
             *
             * @sample {highcharts} highcharts/legend/itemhoverstyle/
             *         Red on hover
             * @sample {highmaps} maps/legend/itemstyle/
             *         Item text styles
             *
             * @type    {Highcharts.CSSObject}
             * @default {"color": "#000000"}
             */
            itemHoverStyle: {
                /**
                 * @ignore
                 */
                color: "#000000" /* Palette.neutralColor100 */
            },
            /**
             * CSS styles for each legend item when the corresponding series or
             * point is hidden. Only a subset of CSS is supported, notably those
             * options related to text. Properties are inherited from `style`
             * unless overridden here.
             *
             * @see In styled mode, the hidden legend items can be styled with
             *      the `.highcharts-legend-item-hidden` class.
             *
             * @sample {highcharts} highcharts/legend/itemhiddenstyle/
             *         Darker gray color
             *
             * @type    {Highcharts.CSSObject}
             * @default {"color": "#cccccc"}
             */
            itemHiddenStyle: {
                /**
                 * @ignore
                 */
                color: "#666666" /* Palette.neutralColor60 */,
                /**
                 * @ignore
                 */
                textDecoration: 'line-through'
            },
            /**
             * Whether to apply a drop shadow to the legend. A `backgroundColor`
             * also needs to be applied for this to take effect. The shadow can be
             * an object configuration containing `color`, `offsetX`, `offsetY`,
             * `opacity` and `width`.
             *
             * @sample {highcharts} highcharts/legend/shadow/
             *         White background and drop shadow
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             *
             * @type {boolean|Highcharts.CSSObject}
             */
            shadow: false,
            /**
             * Default styling for the checkbox next to a legend item when
             * `showCheckbox` is true.
             *
             * @type {Highcharts.CSSObject}
             * @default {"width": "13px", "height": "13px", "position":"absolute"}
             */
            itemCheckboxStyle: {
                /**
                 * @ignore
                 */
                position: 'absolute',
                /**
                 * @ignore
                 */
                width: '13px', // For IE precision
                /**
                 * @ignore
                 */
                height: '13px'
            },
            /// itemWidth: undefined,
            /**
             * When this is true, the legend symbol width will be the same as
             * the symbol height, which in turn defaults to the font size of the
             * legend items.
             *
             * @since 5.0.0
             */
            squareSymbol: true,
            /**
             * The pixel height of the symbol for series types that use a rectangle
             * in the legend. Defaults to the font size of legend items.
             *
             * Note: This option is a default source of color axis height, if the
             * [colorAxis.height](https://api.highcharts.com/highcharts/colorAxis.height)
             * option is not set.
             *
             * @productdesc {highmaps}
             * In Highmaps, when the symbol is the gradient of a vertical color
             * axis, the height defaults to 200.
             *
             * @sample {highmaps} maps/legend/layout-vertical-sized/
             *         Sized vertical gradient
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         No distance between data classes
             *
             * @type      {number}
             * @since     3.0.8
             * @apioption legend.symbolHeight
             */
            /**
             * The border radius of the symbol for series types that use a rectangle
             * in the legend. Defaults to half the `symbolHeight`, effectively
             * creating a circle.
             *
             * For color axis scales, it defaults to 3.
             *
             * @sample {highcharts} highcharts/legend/symbolradius/
             *         Round symbols
             * @sample {highstock} highcharts/legend/symbolradius/
             *         Round symbols
             * @sample {highmaps} highcharts/legend/symbolradius/
             *         Round symbols
             *
             * @type      {number}
             * @since     3.0.8
             * @apioption legend.symbolRadius
             */
            /**
             * The pixel width of the legend item symbol. When the `squareSymbol`
             * option is set, this defaults to the `symbolHeight`, otherwise 16.
             *
             * Note: This option is a default source of color axis width, if the
             * [colorAxis.width](https://api.highcharts.com/highcharts/colorAxis.width)
             * option is not set.
             *
             * @productdesc {highmaps}
             * In Highmaps, when the symbol is the gradient of a horizontal color
             * axis, the width defaults to 200.
             *
             * @sample {highcharts} highcharts/legend/symbolwidth/
             *         Greater symbol width and padding
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             * @sample {highmaps} maps/legend/layout-vertical-sized/
             *         Sized vertical gradient
             *
             * @type      {number}
             * @apioption legend.symbolWidth
             */
            /**
             * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the legend item texts.
             *
             * Prior to 4.1.7, when using HTML, [legend.navigation](
             * #legend.navigation) was disabled.
             *
             * @sample highcharts/legend/scrollable-vertical/
             *         Legend with vertical scrollable extension
             * @sample highcharts/legend/scrollable-horizontal/
             *         Legend with horizontal scrollable extension
             *
             * @type      {boolean}
             * @default   false
             * @apioption legend.useHTML
             */
            /**
             * For a color axis with data classes, how many decimals to render in
             * the legend. The default preserves the decimals of the range numbers.
             *
             * @type      {number}
             * @default   -1
             * @product   highcharts highmaps
             * @apioption legend.valueDecimals
             */
            /**
             * For a color axis with data classes, a suffix for the range numbers in
             * the legend.
             *
             * @type      {string}
             * @default   ''
             * @product   highcharts highmaps
             * @apioption legend.valueSuffix
             */
            /**
             * The width of the legend box. If a number is set, it translates to
             * pixels. Since v7.0.2 it allows setting a percent string of the full
             * chart width, for example `40%`.
             *
             * Defaults to the full chart width for legends below or above the
             * chart, half the chart width for legends to the left and right.
             *
             * @sample {highcharts} highcharts/legend/width/
             *         Aligned to the plot area
             * @sample {highcharts} highcharts/legend/width-percent/
             *         A percent of the chart width
             *
             * @type      {number|string}
             * @since     2.0
             * @apioption legend.width
             */
            /**
             * The pixel padding between the legend item symbol and the legend
             * item text.
             *
             * @sample {highcharts} highcharts/legend/symbolpadding/
             *         Greater symbol width and padding
             */
            symbolPadding: 5,
            /**
             * The vertical alignment of the legend box. Can be one of `top`,
             * `middle` or `bottom`. Vertical position can be further determined
             * by the `y` option.
             *
             * In the case that the legend is aligned in a corner position, the
             * `layout` option will determine whether to place it above/below
             * or on the side of the plot area.
             *
             * When the [layout](#legend.layout) option is `proximate`, the
             * `verticalAlign` option doesn't apply.
             *
             * @sample {highcharts} highcharts/legend/verticalalign/
             *         Legend 100px from the top of the chart
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/alignment/
             *         Legend alignment
             *
             * @type  {Highcharts.VerticalAlignValue}
             * @since 2.0
             */
            verticalAlign: 'bottom',
            // Width: undefined,
            /**
             * The x offset of the legend relative to its horizontal alignment
             * `align` within chart.spacingLeft and chart.spacingRight. Negative
             * x moves it to the left, positive x moves it to the right.
             *
             * @sample {highcharts} highcharts/legend/width/
             *         Aligned to the plot area
             *
             * @since 2.0
             */
            x: 0,
            /**
             * The vertical offset of the legend relative to it's vertical alignment
             * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
             *  Negative y moves it up, positive y moves it down.
             *
             * @sample {highcharts} highcharts/legend/verticalalign/
             *         Legend 100px from the top of the chart
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/alignment/
             *         Legend alignment
             *
             * @since 2.0
             */
            y: 0,
            /**
             * A title to be added on top of the legend.
             *
             * @sample {highcharts} highcharts/legend/title/
             *         Legend title
             * @sample {highmaps} maps/legend/alignment/
             *         Legend with title
             *
             * @since 3.0
             */
            title: {
                /**
                 * A text or HTML string for the title.
                 *
                 * @type      {string}
                 * @since     3.0
                 * @apioption legend.title.text
                 */
                /**
                 * Generic CSS styles for the legend title.
                 *
                 * @see In styled mode, the legend title is styled with the
                 *      `.highcharts-legend-title` class.
                 *
                 * @type    {Highcharts.CSSObject}
                 * @default {"fontSize": "0.8em", "fontWeight": "bold"}
                 * @since   3.0
                 */
                style: {
                    /**
                     * @ignore
                     */
                    fontSize: '0.8em',
                    /**
                     * @ignore
                     */
                    fontWeight: 'bold'
                }
            }
        },
        /**
         * The loading options control the appearance of the loading screen
         * that covers the plot area on chart operations. This screen only
         * appears after an explicit call to `chart.showLoading()`. It is a
         * utility for developers to communicate to the end user that something
         * is going on, for example while retrieving new data via an XHR connection.
         * The "Loading..." text itself is not part of this configuration
         * object, but part of the `lang` object.
         */
        loading: {
            /**
             * The duration in milliseconds of the fade out effect.
             *
             * @sample highcharts/loading/hideduration/
             *         Fade in and out over a second
             *
             * @type      {number}
             * @default   100
             * @since     1.2.0
             * @apioption loading.hideDuration
             */
            /**
             * The duration in milliseconds of the fade in effect.
             *
             * @sample highcharts/loading/hideduration/
             *         Fade in and out over a second
             *
             * @type      {number}
             * @default   100
             * @since     1.2.0
             * @apioption loading.showDuration
             */
            /**
             * CSS styles for the loading label `span`.
             *
             * @see In styled mode, the loading label is styled with the
             *      `.highcharts-loading-inner` class.
             *
             * @sample {highcharts|highmaps} highcharts/loading/labelstyle/
             *         Vertically centered
             * @sample {highstock} stock/loading/general/
             *         Label styles
             *
             * @type    {Highcharts.CSSObject}
             * @default {"fontWeight": "bold", "position": "relative", "top": "45%"}
             * @since   1.2.0
             */
            labelStyle: {
                /**
                 * @ignore
                 */
                fontWeight: 'bold',
                /**
                 * @ignore
                 */
                position: 'relative',
                /**
                 * @ignore
                 */
                top: '45%'
            },
            /**
             * CSS styles for the loading screen that covers the plot area.
             *
             * In styled mode, the loading label is styled with the
             * `.highcharts-loading` class.
             *
             * @sample  {highcharts|highmaps} highcharts/loading/style/
             *          Gray plot area, white text
             * @sample  {highstock} stock/loading/general/
             *          Gray plot area, white text
             *
             * @type    {Highcharts.CSSObject}
             * @default {"position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center"}
             * @since   1.2.0
             */
            style: {
                /**
                 * @ignore
                 */
                position: 'absolute',
                /**
                 * @ignore
                 */
                backgroundColor: "#ffffff" /* Palette.backgroundColor */,
                /**
                 * @ignore
                 */
                opacity: 0.5,
                /**
                 * @ignore
                 */
                textAlign: 'center'
            }
        },
        /**
         * Options for the tooltip that appears when the user hovers over a
         * series or point.
         *
         * @declare Highcharts.TooltipOptions
         */
        tooltip: {
            /**
             * The color of the tooltip border. When `undefined`, the border takes
             * the color of the corresponding series or point.
             *
             * Note that the [borderWidth](#tooltip.borderWidth) is usually 0 by
             * default, so the border color may not be visible until a border width
             * is set.
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/ Follow
             *         series by default
             * @sample {highcharts} highcharts/tooltip/bordercolor-black/ Black
             *         border
             * @sample {highstock} stock/tooltip/general/ Styled tooltip
             * @sample {highmaps} maps/tooltip/background-border/ Background and
             *         border demo
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption tooltip.borderColor
             */
            /**
             * A CSS class name to apply to the tooltip's container div,
             * allowing unique CSS styling for each chart.
             *
             * @type      {string}
             * @apioption tooltip.className
             */
            /**
             * Since 4.1, the crosshair definitions are moved to the Axis object
             * in order for a better separation from the tooltip. See
             * [xAxis.crosshair](#xAxis.crosshair).
             *
             * @sample {highcharts} highcharts/tooltip/crosshairs-x/
             *         Enable a crosshair for the x value
             *
             * @deprecated
             *
             * @type      {*}
             * @default   true
             * @apioption tooltip.crosshairs
             */
            /**
             * Distance from point to tooltip in pixels.
             *
             * @type      {number}
             * @default   16
             * @apioption tooltip.distance
             */
            /**
             * Whether the tooltip should follow the mouse as it moves across
             * columns, pie slices and other point types with an extent.
             * By default it behaves this way for pie, polygon, map, sankey
             * and wordcloud series by override in the `plotOptions`
             * for those series types.
             *
             * Does not apply if [split](#tooltip.split) is `true`.
             *
             * For touch moves to behave the same way, [followTouchMove](
             * #tooltip.followTouchMove) must be `true` also.
             *
             * @sample highcharts/tooltip/followpointer/
             *         Tooltip follow pointer comparison
             *
             * @type      {boolean}
             * @default   {highcharts} false
             * @default   {highstock} false
             * @default   {highmaps} true
             * @since     3.0
             * @apioption tooltip.followPointer
             */
            /**
             * Whether the tooltip should update as the finger moves on a touch
             * device. If this is `true` and [chart.panning](#chart.panning) is
             * set,`followTouchMove` will take over one-finger touches, so the user
             * needs to use two fingers for zooming and panning.
             *
             * Note the difference to [followPointer](#tooltip.followPointer) that
             * only defines the _position_ of the tooltip. If `followPointer` is
             * false in for example a column series, the tooltip will show above or
             * below the column, but as `followTouchMove` is true, the tooltip will
             * jump from column to column as the user swipes across the plot area.
             *
             * @type      {boolean}
             * @default   {highcharts} true
             * @default   {highstock} true
             * @default   {highmaps} false
             * @since     3.0.1
             * @apioption tooltip.followTouchMove
             */
            /**
             * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * for the whole shared tooltip. When format strings are a requirement,
             * it is usually more convenient to use `headerFormat`, `pointFormat`
             * and `footerFormat`, but the `format` option allows combining them
             * into one setting.
             *
             * The context of the format string is the same as that of the
             * `tooltip.formatter` callback.
             *
             * @sample {highcharts} highcharts/tooltip/format-shared/
             *         Format for shared tooltip
             *
             * @type      {string}
             * @default   undefined
             * @since     11.1.0
             * @apioption tooltip.format
             */
            /**
             * Callback function to format the text of the tooltip from scratch. In
             * case of single or [shared](#tooltip.shared) tooltips, a string should
             * be returned. In case of [split](#tooltip.split) tooltips, it should
             * return an array where the first item is the header, and subsequent
             * items are mapped to the points. Return `false` to disable tooltip for
             * a specific point on series.
             *
             * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
             * the tooltip is parsed and converted to SVG, therefore this isn't a
             * complete HTML renderer. The following HTML tags are supported: `b`,
             * `br`, `em`, `i`, `span`, `strong`. Spans can be styled with a `style`
             * attribute, but only text-related CSS, that is shared with SVG, is
             * handled.
             *
             * The available data in the formatter differ a bit depending on whether
             * the tooltip is shared or split, or belongs to a single point. In a
             * shared/split tooltip, all properties except `x`, which is common for
             * all points, are kept in an array, `this.points`.
             *
             * Available data are:
             *
             * - **this.percentage (not shared) /**
             *   **this.points[i].percentage (shared)**:
             *   Stacked series and pies only. The point's percentage of the total.
             *
             * - **this.point (not shared) / this.points[i].point (shared)**:
             *   The point object. The point name, if defined, is available through
             *   `this.point.name`.
             *
             * - **this.points**:
             *   In a shared tooltip, this is an array containing all other
             *   properties for each point.
             *
             * - **this.series (not shared) / this.points[i].series (shared)**:
             *   The series object. The series name is available through
             *   `this.series.name`.
             *
             * - **this.total (not shared) / this.points[i].total (shared)**:
             *   Stacked series only. The total value at this point's x value.
             *
             * - **this.x**:
             *   The x value. This property is the same regardless of the tooltip
             *   being shared or not.
             *
             * - **this.y (not shared) / this.points[i].y (shared)**:
             *   The y value.
             *
             * @sample {highcharts} highcharts/tooltip/formatter-simple/
             *         Simple string formatting
             * @sample {highcharts} highcharts/tooltip/formatter-shared/
             *         Formatting with shared tooltip
             * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
             *         Formatting with split tooltip
             * @sample highcharts/tooltip/formatter-conditional-default/
             *         Extending default formatter
             * @sample {highstock} stock/tooltip/formatter/
             *         Formatting with shared tooltip
             * @sample {highmaps} maps/tooltip/formatter/
             *         String formatting
             *
             * @type      {Highcharts.TooltipFormatterCallbackFunction}
             * @apioption tooltip.formatter
             */
            /**
             * Callback function to format the text of the tooltip for
             * visible null points.
             * Works analogously to [formatter](#tooltip.formatter).
             *
             * @sample highcharts/plotoptions/series-nullformat
             *         Format data label and tooltip for null point.
             *
             * @type      {Highcharts.TooltipFormatterCallbackFunction}
             * @apioption tooltip.nullFormatter
             */
            /**
             * Whether to allow the tooltip to render outside the chart's SVG
             * element box. By default (`false`), the tooltip is rendered within the
             * chart's SVG element, which results in the tooltip being aligned
             * inside the chart area. For small charts, this may result in clipping
             * or overlapping. When `true`, a separate SVG element is created and
             * overlaid on the page, allowing the tooltip to be aligned inside the
             * page itself.
             *
             * Defaults to `true` if `chart.scrollablePlotArea` is activated,
             * otherwise `false`.
             *
             * @sample highcharts/tooltip/outside
             *         Small charts with tooltips outside
             *
             * @type      {boolean|undefined}
             * @default   undefined
             * @since     6.1.1
             * @apioption tooltip.outside
             */
            /**
             * A callback function for formatting the HTML output for a single point
             * in the tooltip. Like the `pointFormat` string, but with more
             * flexibility.
             *
             * @type      {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
             * @since     4.1.0
             * @context   Highcharts.Point
             * @apioption tooltip.pointFormatter
             */
            /**
             * A callback function to place the tooltip in a custom position. The
             * callback receives three parameters: `labelWidth`, `labelHeight` and
             * `point`, where point contains values for `plotX` and `plotY` telling
             * where the reference point is in the plot area. Add `chart.plotLeft`
             * and `chart.plotTop` to get the full coordinates.
             *
             * To find the actual hovered `Point` instance, use
             * `this.chart.hoverPoint`. For shared or split tooltips, all the hover
             * points are available in `this.chart.hoverPoints`.
             *
             * Since v7, when [tooltip.split](#tooltip.split) option is enabled,
             * positioner is called for each of the boxes separately, including
             * xAxis header. xAxis header is not a point, instead `point` argument
             * contains info: `{ plotX: Number, plotY: Number, isHeader: Boolean }`
             *
             * The return should be an object containing x and y values, for example
             * `{ x: 100, y: 100 }`.
             *
             * @sample {highcharts} highcharts/tooltip/positioner/
             *         A fixed tooltip position
             * @sample {highstock} stock/tooltip/positioner/
             *         A fixed tooltip position on top of the chart
             * @sample {highmaps} maps/tooltip/positioner/
             *         A fixed tooltip position
             * @sample {highstock} stock/tooltip/split-positioner/
             *         Split tooltip with fixed positions
             * @sample {highstock} stock/tooltip/positioner-scrollable-plotarea/
             *         Scrollable plot area combined with tooltip positioner
             *
             * @type      {Highcharts.TooltipPositionerCallbackFunction}
             * @since     2.2.4
             * @apioption tooltip.positioner
             */
            /**
             * Shows tooltip for all points with the same X value. Splits the
             * tooltip into one label per series, with the header close to the axis.
             * This is recommended over [shared](#tooltip.shared)
             * tooltips for charts with multiple line series, generally making them
             * easier to read. This option takes precedence over `tooltip.shared`.
             *
             * Not supported for [polar](#chart.polar) and [inverted](#chart.inverted) charts.
             *
             * @productdesc {highstock} In Highcharts Stock, tooltips are split
             * by default since v6.0.0. Stock charts typically contain
             * multi-dimension points and multiple panes, making split tooltips
             * the preferred layout over
             * the previous `shared` tooltip.
             *
             * @sample highcharts/tooltip/split/
             *         Split tooltip
             * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
             *         Split tooltip and custom formatter callback
             *
             * @type      {boolean}
             * @default   {highcharts} false
             * @default   {highstock} true
             * @since     5.0.0
             * @product   highcharts highstock
             * @apioption tooltip.split
             */
            /**
             * Prevents the tooltip from switching or closing, when touched or
             * pointed.
             *
             * @sample highcharts/tooltip/stickoncontact/
             *         Tooltip sticks on pointer contact
             *
             * @type      {boolean}
             * @since     8.0.1
             * @apioption tooltip.stickOnContact
             */
            /**
             * Use HTML to render the contents of the tooltip instead of SVG. Using
             * HTML allows advanced formatting like tables and images in the
             * tooltip. It is also recommended for rtl languages as it works around
             * rtl bugs in early Firefox.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
             *         A table for value alignment
             * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
             *         Full HTML tooltip
             * @sample {highmaps} maps/tooltip/usehtml/
             *         Pure HTML tooltip
             *
             * @type      {boolean}
             * @default   false
             * @since     2.2
             * @apioption tooltip.useHTML
             */
            /**
             * How many decimals to show in each series' y value. This is
             * overridable in each series' tooltip options object. The default is to
             * preserve all decimals.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             * @sample {highmaps} maps/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             *
             * @type      {number|undefined}
             * @since     2.2
             * @apioption tooltip.valueDecimals
             */
            /**
             * A string to prepend to each series' y value. Overridable in each
             * series' tooltip options object.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             * @sample {highmaps} maps/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             *
             * @type      {string}
             * @since     2.2
             * @apioption tooltip.valuePrefix
             */
            /**
             * A string to append to each series' y value. Overridable in each
             * series' tooltip options object.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             * @sample {highmaps} maps/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             *
             * @type      {string}
             * @since     2.2
             * @apioption tooltip.valueSuffix
             */
            /**
             * The format for the date in the tooltip header if the X axis is a
             * datetime axis. The default is a best guess based on the smallest
             * distance between points in the chart.
             *
             * @sample {highcharts} highcharts/tooltip/xdateformat/
             *         A different format
             *
             * @type      {string}
             * @product   highcharts highstock gantt
             * @apioption tooltip.xDateFormat
             */
            /**
             * How many decimals to show for the `point.change`
             * or the `point.cumulativeSum` value when the `series.compare`
             * or the `series.cumulative` option is set.
             * This is overridable in each series' tooltip options object.
             *
             * @type      {number}
             * @default   2
             * @since     1.0.1
             * @product   highstock
             * @apioption tooltip.changeDecimals
             */
            /**
             * Enable or disable the tooltip.
             *
             * @sample {highcharts} highcharts/tooltip/enabled/
             *         Disabled
             * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
             *         Disable tooltip and show values on chart instead
             */
            enabled: true,
            /**
             * Enable or disable animation of the tooltip.
             *
             * @type       {boolean|Partial<Highcharts.AnimationOptionsObject>}
             * @since      2.3.0
             */
            animation: {
                duration: 300,
                // EaseOutCirc
                easing: (x) => Math.sqrt(1 - Math.pow(x - 1, 2))
            },
            /**
             * The radius of the rounded border corners.
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         Default border radius
             * @sample {highcharts} highcharts/tooltip/borderradius-0/
             *         Square borders
             * @sample {highmaps} maps/tooltip/background-border/
             *         Background and border demo
             */
            borderRadius: 3,
            /**
             * For series on datetime axes, the date format in the tooltip's
             * header will by default be guessed based on the closest data points.
             * This member gives the default string representations used for
             * each unit. For an overview of the replacement codes, see
             * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
             *
             * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
             *
             * @type    {Highcharts.Dictionary<string>}
             * @product highcharts highstock gantt
             */
            dateTimeLabelFormats: {
                /** @internal */
                millisecond: '%A, %e %b, %H:%M:%S.%L',
                /** @internal */
                second: '%A, %e %b, %H:%M:%S',
                /** @internal */
                minute: '%A, %e %b, %H:%M',
                /** @internal */
                hour: '%A, %e %b, %H:%M',
                /** @internal */
                day: '%A, %e %b %Y',
                /** @internal */
                week: 'Week from %A, %e %b %Y',
                /** @internal */
                month: '%B %Y',
                /** @internal */
                year: '%Y'
            },
            /**
             * A string to append to the tooltip format.
             *
             * @sample {highcharts} highcharts/tooltip/footerformat/
             *         A table for value alignment
             * @sample {highmaps} maps/tooltip/format/
             *         Format demo
             *
             * @since 2.2
             */
            footerFormat: '',
            /**
             * The name of a symbol to use for the border around the tooltip
             * header. Applies only when [tooltip.split](#tooltip.split) is
             * enabled.
             *
             * Custom callbacks for symbol path generation can also be added to
             * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
             * [series.marker.symbol](plotOptions.line.marker.symbol).
             *
             * @see [tooltip.shape](#tooltip.shape)
             *
             * @sample {highstock} stock/tooltip/split-positioner/
             *         Different shapes for header and split boxes
             *
             * @type       {Highcharts.TooltipShapeValue}
             * @validvalue ["callout", "rect"]
             * @since      7.0
             */
            headerShape: 'callout',
            /**
             * The number of milliseconds to wait until the tooltip is hidden when
             * mouse out from a point or chart.
             *
             * @since 3.0
             */
            hideDelay: 500,
            /**
             * Padding inside the tooltip, in pixels.
             *
             * @since 5.0.0
             */
            padding: 8,
            /**
             * The name of a symbol to use for the border around the tooltip. Can
             * be one of: `"callout"`, `"circle"` or `"rect"`. When
             * [tooltip.split](#tooltip.split)
             * option is enabled, shape is applied to all boxes except header, which
             * is controlled by
             * [tooltip.headerShape](#tooltip.headerShape).
             *
             * Custom callbacks for symbol path generation can also be added to
             * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
             * [series.marker.symbol](plotOptions.line.marker.symbol).
             *
             * @type  {Highcharts.TooltipShapeValue}
             * @since 4.0
             */
            shape: 'callout',
            /**
             * Shows information in the tooltip for all points with the same X
             * value. When the tooltip is shared, the entire plot area will capture
             * mouse movement or touch events. Tooltip texts for series types with
             * ordered data (not pie, scatter, flags etc) will be shown in a single
             * bubble. This is recommended for single series charts and for
             * tablet/mobile optimized charts.
             *
             * See also [tooltip.split](#tooltip.split), that is better suited for
             * charts with many series, especially line-type series. The
             * `tooltip.split` option takes precedence over `tooltip.shared`.
             *
             * @sample {highcharts} highcharts/tooltip/shared-false/
             *         False by default
             * @sample {highcharts} highcharts/tooltip/shared-true/
             *         True
             * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
             *         True with x axis crosshair
             * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
             *         True with mixed series types
             *
             * @since   2.1
             * @product highcharts highstock
             */
            shared: false,
            /**
             * Proximity snap for graphs or single points. It defaults to 10 for
             * mouse-powered devices and 25 for touch devices.
             *
             * Note that in most cases the whole plot area captures the mouse
             * movement, and in these cases `tooltip.snap` doesn't make sense. This
             * applies when [stickyTracking](#plotOptions.series.stickyTracking)
             * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
             * or [split](#tooltip.split).
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         10 px by default
             * @sample {highcharts} highcharts/tooltip/snap-50/
             *         50 px on graph
             *
             * @type    {number}
             * @default 10/25
             * @since   1.2.0
             * @product highcharts highstock
             */
            snap: isTouchDevice ? 25 : 10,
            /**
             * The HTML of the tooltip header line. Variables are enclosed by
             * curly brackets. Available variables are `point.key`, `series.name`,
             * `series.color` and other members from the `point` and `series`
             * objects. The `point.key` variable contains the category name, x
             * value or datetime string depending on the type of axis. For datetime
             * axes, the `point.key` date format can be set using
             * `tooltip.xDateFormat`.
             *
             * @sample {highcharts} highcharts/tooltip/footerformat/
             *         An HTML table in the tooltip
             * @sample {highstock} highcharts/tooltip/footerformat/
             *         An HTML table in the tooltip
             * @sample {highmaps} maps/tooltip/format/
             *         Format demo
             *
             * @type      {string}
             * @apioption tooltip.headerFormat
             */
            headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
            /**
             * The HTML of the null point's line in the tooltip. Works analogously
             * to [pointFormat](#tooltip.pointFormat).
             *
             * @sample {highcharts} highcharts/plotoptions/series-nullformat
             *         Format data label and tooltip for null point.
             *
             * @type      {string}
             * @apioption tooltip.nullFormat
             */
            /**
             * The HTML of the point's line in the tooltip. Variables are enclosed
             * by curly brackets. Available variables are `point.x`, `point.y`,
             * `series.name` and `series.color` and other properties on the same
             * form. Furthermore, `point.y` can be extended by the
             * `tooltip.valuePrefix` and `tooltip.valueSuffix` variables. This can
             * also be overridden for each series, which makes it a good hook for
             * displaying units.
             *
             * In styled mode, the dot is colored by a class name rather
             * than the point color.
             *
             * @sample {highcharts} highcharts/tooltip/pointformat/
             *         A different point format with value suffix
             * @sample {highcharts|highstock} highcharts/tooltip/pointformat-extra-information/
             *         Show extra information about points in the tooltip
             * @sample {highmaps} maps/tooltip/format/
             *         Format demo
             *
             * @type       {string}
             * @since      2.2
             * @apioption  tooltip.pointFormat
             */
            pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
            /**
             * The background color or gradient for the tooltip.
             *
             * In styled mode, the stroke width is set in the
             * `.highcharts-tooltip-box` class.
             *
             * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/
             *         Yellowish background
             * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/
             *         Gradient
             * @sample {highcharts} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             * @sample {highstock} stock/tooltip/general/
             *         Custom tooltip
             * @sample {highstock} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             * @sample {highmaps} maps/tooltip/background-border/
             *         Background and border demo
             * @sample {highmaps} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            backgroundColor: "#ffffff" /* Palette.backgroundColor */,
            /**
             * The pixel width of the tooltip border. Defaults to 0 for single
             * tooltips and 1 for split tooltips.
             *
             * In styled mode, the stroke width is set in the
             * `.highcharts-tooltip-box` class.
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         2 pixels
             * @sample {highcharts} highcharts/tooltip/borderwidth/
             *         No border (shadow only)
             * @sample {highcharts} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             * @sample {highstock} stock/tooltip/general/
             *         Custom tooltip
             * @sample {highstock} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             * @sample {highmaps} maps/tooltip/background-border/
             *         Background and border demo
             * @sample {highmaps} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             *
             * @type {number}
             */
            borderWidth: void 0,
            /**
             * Whether to apply a drop shadow to the tooltip.
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         True by default
             * @sample {highcharts} highcharts/tooltip/shadow/
             *         False
             * @sample {highmaps} maps/tooltip/positioner/
             *         Fixed tooltip position, border and shadow disabled
             *
             * @type {boolean|Highcharts.ShadowOptionsObject}
             */
            shadow: true,
            /**
             * Prevents the tooltip from switching or closing when touched or
             * pointed.
             *
             * @sample highcharts/tooltip/stickoncontact/
             *         Tooltip sticks on pointer contact
             *
             * @since 8.0.1
             */
            stickOnContact: false,
            /**
             * CSS styles for the tooltip. The tooltip can also be styled through
             * the CSS class `.highcharts-tooltip`.
             *
             * Note that the default `pointerEvents` style makes the tooltip ignore
             * mouse events, so in order to use clickable tooltips, this value must
             * be set to `auto`.
             *
             * @sample {highcharts} highcharts/tooltip/style/
             *         Greater padding, bold text
             *
             * @type {Highcharts.CSSObject}
             */
            style: {
                /** @internal */
                color: "#333333" /* Palette.neutralColor80 */,
                /** @internal */
                cursor: 'default',
                /** @internal */
                fontSize: '0.8em'
            },
            /**
             * Use HTML to render the contents of the tooltip instead of SVG. Using
             * HTML allows advanced formatting like tables and images in the
             * tooltip. It is also recommended for rtl languages as it works around
             * rtl bugs in early Firefox.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
             *         A table for value alignment
             * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
             *         Full HTML tooltip
             * @sample {highmaps} maps/tooltip/usehtml/
             *         Pure HTML tooltip
             *
             * @since 2.2
             */
            useHTML: false
        },
        /**
         * Highchart by default puts a credits label in the lower right corner
         * of the chart. This can be changed using these options.
         */
        credits: {
            /**
             * Credits for map source to be concatenated with conventional credit
             * text. By default this is a format string that collects copyright
             * information from the map if available.
             *
             * @see [mapTextFull](#credits.mapTextFull)
             * @see [text](#credits.text)
             *
             * @type      {string}
             * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
             * @since     4.2.2
             * @product   highmaps
             * @apioption credits.mapText
             */
            /**
             * Detailed credits for map source to be displayed on hover of credits
             * text. By default this is a format string that collects copyright
             * information from the map if available.
             *
             * @see [mapText](#credits.mapText)
             * @see [text](#credits.text)
             *
             * @type      {string}
             * @default   {geojson.copyright}
             * @since     4.2.2
             * @product   highmaps
             * @apioption credits.mapTextFull
             */
            /**
             * Whether to show the credits text.
             *
             * @sample {highcharts} highcharts/credits/enabled-false/
             *         Credits disabled
             * @sample {highstock} stock/credits/enabled/
             *         Credits disabled
             * @sample {highmaps} maps/credits/enabled-false/
             *         Credits disabled
             */
            enabled: true,
            /**
             * The URL for the credits label.
             *
             * @sample {highcharts} highcharts/credits/href/
             *         Custom URL and text
             * @sample {highmaps} maps/credits/customized/
             *         Custom URL and text
             */
            href: 'https://www.highcharts.com?credits',
            /**
             * Position configuration for the credits label.
             *
             * @sample {highcharts} highcharts/credits/position-left/
             *         Left aligned
             * @sample {highcharts} highcharts/credits/position-left/
             *         Left aligned
             * @sample {highmaps} maps/credits/customized/
             *         Left aligned
             * @sample {highmaps} maps/credits/customized/
             *         Left aligned
             *
             * @type    {Highcharts.AlignObject}
             * @since   2.1
             */
            position: {
                /** @internal */
                align: 'right',
                /** @internal */
                x: -10,
                /** @internal */
                verticalAlign: 'bottom',
                /** @internal */
                y: -5
            },
            /**
             * CSS styles for the credits label.
             *
             * @see In styled mode, credits styles can be set with the
             *      `.highcharts-credits` class.
             *
             * @type {Highcharts.CSSObject}
             */
            style: {
                /** @internal */
                cursor: 'pointer',
                /** @internal */
                color: "#999999" /* Palette.neutralColor40 */,
                /** @internal */
                fontSize: '0.6em'
            },
            /**
             * The text for the credits label.
             *
             * @productdesc {highmaps}
             * If a map is loaded as GeoJSON, the text defaults to
             * `Highcharts @ {map-credits}`. Otherwise, it defaults to
             * `Highcharts.com`.
             *
             * @sample {highcharts} highcharts/credits/href/
             *         Custom URL and text
             * @sample {highmaps} maps/credits/customized/
             *         Custom URL and text
             */
            text: 'Highcharts.com'
        }
    };
    /* eslint-disable spaced-comment */
    /*= if (!build.classic) { =*/
    // Legacy build for styled mode, set the styledMode option to true by default.
    defaultOptions$7.chart.styledMode = true;
    /*= } else { =*/
    defaultOptions$7.chart.styledMode = false;
    const defaultTime$2 = new Time(defaultOptions$7.time);
    /**
     * Get the updated default options. Until 3.0.7, merely exposing defaultOptions
     * for outside modules wasn't enough because the setOptions method created a new
     * object.
     *
     * @function Highcharts.getOptions
     *
     * @return {Highcharts.Options}
     * Default options.
     */
    function getOptions() {
        return defaultOptions$7;
    }
    /**
     * Merge the default options with custom options and return the new options
     * structure. Commonly used for defining reusable templates.
     *
     * @sample highcharts/global/useutc-false Setting a global option
     * @sample highcharts/members/setoptions Applying a global theme
     *
     * @function Highcharts.setOptions
     *
     * @param {Highcharts.Options} options
     * The new custom chart options.
     *
     * @return {Highcharts.Options}
     * Updated options.
     */
    function setOptions(options) {
        fireEvent$8(H, 'setOptions', { options });
        // Copy in the default options
        merge$b(true, defaultOptions$7, options);
        // Update the time object
        if (options.time || options.global) {
            if (H.time) {
                H.time.update(merge$b(defaultOptions$7.global, defaultOptions$7.time, options.global, options.time));
            }
            else {
                /**
                 * Global `Time` object with default options. Since v6.0.5, time
                 * settings can be applied individually for each chart. If no
                 * individual settings apply, this `Time` object is shared by all
                 * instances.
                 *
                 * @name Highcharts.time
                 * @type {Highcharts.Time}
                 */
                H.time = defaultTime$2;
            }
        }
        return defaultOptions$7;
    }
    /* *
     *
     *  Default Export
     *
     * */
    const DefaultOptions = {
        defaultOptions: defaultOptions$7,
        defaultTime: defaultTime$2,
        getOptions,
        setOptions
    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { addEvent: addEvent$4, isFunction: isFunction$3, objectEach: objectEach$8, removeEvent: removeEvent$5 } = Utilities;
    /* *
     *
     *  Class Namespace
     *
     * */
    var Foundation;
    (function (Foundation) {
        /* *
         *
         *  Functions
         *
         * */
        /* eslint-disable valid-jsdoc */
        /**
         * Register event options. If an event handler is set on the options, it
         * should be subject to Chart.update, Axis.update and Series.update. This is
         * contrary to general handlers that are set directly using addEvent either
         * on the class or on the instance. #6538, #6943, #10861.
         * @private
         */
        function registerEventOptions(component, options) {
            // A lookup over those events that are added by _options_ (not
            // programmatically). These are updated through .update()
            component.eventOptions = component.eventOptions || {};
            // Register event listeners
            objectEach$8(options.events, function (event, eventType) {
                // If event does not exist, or is changed by the .update()
                // function
                if (component.eventOptions[eventType] !== event) {
                    // Remove existing if set by option
                    if (component.eventOptions[eventType]) {
                        removeEvent$5(component, eventType, component.eventOptions[eventType]);
                        delete component.eventOptions[eventType];
                    }
                    if (isFunction$3(event)) {
                        component.eventOptions[eventType] = event;
                        addEvent$4(component, eventType, event, {
                            order: 0 // #14080 fire those events as firsts
                        });
                    }
                }
            });
        }
        Foundation.registerEventOptions = registerEventOptions;
    })(Foundation || (Foundation = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var Foundation$1 = Foundation;

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defaultOptions: defaultOptions$6, defaultTime: defaultTime$1 } = DefaultOptions;
    const { extend: extend$c, getNestedProperty: getNestedProperty$2, isArray: isArray$7, isNumber: isNumber$9, isObject: isObject$4, pick: pick$c, pInt: pInt$3 } = Utilities;
    const helpers = {
        // Built-in helpers
        add: (a, b) => a + b,
        divide: (a, b) => (b !== 0 ? a / b : ''),
        // eslint-disable-next-line eqeqeq
        eq: (a, b) => a == b,
        each: function (arr) {
            const match = arguments[arguments.length - 1];
            return isArray$7(arr) ?
                arr.map((item, i) => format$1(match.body, extend$c(isObject$4(item) ? item : { '@this': item }, {
                    '@index': i,
                    '@first': i === 0,
                    '@last': i === arr.length - 1
                }))).join('') :
                false;
        },
        ge: (a, b) => a >= b,
        gt: (a, b) => a > b,
        'if': (condition) => !!condition,
        le: (a, b) => a <= b,
        lt: (a, b) => a < b,
        multiply: (a, b) => a * b,
        // eslint-disable-next-line eqeqeq
        ne: (a, b) => a != b,
        subtract: (a, b) => a - b,
        unless: (condition) => !condition
    };
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a
     * human readable date string. The format is a subset of the formats for PHP's
     * [strftime](https://www.php.net/manual/en/function.strftime.php) function.
     * Additional formats can be given in the {@link Highcharts.dateFormats} hook.
     *
     * Since v6.0.5, all internal dates are formatted through the
     * {@link Highcharts.Chart#time} instance to respect chart-level time settings.
     * The `Highcharts.dateFormat` function only reflects global time settings set
     * with `setOptions`.
     *
     * Supported format keys:
     * - `%a`: Short weekday, like 'Mon'
     * - `%A`: Long weekday, like 'Monday'
     * - `%d`: Two digit day of the month, 01 to 31
     * - `%e`: Day of the month, 1 through 31
     * - `%w`: Day of the week, 0 through 6
     * - `%b`: Short month, like 'Jan'
     * - `%B`: Long month, like 'January'
     * - `%m`: Two digit month number, 01 through 12
     * - `%y`: Two digits year, like 09 for 2009
     * - `%Y`: Four digits year, like 2009
     * - `%H`: Two digits hours in 24h format, 00 through 23
     * - `%k`: Hours in 24h format, 0 through 23
     * - `%I`: Two digits hours in 12h format, 00 through 11
     * - `%l`: Hours in 12h format, 1 through 12
     * - `%M`: Two digits minutes, 00 through 59
     * - `%p`: Upper case AM or PM
     * - `%P`: Lower case AM or PM
     * - `%S`: Two digits seconds, 00 through 59
     * - `%L`: Milliseconds (naming from Ruby)
     *
     * @function Highcharts.dateFormat
     *
     * @param {string} format
     *        The desired format where various time representations are prefixed
     *        with `%`.
     *
     * @param {number} timestamp
     *        The JavaScript timestamp.
     *
     * @param {boolean} [capitalize=false]
     *        Upper case first letter in the return.
     *
     * @return {string}
     *         The formatted date.
     */
    function dateFormat(format, timestamp, capitalize) {
        return defaultTime$1.dateFormat(format, timestamp, capitalize);
    }
    /**
     * Format a string according to a subset of the rules of Python's String.format
     * method.
     *
     * @example
     * let s = Highcharts.format(
     *     'The {color} fox was {len:.2f} feet long',
     *     { color: 'red', len: Math.PI }
     * );
     * // => The red fox was 3.14 feet long
     *
     * @function Highcharts.format
     *
     * @param {string} str
     *        The string to format.
     *
     * @param {Record<string, *>} ctx
     *        The context, a collection of key-value pairs where each key is
     *        replaced by its value.
     *
     * @param {Highcharts.Chart} [chart]
     *        A `Chart` instance used to get numberFormatter and time.
     *
     * @return {string}
     *         The formatted string.
     */
    function format$1(str = '', ctx, chart) {
        const regex = /\{([\w\:\.\,;\-\/<>%@"'’= #\(\)]+)\}/g, 
        // The sub expression regex is the same as the top expression regex,
        // but except parens and block helpers (#), and surrounded by parens
        // instead of curly brackets.
        subRegex = /\(([\w\:\.\,;\-\/<>%@"'= ]+)\)/g, matches = [], floatRegex = /f$/, decRegex = /\.(\d)/, lang = defaultOptions$6.lang, time = chart && chart.time || defaultTime$1, numberFormatter = chart && chart.numberFormatter || numberFormat$1;
        /*
         * Get a literal or variable value inside a template expression. May be
         * extended with other types like string or null if needed, but keep it
         * small for now.
         */
        const resolveProperty = (key = '') => {
            let n;
            // Literals
            if (key === 'true') {
                return true;
            }
            if (key === 'false') {
                return false;
            }
            if ((n = Number(key)).toString() === key) {
                return n;
            }
            // Variables and constants
            return getNestedProperty$2(key, ctx);
        };
        let match, currentMatch, depth = 0, hasSub;
        // Parse and create tree
        while ((match = regex.exec(str)) !== null) {
            // When a sub expression is found, it is evaluated first, and the
            // results recursively evaluated until no subexpression exists.
            const subMatch = subRegex.exec(match[1]);
            if (subMatch) {
                match = subMatch;
                hasSub = true;
            }
            if (!currentMatch || !currentMatch.isBlock) {
                currentMatch = {
                    ctx,
                    expression: match[1],
                    find: match[0],
                    isBlock: match[1].charAt(0) === '#',
                    start: match.index,
                    startInner: match.index + match[0].length,
                    length: match[0].length
                };
            }
            // Identify helpers
            const fn = match[1].split(' ')[0].replace('#', '');
            if (helpers[fn]) {
                // Block helper, only 0 level is handled
                if (currentMatch.isBlock && fn === currentMatch.fn) {
                    depth++;
                }
                if (!currentMatch.fn) {
                    currentMatch.fn = fn;
                }
            }
            // Closing a block helper
            const startingElseSection = match[1] === 'else';
            if (currentMatch.isBlock &&
                currentMatch.fn && (match[1] === `/${currentMatch.fn}` ||
                startingElseSection)) {
                if (!depth) { // === 0
                    const start = currentMatch.startInner, body = str.substr(start, match.index - start);
                    // Either closing without an else section, or when encountering
                    // an else section
                    if (currentMatch.body === void 0) {
                        currentMatch.body = body;
                        currentMatch.startInner = match.index + match[0].length;
                        // The body exists already, so this is the else section
                    }
                    else {
                        currentMatch.elseBody = body;
                    }
                    currentMatch.find += body + match[0];
                    if (!startingElseSection) {
                        matches.push(currentMatch);
                        currentMatch = void 0;
                    }
                }
                else if (!startingElseSection) {
                    depth--;
                }
                // Common expression
            }
            else if (!currentMatch.isBlock) {
                matches.push(currentMatch);
            }
            // Evaluate sub-matches one by one to prevent orphaned block closers
            if (subMatch && !currentMatch?.isBlock) {
                break;
            }
        }
        // Execute
        matches.forEach((match) => {
            const { body, elseBody, expression, fn } = match;
            let replacement, i;
            // Helper function
            if (fn) {
                // Pass the helpers the amount of arguments defined by the function,
                // then the match as the last argument.
                const args = [match], parts = expression.split(' ');
                i = helpers[fn].length;
                while (i--) {
                    args.unshift(resolveProperty(parts[i + 1]));
                }
                replacement = helpers[fn].apply(ctx, args);
                // Block helpers may return true or false. They may also return a
                // string, like the `each` helper.
                if (match.isBlock && typeof replacement === 'boolean') {
                    replacement = format$1(replacement ? body : elseBody, ctx, chart);
                }
                // Simple variable replacement
            }
            else {
                const valueAndFormat = expression.split(':');
                replacement = resolveProperty(valueAndFormat.shift() || '');
                // Format the replacement
                if (valueAndFormat.length && typeof replacement === 'number') {
                    const segment = valueAndFormat.join(':');
                    if (floatRegex.test(segment)) { // Float
                        const decimals = parseInt((segment.match(decRegex) || ['', '-1'])[1], 10);
                        if (replacement !== null) {
                            replacement = numberFormatter(replacement, decimals, lang.decimalPoint, segment.indexOf(',') > -1 ? lang.thousandsSep : '');
                        }
                    }
                    else {
                        replacement = time.dateFormat(segment, replacement);
                    }
                }
            }
            str = str.replace(match.find, pick$c(replacement, ''));
        });
        return hasSub ? format$1(str, ctx, chart) : str;
    }
    /**
     * Format a number and return a string based on input settings.
     *
     * @sample highcharts/members/highcharts-numberformat/
     *         Custom number format
     *
     * @function Highcharts.numberFormat
     *
     * @param {number} number
     *        The input number to format.
     *
     * @param {number} decimals
     *        The amount of decimals. A value of -1 preserves the amount in the
     *        input number.
     *
     * @param {string} [decimalPoint]
     *        The decimal point, defaults to the one given in the lang options, or
     *        a dot.
     *
     * @param {string} [thousandsSep]
     *        The thousands separator, defaults to the one given in the lang
     *        options, or a space character.
     *
     * @return {string}
     *         The formatted number.
     */
    function numberFormat$1(number, decimals, decimalPoint, thousandsSep) {
        number = +number || 0;
        decimals = +decimals;
        let ret, fractionDigits;
        const lang = defaultOptions$6.lang, origDec = (number.toString().split('.')[1] || '').split('e')[0].length, exponent = number.toString().split('e'), firstDecimals = decimals;
        if (decimals === -1) {
            // Preserve decimals. Not huge numbers (#3793).
            decimals = Math.min(origDec, 20);
        }
        else if (!isNumber$9(decimals)) {
            decimals = 2;
        }
        else if (decimals && exponent[1] && exponent[1] < 0) {
            // Expose decimals from exponential notation (#7042)
            fractionDigits = decimals + +exponent[1];
            if (fractionDigits >= 0) {
                // Remove too small part of the number while keeping the notation
                exponent[0] = (+exponent[0]).toExponential(fractionDigits)
                    .split('e')[0];
                decimals = fractionDigits;
            }
            else {
                // `fractionDigits < 0`
                exponent[0] = exponent[0].split('.')[0] || 0;
                if (decimals < 20) {
                    // Use number instead of exponential notation (#7405)
                    number = (exponent[0] * Math.pow(10, exponent[1]))
                        .toFixed(decimals);
                }
                else {
                    // Or zero
                    number = 0;
                }
                exponent[1] = 0;
            }
        }
        // Add another decimal to avoid rounding errors of float numbers. (#4573)
        // Then use toFixed to handle rounding.
        const roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) +
            Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);
        // A string containing the positive integer component of the number
        const strinteger = String(pInt$3(roundedNumber));
        // Leftover after grouping into thousands. Can be 0, 1 or 2.
        const thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
        // Language
        decimalPoint = pick$c(decimalPoint, lang.decimalPoint);
        thousandsSep = pick$c(thousandsSep, lang.thousandsSep);
        // Start building the return
        ret = number < 0 ? '-' : '';
        // Add the leftover after grouping into thousands. For example, in the
        // number 42 000 000, this line adds 42.
        ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';
        if (+exponent[1] < 0 && !firstDecimals) {
            ret = '0';
        }
        else {
            // Add the remaining thousands groups, joined by the thousands separator
            ret += strinteger
                .substr(thousands)
                .replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);
        }
        // Add the decimal point and the decimal component
        if (decimals) {
            // Get the decimal component
            ret += decimalPoint + roundedNumber.slice(-decimals);
        }
        else if (+ret === 0) { // Remove signed minus #20564
            ret = '0';
        }
        if (exponent[1] && +ret !== 0) {
            ret += 'e' + exponent[1];
        }
        return ret;
    }
    /* *
     *
     *  Default Export
     *
     * */
    const Templating = {
        dateFormat,
        format: format$1,
        helpers,
        numberFormat: numberFormat$1
    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { deg2rad: deg2rad$3 } = H;
    const { clamp: clamp$3, correctFloat: correctFloat$2, defined: defined$8, destroyObjectProperties: destroyObjectProperties$3, extend: extend$b, fireEvent: fireEvent$7, isNumber: isNumber$8, merge: merge$a, objectEach: objectEach$7, pick: pick$b } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * The Tick class.
     *
     * @class
     * @name Highcharts.Tick
     *
     * @param {Highcharts.Axis} axis
     * The axis of the tick.
     *
     * @param {number} pos
     * The position of the tick on the axis in terms of axis values.
     *
     * @param {string} [type]
     * The type of tick, either 'minor' or an empty string
     *
     * @param {boolean} [noLabel=false]
     * Whether to disable the label or not. Defaults to false.
     *
     * @param {Object} [parameters]
     * Optional parameters for the tick.
     */
    class Tick {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(axis, pos, type, noLabel, parameters) {
            this.isNew = true;
            this.isNewLabel = true;
            /**
             * The related axis of the tick.
             * @name Highcharts.Tick#axis
             * @type {Highcharts.Axis}
             */
            this.axis = axis;
            /**
             * The logical position of the tick on the axis in terms of axis values.
             * @name Highcharts.Tick#pos
             * @type {number}
             */
            this.pos = pos;
            /**
             * The tick type, which can be `"minor"`, or an empty string.
             * @name Highcharts.Tick#type
             * @type {string}
             */
            this.type = type || '';
            this.parameters = parameters || {};
            /**
             * The mark offset of the tick on the axis. Usually `undefined`, numeric
             * for grid axes.
             * @name Highcharts.Tick#tickmarkOffset
             * @type {number|undefined}
             */
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            fireEvent$7(this, 'init');
            if (!type && !noLabel) {
                this.addLabel();
            }
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Write the tick label.
         *
         * @private
         * @function Highcharts.Tick#addLabel
         */
        addLabel() {
            const tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick$b(tick.options && tick.options.labels, options.labels), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) &&
                axis.tickInterval === 1, tickPositionInfo = tickPositions.info;
            let label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
            // The context value
            let value = this.parameters.category || (categories ?
                pick$b(categories[pos], names[pos], pos) :
                pos);
            if (log && isNumber$8(value)) {
                value = correctFloat$2(log.lin2log(value));
            }
            // Set the datetime label format. If a higher rank is set for this
            // position, use that. If not, use the general format.
            if (axis.dateTime) {
                if (tickPositionInfo) {
                    dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[(!options.grid &&
                        tickPositionInfo.higherRanks[pos]) ||
                        tickPositionInfo.unitName]);
                    dateTimeLabelFormat = dateTimeLabelFormats.main;
                }
                else if (isNumber$8(value)) { // #1441
                    dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats ||
                        {});
                }
            }
            // Set properties for access in render method
            /**
             * True if the tick is the first one on the axis.
             * @name Highcharts.Tick#isFirst
             * @readonly
             * @type {boolean|undefined}
             */
            tick.isFirst = isFirst;
            /**
             * True if the tick is the last one on the axis.
             * @name Highcharts.Tick#isLast
             * @readonly
             * @type {boolean|undefined}
             */
            tick.isLast = isLast;
            // Get the string
            const ctx = {
                axis,
                chart,
                dateTimeLabelFormat: dateTimeLabelFormat,
                isFirst,
                isLast,
                pos,
                tick: tick,
                tickPositionInfo,
                value
            };
            // Fire an event that allows modifying the context for use in
            // `labels.format` and `labels.formatter`.
            fireEvent$7(this, 'labelFormat', ctx);
            // Label formatting. When `labels.format` is given, we first run the
            // defaultFormatter and append the result to the context as `text`.
            // Handy for adding prefix or suffix while keeping default number
            // formatting.
            const labelFormatter = (ctx) => {
                if (labelOptions.formatter) {
                    return labelOptions.formatter.call(ctx, ctx);
                }
                if (labelOptions.format) {
                    ctx.text = axis.defaultLabelFormatter.call(ctx);
                    return Templating.format(labelOptions.format, ctx, chart);
                }
                return axis.defaultLabelFormatter.call(ctx);
            };
            const str = labelFormatter.call(ctx, ctx);
            // Set up conditional formatting based on the format list if existing.
            const list = dateTimeLabelFormats && dateTimeLabelFormats.list;
            if (list) {
                tick.shortenLabel = function () {
                    for (i = 0; i < list.length; i++) {
                        extend$b(ctx, { dateTimeLabelFormat: list[i] });
                        label.attr({
                            text: labelFormatter.call(ctx, ctx)
                        });
                        if (label.getBBox().width <
                            axis.getSlotWidth(tick) - 2 *
                                (labelOptions.padding || 0)) {
                            return;
                        }
                    }
                    label.attr({
                        text: ''
                    });
                };
            }
            else {
                // #15692
                tick.shortenLabel = void 0;
            }
            // Call only after first render
            if (animateLabels && axis._addedPlotLB) {
                tick.moveLabel(str, labelOptions);
            }
            // First call
            if (!defined$8(label) && !tick.movedLabel) {
                /**
                 * The rendered text label of the tick.
                 * @name Highcharts.Tick#label
                 * @type {Highcharts.SVGElement|undefined}
                 */
                tick.label = label = tick.createLabel(str, labelOptions);
                // Base value to detect change for new calls to getBBox
                tick.rotation = 0;
                // Update
            }
            else if (label && label.textStr !== str && !animateLabels) {
                // When resetting text, also reset the width if dynamically set
                // (#8809)
                if (label.textWidth &&
                    !labelOptions.style.width &&
                    !label.styles.width) {
                    label.css({ width: null });
                }
                label.attr({ text: str });
                label.textPxLength = label.getBBox().width;
            }
        }
        /**
         * Render and return the label of the tick.
         *
         * @private
         * @function Highcharts.Tick#createLabel
         */
        createLabel(str, labelOptions, xy) {
            const axis = this.axis, chart = axis.chart, label = defined$8(str) && labelOptions.enabled ?
                chart.renderer
                    .text(str, xy?.x, xy?.y, labelOptions.useHTML)
                    .add(axis.labelGroup) :
                void 0;
            // Un-rotated length
            if (label) {
                // Without position absolute, IE export sometimes is wrong
                if (!chart.styledMode) {
                    label.css(merge$a(labelOptions.style));
                }
                label.textPxLength = label.getBBox().width;
            }
            return label;
        }
        /**
         * Destructor for the tick prototype
         *
         * @private
         * @function Highcharts.Tick#destroy
         */
        destroy() {
            destroyObjectProperties$3(this, this.axis);
        }
        /**
         * Gets the x and y positions for ticks in terms of pixels.
         *
         * @private
         * @function Highcharts.Tick#getPosition
         *
         * @param {boolean} horiz
         * Whether the tick is on an horizontal axis or not.
         *
         * @param {number} tickPos
         * Position of the tick.
         *
         * @param {number} tickmarkOffset
         * Tickmark offset for all ticks.
         *
         * @param {boolean} [old]
         * Whether the axis has changed or not.
         *
         * @return {Highcharts.PositionObject}
         * The tick position.
         *
         * @emits Highcharts.Tick#event:afterGetPosition
         */
        getPosition(horiz, tickPos, tickmarkOffset, old) {
            const axis = this.axis, chart = axis.chart, cHeight = (old && chart.oldChartHeight) || chart.chartHeight, pos = {
                x: horiz ?
                    correctFloat$2(axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) +
                        axis.transB) :
                    (axis.left +
                        axis.offset +
                        (axis.opposite ?
                            (((old && chart.oldChartWidth) ||
                                chart.chartWidth) -
                                axis.right -
                                axis.left) :
                            0)),
                y: horiz ?
                    (cHeight -
                        axis.bottom +
                        axis.offset -
                        (axis.opposite ? axis.height : 0)) :
                    correctFloat$2(cHeight -
                        axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) -
                        axis.transB)
            };
            // Chrome workaround for #10516
            pos.y = clamp$3(pos.y, -1e9, 1e9);
            fireEvent$7(this, 'afterGetPosition', { pos: pos });
            return pos;
        }
        /**
         * Get the x, y position of the tick label
         * @private
         */
        getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
            const axis = this.axis, transA = axis.transA, reversed = ( // #7911
            axis.isLinked && axis.linkedParent ?
                axis.linkedParent.reversed :
                axis.reversed), staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || { x: 0, y: 0 }, 
            // Adjust for label alignment if we use reserveSpace: true (#5286)
            labelOffsetCorrection = (!horiz && !axis.reserveSpaceDefault ?
                -axis.labelOffset * (axis.labelAlign === 'center' ? 0.5 : 1) :
                0), distance = labelOptions.distance, pos = {};
            let yOffset, line;
            if (axis.side === 0) {
                yOffset = label.rotation ? -distance : -label.getBBox().height;
            }
            else if (axis.side === 2) {
                yOffset = rotCorr.y + distance;
            }
            else {
                // #3140, #3140
                yOffset = Math.cos(label.rotation * deg2rad$3) *
                    (rotCorr.y - label.getBBox(false, 0).height / 2);
            }
            if (defined$8(labelOptions.y)) {
                yOffset = axis.side === 0 && axis.horiz ?
                    labelOptions.y + yOffset :
                    labelOptions.y;
            }
            x = x +
                pick$b(labelOptions.x, [0, 1, 0, -1][axis.side] * distance) +
                labelOffsetCorrection +
                rotCorr.x -
                (tickmarkOffset && horiz ?
                    tickmarkOffset * transA * (reversed ? -1 : 1) :
                    0);
            y = y + yOffset - (tickmarkOffset && !horiz ?
                tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
            // Correct for staggered labels
            if (staggerLines) {
                line = (index / (step || 1) % staggerLines);
                if (axis.opposite) {
                    line = staggerLines - line - 1;
                }
                y += line * (axis.labelOffset / staggerLines);
            }
            pos.x = x;
            pos.y = Math.round(y);
            fireEvent$7(this, 'afterGetLabelPosition', { pos: pos, tickmarkOffset: tickmarkOffset, index: index });
            return pos;
        }
        /**
         * Get the offset height or width of the label
         *
         * @private
         * @function Highcharts.Tick#getLabelSize
         */
        getLabelSize() {
            return this.label ?
                this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
                0;
        }
        /**
         * Extendible method to return the path of the marker
         * @private
         */
        getMarkPath(x, y, tickLength, tickWidth, horiz = false, renderer) {
            return renderer.crispLine([[
                    'M',
                    x,
                    y
                ], [
                    'L',
                    x + (horiz ? 0 : -tickLength),
                    y + (horiz ? tickLength : 0)
                ]], tickWidth);
        }
        /**
         * Handle the label overflow by adjusting the labels to the left and right
         * edge, or hide them if they collide into the neighbour label.
         *
         * @private
         * @function Highcharts.Tick#handleOverflow
         */
        handleOverflow(xy) {
            const tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick$b(axis.labelLeft, Math.min(axis.pos, spacing[3])), rightBound = pick$b(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])), label = this.label, rotation = this.rotation, factor = {
                left: 0,
                center: 0.5,
                right: 1
            }[axis.labelAlign || label.attr('align')], labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css = {};
            let modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
            // Check if the label overshoots the chart spacing box. If it does, move
            // it. If it now overshoots the slotWidth, add ellipsis.
            if (!rotation && labelOptions.overflow === 'justify') {
                leftPos = pxPos - factor * labelWidth;
                rightPos = pxPos + (1 - factor) * labelWidth;
                if (leftPos < leftBound) {
                    modifiedSlotWidth =
                        xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
                }
                else if (rightPos > rightBound) {
                    modifiedSlotWidth =
                        rightBound - xy.x + modifiedSlotWidth * factor;
                    goRight = -1;
                }
                modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177
                if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
                    xy.x += (goRight *
                        (slotWidth -
                            modifiedSlotWidth -
                            xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth))));
                }
                // If the label width exceeds the available space, set a text width
                // to be picked up below. Also, if a width has been set before, we
                // need to set a new one because the reported labelWidth will be
                // limited by the box (#3938).
                if (labelWidth > modifiedSlotWidth ||
                    (axis.autoRotation && (label.styles || {}).width)) {
                    textWidth = modifiedSlotWidth;
                }
                // Add ellipsis to prevent rotated labels to be clipped against the edge
                // of the chart
            }
            else if (rotation < 0 &&
                pxPos - factor * labelWidth < leftBound) {
                textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad$3) - leftBound);
            }
            else if (rotation > 0 &&
                pxPos + factor * labelWidth > rightBound) {
                textWidth = Math.round((chartWidth - pxPos) /
                    Math.cos(rotation * deg2rad$3));
            }
            if (textWidth) {
                if (tick.shortenLabel) {
                    tick.shortenLabel();
                }
                else {
                    css.width = Math.floor(textWidth) + 'px';
                    if (!(labelOptions.style || {}).textOverflow) {
                        css.textOverflow = 'ellipsis';
                    }
                    label.css(css);
                }
            }
        }
        /**
         * Try to replace the label if the same one already exists.
         *
         * @private
         * @function Highcharts.Tick#moveLabel
         */
        moveLabel(str, labelOptions) {
            const tick = this, label = tick.label, axis = tick.axis;
            let moved = false, labelPos;
            if (label && label.textStr === str) {
                tick.movedLabel = label;
                moved = true;
                delete tick.label;
            }
            else { // Find a label with the same string
                objectEach$7(axis.ticks, function (currentTick) {
                    if (!moved &&
                        !currentTick.isNew &&
                        currentTick !== tick &&
                        currentTick.label &&
                        currentTick.label.textStr === str) {
                        tick.movedLabel = currentTick.label;
                        moved = true;
                        currentTick.labelPos = tick.movedLabel.xy;
                        delete currentTick.label;
                    }
                });
            }
            // Create new label if the actual one is moved
            if (!moved && (tick.labelPos || label)) {
                labelPos = tick.labelPos || label.xy;
                tick.movedLabel = tick.createLabel(str, labelOptions, labelPos);
                if (tick.movedLabel) {
                    tick.movedLabel.attr({ opacity: 0 });
                }
            }
        }
        /**
         * Put everything in place
         *
         * @private
         * @param {number} index
         *
         * @param {boolean} [old]
         * Use old coordinates to prepare an animation into new position
         *
         * @param {number} [opacity]
         */
        render(index, old, opacity) {
            const tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick$b(tick.tickmarkOffset, axis.tickmarkOffset), xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, axisStart = axis.pos, axisEnd = axisStart + axis.len, pxPos = horiz ? x : y;
            // Anything that is not between `axis.pos` and `axis.pos + axis.length`
            // should not be visible (#20166). The `correctFloat` is for reversed
            // axes in Safari.
            if (!axis.chart.polar &&
                tick.isNew &&
                (correctFloat$2(pxPos) < axisStart || pxPos > axisEnd)) {
                opacity = 0;
            }
            const labelOpacity = pick$b(opacity, tick.label && tick.label.newOpacity, // #15528
            1);
            opacity = pick$b(opacity, 1);
            this.isActive = true;
            // Create the grid line
            this.renderGridLine(old, opacity);
            // Create the tick mark
            this.renderMark(xy, opacity);
            // The label is created on init - now move it into place
            this.renderLabel(xy, old, labelOpacity, index);
            tick.isNew = false;
            fireEvent$7(this, 'afterRender');
        }
        /**
         * Renders the gridLine.
         *
         * @private
         * @function Highcharts.Tick#renderGridLine
         * @param {boolean} old  Whether or not the tick is old
         * @param {number} opacity  The opacity of the grid line
         */
        renderGridLine(old, opacity) {
            const tick = this, axis = tick.axis, options = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick$b(tick.tickmarkOffset, axis.tickmarkOffset), renderer = axis.chart.renderer;
            let gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;
            if (tick.type === 'minor') {
                gridLineWidth = options.minorGridLineWidth;
                gridLineColor = options.minorGridLineColor;
                dashStyle = options.minorGridLineDashStyle;
            }
            if (!gridLine) {
                if (!axis.chart.styledMode) {
                    attribs.stroke = gridLineColor;
                    attribs['stroke-width'] = gridLineWidth || 0;
                    attribs.dashstyle = dashStyle;
                }
                if (!type) {
                    attribs.zIndex = 1;
                }
                if (old) {
                    opacity = 0;
                }
                /**
                 * The rendered grid line of the tick.
                 * @name Highcharts.Tick#gridLine
                 * @type {Highcharts.SVGElement|undefined}
                 */
                tick.gridLine = gridLine = renderer.path()
                    .attr(attribs)
                    .addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line')
                    .add(axis.gridGroup);
            }
            if (gridLine) {
                gridLinePath = axis.getPlotLinePath({
                    value: pos + tickmarkOffset,
                    lineWidth: gridLine.strokeWidth(),
                    force: 'pass',
                    old: old,
                    acrossPanes: false // #18025
                });
                // If the parameter 'old' is set, the current call will be followed
                // by another call, therefore do not do any animations this time
                if (gridLinePath) {
                    gridLine[old || tick.isNew ? 'attr' : 'animate']({
                        d: gridLinePath,
                        opacity: opacity
                    });
                }
            }
        }
        /**
         * Renders the tick mark.
         *
         * @private
         * @function Highcharts.Tick#renderMark
         * @param {Highcharts.PositionObject} xy  The position vector of the mark
         * @param {number} opacity  The opacity of the mark
         */
        renderMark(xy, opacity) {
            const tick = this, axis = tick.axis, options = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + 'Tick' : 'tick'), x = xy.x, y = xy.y, tickWidth = pick$b(options[type !== 'minor' ? 'tickWidth' : 'minorTickWidth'], !type && axis.isXAxis ? 1 : 0), // X axis defaults to 1
            tickColor = options[type !== 'minor' ? 'tickColor' : 'minorTickColor'];
            let mark = tick.mark;
            const isNewMark = !mark;
            if (tickSize) {
                // Negate the length
                if (axis.opposite) {
                    tickSize[0] = -tickSize[0];
                }
                // First time, create it
                if (!mark) {
                    /**
                     * The rendered mark of the tick.
                     * @name Highcharts.Tick#mark
                     * @type {Highcharts.SVGElement|undefined}
                     */
                    tick.mark = mark = renderer.path()
                        .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')
                        .add(axis.axisGroup);
                    if (!axis.chart.styledMode) {
                        mark.attr({
                            stroke: tickColor,
                            'stroke-width': tickWidth
                        });
                    }
                }
                mark[isNewMark ? 'attr' : 'animate']({
                    d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth(), axis.horiz, renderer),
                    opacity: opacity
                });
            }
        }
        /**
         * Renders the tick label.
         * Note: The label should already be created in init(), so it should only
         * have to be moved into place.
         *
         * @private
         * @function Highcharts.Tick#renderLabel
         * @param {Highcharts.PositionObject} xy  The position vector of the label
         * @param {boolean} old  Whether or not the tick is old
         * @param {number} opacity  The opacity of the label
         * @param {number} index  The index of the tick
         */
        renderLabel(xy, old, opacity, index) {
            const tick = this, axis = tick.axis, horiz = axis.horiz, options = axis.options, label = tick.label, labelOptions = options.labels, step = labelOptions.step, tickmarkOffset = pick$b(tick.tickmarkOffset, axis.tickmarkOffset), x = xy.x, y = xy.y;
            let show = true;
            if (label && isNumber$8(x)) {
                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
                // Apply show first and show last. If the tick is both first and
                // last, it is a single centered tick, in which case we show the
                // label anyway (#2100).
                if ((tick.isFirst &&
                    !tick.isLast &&
                    !options.showFirstLabel) ||
                    (tick.isLast &&
                        !tick.isFirst &&
                        !options.showLastLabel)) {
                    show = false;
                    // Handle label overflow and show or hide accordingly
                }
                else if (horiz &&
                    !labelOptions.step &&
                    !labelOptions.rotation &&
                    !old &&
                    opacity !== 0) {
                    tick.handleOverflow(xy);
                }
                // Apply step
                if (step && index % step) {
                    // Show those indices dividable by step
                    show = false;
                }
                // Set the new position, and show or hide
                if (show && isNumber$8(xy.y)) {
                    xy.opacity = opacity;
                    label[tick.isNewLabel ? 'attr' : 'animate'](xy).show(true);
                    tick.isNewLabel = false;
                }
                else {
                    label.hide(); // #1338, #15863
                    tick.isNewLabel = true;
                }
            }
        }
        /**
         * Replace labels with the moved ones to perform animation. Additionally
         * destroy unused labels.
         *
         * @private
         * @function Highcharts.Tick#replaceMovedLabel
         */
        replaceMovedLabel() {
            const tick = this, label = tick.label, axis = tick.axis;
            // Animate and destroy
            if (label && !tick.isNew) {
                label.animate({ opacity: 0 }, void 0, label.destroy);
                delete tick.label;
            }
            axis.isDirty = true;
            tick.label = tick.movedLabel;
            delete tick.movedLabel;
        }
    }

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animObject: animObject$5 } = animationExports;
    const { xAxis, yAxis } = AxisDefaults$1;
    const { defaultOptions: defaultOptions$5 } = DefaultOptions;
    const { registerEventOptions: registerEventOptions$2 } = Foundation$1;
    const { deg2rad: deg2rad$2 } = H;
    const { arrayMax: arrayMax$1, arrayMin: arrayMin$1, clamp: clamp$2, correctFloat: correctFloat$1, defined: defined$7, destroyObjectProperties: destroyObjectProperties$2, erase: erase$4, error: error$3, extend: extend$a, fireEvent: fireEvent$6, getClosestDistance: getClosestDistance$1, insertItem: insertItem$1, isArray: isArray$6, isNumber: isNumber$7, isString: isString$6, merge: merge$9, normalizeTickInterval, objectEach: objectEach$6, pick: pick$a, relativeLength: relativeLength$1, removeEvent: removeEvent$4, splat: splat$3, syncTimeout: syncTimeout$4 } = Utilities;
    const getNormalizedTickInterval = (axis, tickInterval) => normalizeTickInterval(tickInterval, void 0, void 0, pick$a(axis.options.allowDecimals, 
    // If the tick interval is greater than 0.5, avoid decimals, as
    // linear axes are often used to render discrete values (#3363). If
    // a tick amount is set, allow decimals by default, as it increases
    // the chances for a good fit.
    tickInterval < 0.5 || axis.tickAmount !== void 0), !!axis.tickAmount);
    extend$a(defaultOptions$5, { xAxis, yAxis: merge$9(xAxis, yAxis) });
    /* *
     *
     *  Class
     *
     * */
    /**
     * Create a new axis object. Called internally when instantiating a new chart or
     * adding axes by {@link Highcharts.Chart#addAxis}.
     *
     * A chart can have from 0 axes (pie chart) to multiples. In a normal, single
     * series cartesian chart, there is one X axis and one Y axis.
     *
     * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is
     * an array of Axis objects. If there is only one axis, it can be referenced
     * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same
     * pattern goes for Y axes.
     *
     * If you need to get the axes from a series object, use the `series.xAxis` and
     * `series.yAxis` properties. These are not arrays, as one series can only be
     * associated to one X and one Y axis.
     *
     * A third way to reference the axis programmatically is by `id`. Add an `id` in
     * the axis configuration options, and get the axis by
     * {@link Highcharts.Chart#get}.
     *
     * Configuration options for the axes are given in options.xAxis and
     * options.yAxis.
     *
     * @class
     * @name Highcharts.Axis
     *
     * @param {Highcharts.Chart} chart
     * The Chart instance to apply the axis on.
     *
     * @param {Highcharts.AxisOptions} userOptions
     * Axis options
     */
    class Axis {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(chart, userOptions, coll) {
            this.init(chart, userOptions, coll);
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Overrideable function to initialize the axis.
         *
         * @see {@link Axis}
         *
         * @function Highcharts.Axis#init
         *
         * @param {Highcharts.Chart} chart
         * The Chart instance to apply the axis on.
         *
         * @param {AxisOptions} userOptions
         * Axis options.
         *
         * @emits Highcharts.Axis#event:afterInit
         * @emits Highcharts.Axis#event:init
         */
        init(chart, userOptions, coll = this.coll) {
            const isXAxis = coll === 'xAxis', axis = this, horiz = axis.isZAxis || (chart.inverted ? !isXAxis : isXAxis);
            /**
             * The Chart that the axis belongs to.
             *
             * @name Highcharts.Axis#chart
             * @type {Highcharts.Chart}
             */
            axis.chart = chart;
            /**
             * Whether the axis is horizontal.
             *
             * @name Highcharts.Axis#horiz
             * @type {boolean|undefined}
             */
            axis.horiz = horiz;
            /**
             * Whether the axis is the x-axis.
             *
             * @name Highcharts.Axis#isXAxis
             * @type {boolean|undefined}
             */
            axis.isXAxis = isXAxis;
            /**
             * The collection where the axis belongs, for example `xAxis`, `yAxis`
             * or `colorAxis`. Corresponds to properties on Chart, for example
             * {@link Chart.xAxis}.
             *
             * @name Highcharts.Axis#coll
             * @type {string}
             */
            axis.coll = coll;
            fireEvent$6(this, 'init', { userOptions: userOptions });
            // Needed in setOptions
            axis.opposite = pick$a(userOptions.opposite, axis.opposite);
            /**
             * The side on which the axis is rendered. 0 is top, 1 is right, 2
             * is bottom and 3 is left.
             *
             * @name Highcharts.Axis#side
             * @type {number}
             */
            axis.side = pick$a(userOptions.side, axis.side, (horiz ?
                (axis.opposite ? 0 : 2) : // Top : bottom
                (axis.opposite ? 1 : 3)) // Right : left
            );
            /**
             * Current options for the axis after merge of defaults and user's
             * options.
             *
             * @name Highcharts.Axis#options
             * @type {Highcharts.AxisOptions}
             */
            axis.setOptions(userOptions);
            const options = axis.options, labelsOptions = options.labels;
            // Set the type and fire an event
            axis.type ?? (axis.type = options.type || 'linear');
            axis.uniqueNames ?? (axis.uniqueNames = options.uniqueNames ?? true);
            fireEvent$6(axis, 'afterSetType');
            /**
             * User's options for this axis without defaults.
             *
             * @name Highcharts.Axis#userOptions
             * @type {Highcharts.AxisOptions}
             */
            axis.userOptions = userOptions;
            axis.minPixelPadding = 0;
            /**
             * Whether the axis is reversed. Based on the `axis.reversed`,
             * option, but inverted charts have reversed xAxis by default.
             *
             * @name Highcharts.Axis#reversed
             * @type {boolean}
             */
            axis.reversed = pick$a(options.reversed, axis.reversed);
            axis.visible = options.visible;
            axis.zoomEnabled = options.zoomEnabled;
            // Initial categories
            axis.hasNames = this.type === 'category' || options.categories === true;
            /**
             * If categories are present for the axis, names are used instead of
             * numbers for that axis.
             *
             * Since Highcharts 3.0, categories can also be extracted by giving each
             * point a name and setting axis type to `category`. However, if you
             * have multiple series, best practice remains defining the `categories`
             * array.
             *
             * @see [xAxis.categories](/highcharts/xAxis.categories)
             *
             * @name Highcharts.Axis#categories
             * @type {Array<string>}
             * @readonly
             */
            axis.categories = (isArray$6(options.categories) && options.categories) ||
                (axis.hasNames ? [] : void 0);
            if (!axis.names) { // Preserve on update (#3830)
                axis.names = [];
                axis.names.keys = {};
            }
            // Placeholder for plotlines and plotbands groups
            axis.plotLinesAndBandsGroups = {};
            // Shorthand types
            axis.positiveValuesOnly = !!axis.logarithmic;
            // Flag, if axis is linked to another axis
            axis.isLinked = defined$7(options.linkedTo);
            /**
             * List of major ticks mapped by position on axis.
             *
             * @see {@link Highcharts.Tick}
             *
             * @name Highcharts.Axis#ticks
             * @type {Highcharts.Dictionary<Highcharts.Tick>}
             */
            axis.ticks = {};
            axis.labelEdge = [];
            /**
             * List of minor ticks mapped by position on the axis.
             *
             * @see {@link Highcharts.Tick}
             *
             * @name Highcharts.Axis#minorTicks
             * @type {Highcharts.Dictionary<Highcharts.Tick>}
             */
            axis.minorTicks = {};
            // List of plotLines/Bands
            axis.plotLinesAndBands = [];
            // Alternate bands
            axis.alternateBands = {};
            /**
             * The length of the axis in terms of pixels.
             *
             * @name Highcharts.Axis#len
             * @type {number}
             */
            axis.len ?? (axis.len = 0);
            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
            axis.range = options.range;
            axis.offset = options.offset || 0;
            /**
             * The maximum value of the axis. In a logarithmic axis, this is the
             * logarithm of the real value, and the real value can be obtained from
             * {@link Axis#getExtremes}.
             *
             * @name Highcharts.Axis#max
             * @type {number|undefined}
             */
            axis.max = void 0;
            /**
             * The minimum value of the axis. In a logarithmic axis, this is the
             * logarithm of the real value, and the real value can be obtained from
             * {@link Axis#getExtremes}.
             *
             * @name Highcharts.Axis#min
             * @type {number|undefined}
             */
            axis.min = void 0;
            /**
             * The processed crosshair options.
             *
             * @name Highcharts.Axis#crosshair
             * @type {boolean|Highcharts.AxisCrosshairOptions}
             */
            const crosshair = pick$a(options.crosshair, splat$3(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);
            axis.crosshair = crosshair === true ? {} : crosshair;
            // Register. Don't add it again on Axis.update().
            if (chart.axes.indexOf(axis) === -1) { //
                if (isXAxis) { // #2713
                    chart.axes.splice(chart.xAxis.length, 0, axis);
                }
                else {
                    chart.axes.push(axis);
                }
                insertItem$1(this, chart[this.coll]);
            }
            chart.orderItems(axis.coll);
            /**
             * All series associated to the axis.
             *
             * @name Highcharts.Axis#series
             * @type {Array<Highcharts.Series>}
             */
            axis.series = axis.series || []; // Populated by Series
            // Reversed axis
            if (chart.inverted &&
                !axis.isZAxis &&
                isXAxis &&
                !defined$7(axis.reversed)) {
                axis.reversed = true;
            }
            axis.labelRotation = isNumber$7(labelsOptions.rotation) ?
                labelsOptions.rotation :
                void 0;
            // Register event listeners
            registerEventOptions$2(axis, options);
            fireEvent$6(this, 'afterInit');
        }
        /**
         * Merge and set options.
         *
         * @private
         * @function Highcharts.Axis#setOptions
         *
         * @param {Highcharts.AxisOptions} userOptions
         * Axis options.
         *
         * @emits Highcharts.Axis#event:afterSetOptions
         */
        setOptions(userOptions) {
            const sideSpecific = this.horiz ?
                // Top and bottom axis defaults
                {
                    labels: {
                        autoRotation: [-45],
                        padding: 4
                    },
                    margin: 15
                } :
                // Left and right axis, title rotated 90 or 270 degrees
                // respectively
                {
                    labels: {
                        padding: 1
                    },
                    title: {
                        rotation: 90 * this.side
                    }
                };
            this.options = merge$9(sideSpecific, defaultOptions$5[this.coll], userOptions);
            fireEvent$6(this, 'afterSetOptions', { userOptions });
        }
        /**
         * The default label formatter. The context is a special config object for
         * the label. In apps, use the
         * [labels.formatter](https://api.highcharts.com/highcharts/xAxis.labels.formatter)
         * instead, except when a modification is needed.
         *
         * @function Highcharts.Axis#defaultLabelFormatter
         *
         * @param {Highcharts.AxisLabelsFormatterContextObject} this
         * Formatter context of axis label.
         *
         * @param {Highcharts.AxisLabelsFormatterContextObject} [ctx]
         * Formatter context of axis label.
         *
         * @return {string}
         * The formatted label content.
         */
        defaultLabelFormatter() {
            const axis = this.axis, chart = this.chart, { numberFormatter } = chart, value = isNumber$7(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang = defaultOptions$5.lang, numericSymbols = lang.numericSymbols, numSymMagnitude = lang.numericSymbolMagnitude || 1000, 
            // Make sure the same symbol is added for all labels on a linear
            // axis
            numericSymbolDetector = axis.logarithmic ?
                Math.abs(value) :
                axis.tickInterval;
            let i = numericSymbols && numericSymbols.length, multi, ret;
            if (categories) {
                ret = `${this.value}`;
            }
            else if (dateTimeLabelFormat) { // Datetime axis
                ret = time.dateFormat(dateTimeLabelFormat, value);
            }
            else if (i &&
                numericSymbols &&
                numericSymbolDetector >= 1000) {
                // Decide whether we should add a numeric symbol like k (thousands)
                // or M (millions). If we are to enable this in tooltip or other
                // places as well, we can move this logic to the numberFormatter and
                // enable it by a parameter.
                while (i-- && typeof ret === 'undefined') {
                    multi = Math.pow(numSymMagnitude, i + 1);
                    if (
                    // Only accept a numeric symbol when the distance is more
                    // than a full unit. So for example if the symbol is k, we
                    // don't accept numbers like 0.5k.
                    numericSymbolDetector >= multi &&
                        // Accept one decimal before the symbol. Accepts 0.5k but
                        // not 0.25k. How does this work with the previous?
                        (value * 10) % multi === 0 &&
                        numericSymbols[i] !== null &&
                        value !== 0) { // #5480
                        ret = numberFormatter(value / multi, -1) + numericSymbols[i];
                    }
                }
            }
            if (typeof ret === 'undefined') {
                if (Math.abs(value) >= 10000) { // Add thousands separators
                    ret = numberFormatter(value, -1);
                }
                else { // Small numbers
                    ret = numberFormatter(value, -1, void 0, ''); // #2466
                }
            }
            return ret;
        }
        /**
         * Get the minimum and maximum for the series of each axis. The function
         * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.
         *
         * @private
         * @function Highcharts.Axis#getSeriesExtremes
         *
         * @emits Highcharts.Axis#event:afterGetSeriesExtremes
         * @emits Highcharts.Axis#event:getSeriesExtremes
         */
        getSeriesExtremes() {
            const axis = this;
            let xExtremes;
            fireEvent$6(this, 'getSeriesExtremes', null, function () {
                axis.hasVisibleSeries = false;
                // Reset properties in case we're redrawing (#3353)
                axis.dataMin = axis.dataMax = axis.threshold = void 0;
                axis.softThreshold = !axis.isXAxis;
                // Loop through this axis' series
                axis.series.forEach((series) => {
                    if (series.reserveSpace()) {
                        const seriesOptions = series.options;
                        let xData, threshold = seriesOptions.threshold, seriesDataMin, seriesDataMax;
                        axis.hasVisibleSeries = true;
                        // Validate threshold in logarithmic axes
                        if (axis.positiveValuesOnly && (threshold || 0) <= 0) {
                            threshold = void 0;
                        }
                        // Get dataMin and dataMax for X axes
                        if (axis.isXAxis) {
                            xData = series.xData;
                            if (xData && xData.length) {
                                xData = axis.logarithmic ?
                                    xData.filter((x) => x > 0) :
                                    xData;
                                xExtremes = series.getXExtremes(xData);
                                // If xData contains values which is not numbers,
                                // then filter them out. To prevent performance hit,
                                // we only do this after we have already found
                                // seriesDataMin because in most cases all data is
                                // valid. #5234.
                                seriesDataMin = xExtremes.min;
                                seriesDataMax = xExtremes.max;
                                if (!isNumber$7(seriesDataMin) &&
                                    // #5010:
                                    !(seriesDataMin instanceof Date)) {
                                    xData = xData.filter(isNumber$7);
                                    xExtremes = series.getXExtremes(xData);
                                    // Do it again with valid data
                                    seriesDataMin = xExtremes.min;
                                    seriesDataMax = xExtremes.max;
                                }
                                if (xData.length) {
                                    axis.dataMin = Math.min(pick$a(axis.dataMin, seriesDataMin), seriesDataMin);
                                    axis.dataMax = Math.max(pick$a(axis.dataMax, seriesDataMax), seriesDataMax);
                                }
                            }
                            // Get dataMin and dataMax for Y axes, as well as handle
                            // stacking and processed data
                        }
                        else {
                            // Get this particular series extremes
                            const dataExtremes = series.applyExtremes();
                            // Get the dataMin and dataMax so far. If percentage is
                            // used, the min and max are always 0 and 100. If
                            // seriesDataMin and seriesDataMax is null, then series
                            // doesn't have active y data, we continue with nulls
                            if (isNumber$7(dataExtremes.dataMin)) {
                                seriesDataMin = dataExtremes.dataMin;
                                axis.dataMin = Math.min(pick$a(axis.dataMin, seriesDataMin), seriesDataMin);
                            }
                            if (isNumber$7(dataExtremes.dataMax)) {
                                seriesDataMax = dataExtremes.dataMax;
                                axis.dataMax = Math.max(pick$a(axis.dataMax, seriesDataMax), seriesDataMax);
                            }
                            // Adjust to threshold
                            if (defined$7(threshold)) {
                                axis.threshold = threshold;
                            }
                            // If any series has a hard threshold, it takes
                            // precedence
                            if (!seriesOptions.softThreshold ||
                                axis.positiveValuesOnly) {
                                axis.softThreshold = false;
                            }
                        }
                    }
                });
            });
            fireEvent$6(this, 'afterGetSeriesExtremes');
        }
        /**
         * Translate from axis value to pixel position on the chart, or back. Use
         * the `toPixels` and `toValue` functions in applications.
         *
         * @private
         * @function Highcharts.Axis#translate
         */
        translate(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
            const axis = (this.linkedParent || this), // #1417
            localMin = (old && axis.old ? axis.old.min : axis.min);
            if (!isNumber$7(localMin)) {
                return NaN;
            }
            const minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal ||
                axis.brokenAxis?.hasBreaks ||
                (axis.logarithmic && handleLog)) && axis.lin2val;
            let sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;
            if (!localA) {
                localA = axis.transA;
            }
            // In vertical axes, the canvas coordinates start from 0 at the top like
            // in SVG.
            if (cvsCoord) {
                sign *= -1; // Canvas coordinates inverts the value
                cvsOffset = axis.len;
            }
            // Handle reversed axis
            if (axis.reversed) {
                sign *= -1;
                cvsOffset -= sign * (axis.sector || axis.len);
            }
            // From pixels to value
            if (backwards) { // Reverse translation
                val = val * sign + cvsOffset;
                val -= minPixelPadding;
                // From chart pixel to value:
                returnValue = val / localA + localMin;
                if (doPostTranslate) { // Log, ordinal and broken axis
                    returnValue = axis.lin2val(returnValue);
                }
                // From value to pixels
            }
            else {
                if (doPostTranslate) { // Log, ordinal and broken axis
                    val = axis.val2lin(val);
                }
                const value = sign * (val - localMin) * localA;
                returnValue = value +
                    cvsOffset +
                    (sign * minPixelPadding) +
                    (isNumber$7(pointPlacement) ? localA * pointPlacement : 0);
                if (!axis.isRadial) {
                    returnValue = correctFloat$1(returnValue);
                }
            }
            return returnValue;
        }
        /**
         * Translate a value in terms of axis units into pixels within the chart.
         *
         * @function Highcharts.Axis#toPixels
         *
         * @param {number} value
         * A value in terms of axis units.
         *
         * @param {boolean} [paneCoordinates=false]
         * Whether to return the pixel coordinate relative to the chart or just the
         * axis/pane itself.
         *
         * @return {number}
         * Pixel position of the value on the chart or axis.
         */
        toPixels(value, paneCoordinates) {
            return this.translate(value, false, !this.horiz, void 0, true) +
                (paneCoordinates ? 0 : this.pos);
        }
        /**
         * Translate a pixel position along the axis to a value in terms of axis
         * units.
         *
         * @function Highcharts.Axis#toValue
         *
         * @param {number} pixel
         * The pixel value coordinate.
         *
         * @param {boolean} [paneCoordinates=false]
         * Whether the input pixel is relative to the chart or just the axis/pane
         * itself.
         *
         * @return {number}
         * The axis value.
         */
        toValue(pixel, paneCoordinates) {
            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, void 0, true);
        }
        /**
         * Create the path for a plot line that goes from the given value on
         * this axis, across the plot to the opposite side. Also used internally for
         * grid lines and crosshairs.
         *
         * @function Highcharts.Axis#getPlotLinePath
         *
         * @param {Highcharts.AxisPlotLinePathOptionsObject} options
         * Options for the path.
         *
         * @return {Highcharts.SVGPathArray|null}
         * The SVG path definition for the plot line.
         */
        getPlotLinePath(options) {
            const axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options.old, value = options.value, lineWidth = options.lineWidth, cHeight = (old && chart.oldChartHeight) || chart.chartHeight, cWidth = (old && chart.oldChartWidth) || chart.chartWidth, transB = axis.transB;
            let translatedValue = options.translatedValue, force = options.force, x1, y1, x2, y2, skip;
            // eslint-disable-next-line valid-jsdoc
            /**
             * Check if x is between a and b. If not, either move to a/b
             * or skip, depending on the force parameter.
             * @private
             */
            function between(x, a, b) {
                if (force !== 'pass' && (x < a || x > b)) {
                    if (force) {
                        x = clamp$2(x, a, b);
                    }
                    else {
                        skip = true;
                    }
                }
                return x;
            }
            const evt = {
                value,
                lineWidth,
                old,
                force,
                acrossPanes: options.acrossPanes,
                translatedValue
            };
            fireEvent$6(this, 'getPlotLinePath', evt, function (e) {
                translatedValue = pick$a(translatedValue, axis.translate(value, void 0, void 0, old));
                // Keep the translated value within sane bounds, and avoid Infinity
                // to fail the isNumber test (#7709).
                translatedValue = clamp$2(translatedValue, -1e9, 1e9);
                x1 = x2 = translatedValue + transB;
                y1 = y2 = cHeight - translatedValue - transB;
                if (!isNumber$7(translatedValue)) { // No min or max
                    skip = true;
                    force = false; // #7175, don't force it when path is invalid
                }
                else if (axis.horiz) {
                    y1 = axisTop;
                    y2 = cHeight - axis.bottom + (axis.options.isInternal ?
                        0 :
                        (chart.scrollablePixelsY || 0)); // #20354, scrollablePixelsY shouldn't be used for navigator
                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
                }
                else {
                    x1 = axisLeft;
                    x2 = cWidth - axis.right + (chart.scrollablePixelsX || 0);
                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);
                }
                e.path = skip && !force ?
                    void 0 :
                    chart.renderer.crispLine([['M', x1, y1], ['L', x2, y2]], lineWidth || 1);
            });
            return evt.path;
        }
        /**
         * Internal function to get the tick positions of a linear axis to round
         * values like whole tens or every five.
         *
         * @function Highcharts.Axis#getLinearTickPositions
         *
         * @param {number} tickInterval
         * The normalized tick interval.
         *
         * @param {number} min
         * Axis minimum.
         *
         * @param {number} max
         * Axis maximum.
         *
         * @return {Array<number>}
         * An array of axis values where ticks should be placed.
         */
        getLinearTickPositions(tickInterval, min, max) {
            const roundedMin = correctFloat$1(Math.floor(min / tickInterval) * tickInterval), roundedMax = correctFloat$1(Math.ceil(max / tickInterval) * tickInterval), tickPositions = [];
            let pos, lastPos, precision;
            // When the precision is higher than what we filter out in
            // correctFloat, skip it (#6183).
            if (correctFloat$1(roundedMin + tickInterval) === roundedMin) {
                precision = 20;
            }
            // For single points, add a tick regardless of the relative position
            // (#2662, #6274)
            if (this.single) {
                return [min];
            }
            // Populate the intermediate values
            pos = roundedMin;
            while (pos <= roundedMax) {
                // Place the tick on the rounded value
                tickPositions.push(pos);
                // Always add the raw tickInterval, not the corrected one.
                pos = correctFloat$1(pos + tickInterval, precision);
                // If the interval is not big enough in the current min - max range
                // to actually increase the loop variable, we need to break out to
                // prevent endless loop. Issue #619
                if (pos === lastPos) {
                    break;
                }
                // Record the last value
                lastPos = pos;
            }
            return tickPositions;
        }
        /**
         * Resolve the new minorTicks/minorTickInterval options into the legacy
         * loosely typed minorTickInterval option.
         *
         * @function Highcharts.Axis#getMinorTickInterval
         *
         * @return {number|"auto"|null}
         * Legacy option
         */
        getMinorTickInterval() {
            const { minorTicks, minorTickInterval } = this.options;
            if (minorTicks === true) {
                return pick$a(minorTickInterval, 'auto');
            }
            if (minorTicks === false) {
                return;
            }
            return minorTickInterval;
        }
        /**
         * Internal function to return the minor tick positions. For logarithmic
         * axes, the same logic as for major ticks is reused.
         *
         * @function Highcharts.Axis#getMinorTickPositions
         *
         * @return {Array<number>}
         * An array of axis values where ticks should be placed.
         */
        getMinorTickPositions() {
            const axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min = (axis.min || 0) - pointRangePadding, // #1498
            max = (axis.max || 0) + pointRangePadding, // #1498
            range = max - min;
            let minorTickPositions = [], pos;
            // If minor ticks get too dense, they are hard to read, and may cause
            // long running script. So we don't draw them.
            if (range && range / minorTickInterval < axis.len / 3) { // #3875
                const logarithmic = axis.logarithmic;
                if (logarithmic) {
                    // For each interval in the major ticks, compute the minor ticks
                    // separately.
                    this.paddedTicks.forEach(function (_pos, i, paddedTicks) {
                        if (i) {
                            minorTickPositions.push.apply(minorTickPositions, logarithmic.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
                        }
                    });
                }
                else if (axis.dateTime &&
                    this.getMinorTickInterval() === 'auto') { // #1314
                    minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));
                }
                else {
                    for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
                        // Very, very, tight grid lines (#5771)
                        if (pos === minorTickPositions[0]) {
                            break;
                        }
                        minorTickPositions.push(pos);
                    }
                }
            }
            if (minorTickPositions.length !== 0) {
                axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330
            }
            return minorTickPositions;
        }
        /**
         * Adjust the min and max for the minimum range. Keep in mind that the
         * series data is not yet processed, so we don't have information on data
         * cropping and grouping, or updated `axis.pointRange` or
         * `series.pointRange`. The data can't be processed until we have finally
         * established min and max.
         *
         * @private
         * @function Highcharts.Axis#adjustForMinRange
         */
        adjustForMinRange() {
            const axis = this, options = axis.options, logarithmic = axis.logarithmic;
            let { max, min, minRange } = axis, zoomOffset, spaceAvailable, closestDataRange, minArgs, maxArgs;
            // Set the automatic minimum range based on the closest point distance
            if (axis.isXAxis &&
                typeof minRange === 'undefined' &&
                !logarithmic) {
                if (defined$7(options.min) ||
                    defined$7(options.max) ||
                    defined$7(options.floor) ||
                    defined$7(options.ceiling)) {
                    // Setting it to null, as opposed to undefined, signals we don't
                    // run this block again as per the condition above.
                    minRange = null;
                }
                else {
                    // Find the closest distance between raw data points, as opposed
                    // to closestPointRange that applies to processed points
                    // (cropped and grouped)
                    closestDataRange = getClosestDistance$1(axis.series.map((s) => 
                    // If xIncrement, we only need to measure the two first
                    // points to get the distance. Saves processing time.
                    (s.xIncrement ? s.xData?.slice(0, 2) : s.xData) || [])) || 0;
                    minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
                }
            }
            // If minRange is exceeded, adjust
            if (isNumber$7(max) &&
                isNumber$7(min) &&
                isNumber$7(minRange) &&
                max - min < minRange) {
                spaceAvailable =
                    axis.dataMax - axis.dataMin >=
                        minRange;
                zoomOffset = (minRange - max + min) / 2;
                // If min and max options have been set, don't go beyond it
                minArgs = [
                    min - zoomOffset,
                    pick$a(options.min, min - zoomOffset)
                ];
                // If space is available, stay within the data range
                if (spaceAvailable) {
                    minArgs[2] = logarithmic ?
                        logarithmic.log2lin(axis.dataMin) :
                        axis.dataMin;
                }
                min = arrayMax$1(minArgs);
                maxArgs = [
                    min + minRange,
                    pick$a(options.max, min + minRange)
                ];
                // If space is available, stay within the data range
                if (spaceAvailable) {
                    maxArgs[2] = logarithmic ?
                        logarithmic.log2lin(axis.dataMax) :
                        axis.dataMax;
                }
                max = arrayMin$1(maxArgs);
                // Now if the max is adjusted, adjust the min back
                if (max - min < minRange) {
                    minArgs[0] = max - minRange;
                    minArgs[1] = pick$a(options.min, max - minRange);
                    min = arrayMax$1(minArgs);
                }
            }
            // Record modified extremes
            axis.minRange = minRange;
            axis.min = min;
            axis.max = max;
        }
        /**
         * Find the closestPointRange across all series, including the single data
         * series.
         *
         * @private
         * @function Highcharts.Axis#getClosest
         */
        getClosest() {
            let closestSingleDistance, closestDistance;
            if (this.categories) {
                closestDistance = 1;
            }
            else {
                const singleXs = [];
                this.series.forEach(function (series) {
                    const seriesClosest = series.closestPointRange;
                    if (series.xData?.length === 1) {
                        singleXs.push(series.xData[0]);
                    }
                    else if (!series.noSharedTooltip &&
                        defined$7(seriesClosest) &&
                        series.reserveSpace()) {
                        closestDistance = defined$7(closestDistance) ?
                            Math.min(closestDistance, seriesClosest) :
                            seriesClosest;
                    }
                });
                if (singleXs.length) {
                    singleXs.sort((a, b) => a - b);
                    closestSingleDistance = getClosestDistance$1([singleXs]);
                }
            }
            if (closestSingleDistance && closestDistance) {
                return Math.min(closestSingleDistance, closestDistance);
            }
            return closestSingleDistance || closestDistance;
        }
        /**
         * When a point name is given and no x, search for the name in the existing
         * categories, or if categories aren't provided, search names or create a
         * new category (#2522).
         *
         * @private
         * @function Highcharts.Axis#nameToX
         *
         * @param {Highcharts.Point} point
         * The point to inspect.
         *
         * @return {number}
         * The X value that the point is given.
         */
        nameToX(point) {
            const explicitCategories = isArray$6(this.options.categories), names = explicitCategories ? this.categories : this.names;
            let nameX = point.options.x, x;
            point.series.requireSorting = false;
            if (!defined$7(nameX)) {
                nameX = this.uniqueNames && names ?
                    (explicitCategories ?
                        names.indexOf(point.name) :
                        pick$a(names.keys[point.name], -1)) :
                    point.series.autoIncrement();
            }
            if (nameX === -1) { // Not found in current categories
                if (!explicitCategories && names) {
                    x = names.length;
                }
            }
            else {
                x = nameX;
            }
            // Write the last point's name to the names array
            if (typeof x !== 'undefined') {
                this.names[x] = point.name;
                // Backwards mapping is much faster than array searching (#7725)
                this.names.keys[point.name] = x;
            }
            else if (point.x) {
                x = point.x; // #17438
            }
            return x;
        }
        /**
         * When changes have been done to series data, update the axis.names.
         *
         * @private
         * @function Highcharts.Axis#updateNames
         */
        updateNames() {
            const axis = this, names = this.names, i = names.length;
            if (i > 0) {
                Object.keys(names.keys).forEach(function (key) {
                    delete (names.keys)[key];
                });
                names.length = 0;
                this.minRange = this.userMinRange; // Reset
                (this.series || []).forEach((series) => {
                    // Reset incrementer (#5928)
                    series.xIncrement = null;
                    // When adding a series, points are not yet generated
                    if (!series.points || series.isDirtyData) {
                        // When we're updating the series with data that is longer
                        // than it was, and cropThreshold is passed, we need to make
                        // sure that the axis.max is increased _before_ running the
                        // premature processData. Otherwise this early iteration of
                        // processData will crop the points to axis.max, and the
                        // names array will be too short (#5857).
                        axis.max = Math.max(axis.max, series.xData.length - 1);
                        series.processData();
                        series.generatePoints();
                    }
                    series.data.forEach(function (point, i) {
                        let x;
                        if (point?.options &&
                            typeof point.name !== 'undefined' // #9562
                        ) {
                            x = axis.nameToX(point);
                            if (typeof x !== 'undefined' && x !== point.x) {
                                point.x = x;
                                series.xData[i] = x;
                            }
                        }
                    });
                });
            }
        }
        /**
         * Update translation information.
         *
         * @private
         * @function Highcharts.Axis#setAxisTranslation
         *
         * @emits Highcharts.Axis#event:afterSetAxisTranslation
         */
        setAxisTranslation() {
            const axis = this, range = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;
            let pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
            // Adjust translation for padding. Y axis with categories need to go
            // through the same (#1784).
            if (isXAxis || hasCategories || pointRange) {
                // Get the closest points
                closestPointRange = axis.getClosest();
                if (linkedParent) {
                    minPointOffset = linkedParent.minPointOffset;
                    pointRangePadding = linkedParent.pointRangePadding;
                }
                else {
                    axis.series.forEach(function (series) {
                        const seriesPointRange = hasCategories ?
                            1 :
                            (isXAxis ?
                                pick$a(series.options.pointRange, closestPointRange, 0) :
                                (axis.axisPointRange || 0)), // #2806
                        pointPlacement = series.options.pointPlacement;
                        pointRange = Math.max(pointRange, seriesPointRange);
                        if (!axis.single || hasCategories) {
                            // TODO: series should internally set x- and y-
                            // pointPlacement to simplify this logic.
                            const isPointPlacementAxis = series.is('xrange') ?
                                !isXAxis :
                                isXAxis;
                            // The `minPointOffset` is the value padding to the left
                            // of the axis in order to make room for points with a
                            // pointRange, typically columns. When the
                            // pointPlacement option is 'between' or 'on', this
                            // padding does not apply.
                            minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString$6(pointPlacement) ?
                                0 :
                                seriesPointRange / 2);
                            // Determine the total padding needed to the length of
                            // the axis to make room for the pointRange. If the
                            // series' pointPlacement is 'on', no padding is added.
                            pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === 'on' ?
                                0 :
                                seriesPointRange);
                        }
                    });
                }
                // Record minPointOffset and pointRangePadding
                ordinalCorrection = (axis.ordinal && axis.ordinal.slope && closestPointRange) ?
                    axis.ordinal.slope / closestPointRange :
                    1; // #988, #1853
                axis.minPointOffset = minPointOffset =
                    minPointOffset * ordinalCorrection;
                axis.pointRangePadding =
                    pointRangePadding = pointRangePadding * ordinalCorrection;
                // The `pointRange` is the width reserved for each point, like in a
                // column chart
                axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);
                // The `closestPointRange` is the closest distance between points.
                // In columns it is mostly equal to pointRange, but in lines
                // pointRange is 0 while closestPointRange is some other value
                if (isXAxis && closestPointRange) {
                    axis.closestPointRange = closestPointRange;
                }
            }
            // Secondary values
            axis.translationSlope = axis.transA = transA =
                axis.staticScale ||
                    axis.len / ((range + pointRangePadding) || 1);
            // Translation addend
            axis.transB = axis.horiz ? axis.left : axis.bottom;
            axis.minPixelPadding = transA * minPointOffset;
            fireEvent$6(this, 'afterSetAxisTranslation');
        }
        /**
         * @private
         * @function Highcharts.Axis#minFromRange
         */
        minFromRange() {
            const { max, min } = this;
            return isNumber$7(max) && isNumber$7(min) && max - min || void 0;
        }
        /**
         * Set the tick positions to round values and optionally extend the extremes
         * to the nearest tick.
         *
         * @private
         * @function Highcharts.Axis#setTickInterval
         *
         * @param {boolean} secondPass
         * TO-DO: parameter description
         *
         * @emits Highcharts.Axis#event:foundExtremes
         */
        setTickInterval(secondPass) {
            const axis = this, { categories, chart, dataMax, dataMin, dateTime, isXAxis, logarithmic, options, softThreshold } = axis, threshold = isNumber$7(axis.threshold) ? axis.threshold : void 0, minRange = axis.minRange || 0, { ceiling, floor, linkedTo, softMax, softMin } = options, linkedParent = isNumber$7(linkedTo) && chart[axis.coll]?.[linkedTo], tickPixelIntervalOption = options.tickPixelInterval;
            let maxPadding = options.maxPadding, minPadding = options.minPadding, range = 0, linkedParentExtremes, 
            // Only non-negative tickInterval is valid, #12961
            tickIntervalOption = isNumber$7(options.tickInterval) && options.tickInterval >= 0 ?
                options.tickInterval : void 0, thresholdMin, thresholdMax, hardMin, hardMax;
            if (!dateTime && !categories && !linkedParent) {
                this.getTickAmount();
            }
            // Min or max set either by zooming/setExtremes or initial options
            hardMin = pick$a(axis.userMin, options.min);
            hardMax = pick$a(axis.userMax, options.max);
            // Linked axis gets the extremes from the parent axis
            if (linkedParent) {
                axis.linkedParent = linkedParent;
                linkedParentExtremes = linkedParent.getExtremes();
                axis.min = pick$a(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                axis.max = pick$a(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                if (this.type !== linkedParent.type) {
                    // Can't link axes of different type
                    error$3(11, true, chart);
                }
                // Initial min and max from the extreme data values
            }
            else {
                // Adjust to hard threshold
                if (softThreshold &&
                    defined$7(threshold) &&
                    isNumber$7(dataMax) &&
                    isNumber$7(dataMin)) {
                    if (dataMin >= threshold) {
                        thresholdMin = threshold;
                        minPadding = 0;
                    }
                    else if (dataMax <= threshold) {
                        thresholdMax = threshold;
                        maxPadding = 0;
                    }
                }
                axis.min = pick$a(hardMin, thresholdMin, dataMin);
                axis.max = pick$a(hardMax, thresholdMax, dataMax);
            }
            if (isNumber$7(axis.max) && isNumber$7(axis.min)) {
                if (logarithmic) {
                    if (axis.positiveValuesOnly &&
                        !secondPass &&
                        Math.min(axis.min, pick$a(dataMin, axis.min)) <= 0) { // #978
                        // Can't plot negative values on log axis
                        error$3(10, true, chart);
                    }
                    // The correctFloat cures #934, float errors on full tens. But
                    // it was too aggressive for #4360 because of conversion back to
                    // lin, therefore use precision 15.
                    axis.min = correctFloat$1(logarithmic.log2lin(axis.min), 16);
                    axis.max = correctFloat$1(logarithmic.log2lin(axis.max), 16);
                }
                // Handle zoomed range
                if (axis.range && isNumber$7(dataMin)) {
                    // #618, #6773:
                    axis.userMin = axis.min = hardMin = Math.max(dataMin, axis.minFromRange() || 0);
                    axis.userMax = hardMax = axis.max;
                    axis.range = void 0; // Don't use it when running setExtremes
                }
            }
            // Hook for Highcharts Stock Scroller and bubble axis padding
            fireEvent$6(axis, 'foundExtremes');
            // Adjust min and max for the minimum range
            axis.adjustForMinRange();
            if (isNumber$7(axis.min) && isNumber$7(axis.max)) {
                // Handle options for floor, ceiling, softMin and softMax (#6359)
                if (!isNumber$7(axis.userMin) &&
                    isNumber$7(softMin) &&
                    softMin < axis.min) {
                    axis.min = hardMin = softMin; // #6894
                }
                if (!isNumber$7(axis.userMax) &&
                    isNumber$7(softMax) &&
                    softMax > axis.max) {
                    axis.max = hardMax = softMax; // #6894
                }
                // Pad the values to get clear of the chart's edges. To avoid
                // tickInterval taking the padding into account, we do this after
                // computing tick interval (#1337).
                if (!categories &&
                    !axis.axisPointRange &&
                    !axis.stacking?.usePercentage &&
                    !linkedParent) {
                    range = axis.max - axis.min;
                    if (range) {
                        if (!defined$7(hardMin) && minPadding) {
                            axis.min -= range * minPadding;
                        }
                        if (!defined$7(hardMax) && maxPadding) {
                            axis.max += range * maxPadding;
                        }
                    }
                }
                if (!isNumber$7(axis.userMin) && isNumber$7(floor)) {
                    axis.min = Math.max(axis.min, floor);
                }
                if (!isNumber$7(axis.userMax) && isNumber$7(ceiling)) {
                    axis.max = Math.min(axis.max, ceiling);
                }
                // When the threshold is soft, adjust the extreme value only if the
                // data extreme and the padded extreme land on either side of the
                // threshold. For example, a series of [0, 1, 2, 3] would make the
                // yAxis add a tick for -1 because of the default `minPadding` and
                // `startOnTick` options. This is prevented by the `softThreshold`
                // option.
                if (softThreshold &&
                    isNumber$7(dataMin) &&
                    isNumber$7(dataMax)) {
                    const numThreshold = threshold || 0;
                    if (!defined$7(hardMin) &&
                        axis.min < numThreshold &&
                        dataMin >= numThreshold) {
                        axis.min = options.minRange ?
                            Math.min(numThreshold, axis.max - minRange) :
                            numThreshold;
                    }
                    else if (!defined$7(hardMax) &&
                        axis.max > numThreshold &&
                        dataMax <= numThreshold) {
                        axis.max = options.minRange ?
                            Math.max(numThreshold, axis.min + minRange) :
                            numThreshold;
                    }
                }
                // If min is bigger than highest, or if max less than lowest value,
                // the chart should not render points. (#14417)
                if (!chart.polar && axis.min > axis.max) {
                    if (defined$7(options.min)) {
                        axis.max = axis.min;
                    }
                    else if (defined$7(options.max)) {
                        axis.min = axis.max;
                    }
                }
                range = axis.max - axis.min;
            }
            // Get tickInterval
            if (axis.min === axis.max ||
                !isNumber$7(axis.min) ||
                !isNumber$7(axis.max)) {
                axis.tickInterval = 1;
            }
            else if (linkedParent &&
                !tickIntervalOption &&
                tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
                axis.tickInterval = tickIntervalOption = linkedParent.tickInterval;
            }
            else {
                axis.tickInterval = pick$a(tickIntervalOption, this.tickAmount ?
                    range / Math.max(this.tickAmount - 1, 1) :
                    void 0, 
                // For categorized axis, 1 is default, for linear axis use
                // tickPix
                categories ?
                    1 :
                    // Don't let it be more than the data range
                    range * tickPixelIntervalOption /
                        Math.max(axis.len, tickPixelIntervalOption));
            }
            // Now we're finished detecting min and max, crop and group series data.
            // This is in turn needed in order to find tick positions in ordinal
            // axes.
            if (isXAxis && !secondPass) {
                const hasExtremesChanged = axis.min !== axis.old?.min ||
                    axis.max !== axis.old?.max;
                // First process all series assigned to that axis.
                axis.series.forEach(function (series) {
                    // Allows filtering out points outside the plot area.
                    series.forceCrop = series.forceCropping?.();
                    series.processData(hasExtremesChanged);
                });
                // Then apply grouping if needed. The hasExtremesChanged helps to
                // decide if the data grouping should be skipped in the further
                // calculations #16319.
                fireEvent$6(this, 'postProcessData', { hasExtremesChanged });
            }
            // Set the translation factor used in translate function
            axis.setAxisTranslation();
            // Hook for ordinal axes and radial axes
            fireEvent$6(this, 'initialAxisTranslation');
            // In column-like charts, don't cramp in more ticks than there are
            // points (#1943, #4184)
            if (axis.pointRange && !tickIntervalOption) {
                axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
            }
            // Before normalizing the tick interval, handle minimum tick interval.
            // This applies only if tickInterval is not defined.
            const minTickInterval = pick$a(options.minTickInterval, 
            // In datetime axes, don't go below the data interval, except when
            // there are scatter-like series involved (#13369).
            dateTime &&
                !axis.series.some((s) => s.noSharedTooltip) ?
                axis.closestPointRange : 0);
            if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
                axis.tickInterval = minTickInterval;
            }
            // For linear axes, normalize the interval
            if (!dateTime && !logarithmic && !tickIntervalOption) {
                axis.tickInterval = getNormalizedTickInterval(axis, axis.tickInterval);
            }
            // Prevent ticks from getting so close that we can't draw the labels
            if (!this.tickAmount) {
                axis.tickInterval = axis.unsquish();
            }
            this.setTickPositions();
        }
        /**
         * Now we have computed the normalized tickInterval, get the tick positions.
         *
         * @private
         * @function Highcharts.Axis#setTickPositions
         *
         * @emits Highcharts.Axis#event:afterSetTickPositions
         */
        setTickPositions() {
            const axis = this, options = this.options, tickPositionsOption = options.tickPositions, tickPositioner = options.tickPositioner, minorTickIntervalOption = this.getMinorTickInterval(), allowEndOnTick = !this.isPanning, startOnTick = allowEndOnTick && options.startOnTick, endOnTick = allowEndOnTick && options.endOnTick;
            let tickPositions = [], tickPositionerResult;
            // Set the tickmarkOffset
            this.tickmarkOffset = (this.categories &&
                options.tickmarkPlacement === 'between' &&
                this.tickInterval === 1) ? 0.5 : 0; // #3202
            // When there is only one point, or all points have the same value on
            // this axis, then min and max are equal and tickPositions.length is 0
            // or 1. In this case, add some padding in order to center the point,
            // but leave it with one tick. #1337.
            this.single =
                this.min === this.max &&
                    defined$7(this.min) &&
                    !this.tickAmount &&
                    (
                    // Data is on integer (#6563)
                    this.min % 1 === 0 ||
                        // Between integers and decimals are not allowed (#6274)
                        options.allowDecimals !== false);
            /**
             * Contains the current positions that are laid out on the axis. The
             * positions are numbers in terms of axis values. In a category axis
             * they are integers, in a datetime axis they are also integers, but
             * designating milliseconds.
             *
             * This property is read only - for modifying the tick positions, use
             * the `tickPositioner` callback or [axis.tickPositions(
             * https://api.highcharts.com/highcharts/xAxis.tickPositions) option
             * instead.
             *
             * @name Highcharts.Axis#tickPositions
             * @type {Highcharts.AxisTickPositionsArray|undefined}
             */
            if (tickPositionsOption) {
                // Find the tick positions. Work on a copy (#1565)
                tickPositions = tickPositionsOption.slice();
            }
            else if (isNumber$7(this.min) && isNumber$7(this.max)) {
                // Too many ticks (#6405). Create a friendly warning and provide two
                // ticks so at least we can show the data series.
                if (!axis.ordinal?.positions &&
                    ((this.max - this.min) /
                        this.tickInterval >
                        Math.max(2 * this.len, 200))) {
                    tickPositions = [this.min, this.max];
                    error$3(19, false, this.chart);
                }
                else if (axis.dateTime) {
                    tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal?.positions, this.closestPointRange, true);
                }
                else if (axis.logarithmic) {
                    tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                }
                else {
                    const startingTickInterval = this.tickInterval;
                    let adjustedTickInterval = startingTickInterval;
                    while (adjustedTickInterval <= startingTickInterval * 2) {
                        tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
                        // If there are more tick positions than the set tickAmount,
                        // increase the tickInterval and continue until it fits.
                        // (#17100)
                        if (this.tickAmount &&
                            tickPositions.length > this.tickAmount) {
                            this.tickInterval = getNormalizedTickInterval(this, adjustedTickInterval *= 1.1);
                        }
                        else {
                            break;
                        }
                    }
                }
                // Too dense ticks, keep only the first and last (#4477)
                if (tickPositions.length > this.len) {
                    tickPositions = [
                        tickPositions[0],
                        tickPositions[tickPositions.length - 1]
                    ];
                    // Reduce doubled value (#7339)
                    if (tickPositions[0] === tickPositions[1]) {
                        tickPositions.length = 1;
                    }
                }
                // Run the tick positioner callback, that allows modifying auto tick
                // positions.
                if (tickPositioner) {
                    // Make it available to the positioner
                    this.tickPositions = tickPositions;
                    tickPositionerResult = tickPositioner.apply(axis, [this.min, this.max]);
                    if (tickPositionerResult) {
                        tickPositions = tickPositionerResult;
                    }
                }
            }
            this.tickPositions = tickPositions;
            // Get minorTickInterval
            this.minorTickInterval =
                minorTickIntervalOption === 'auto' && this.tickInterval ?
                    this.tickInterval / options.minorTicksPerMajor :
                    minorTickIntervalOption;
            // Reset min/max or remove extremes based on start/end on tick
            this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor
            this.trimTicks(tickPositions, startOnTick, endOnTick);
            if (!this.isLinked && isNumber$7(this.min) && isNumber$7(this.max)) {
                // Substract half a unit (#2619, #2846, #2515, #3390), but not in
                // case of multiple ticks (#6897)
                if (this.single &&
                    tickPositions.length < 2 &&
                    !this.categories &&
                    !this.series.some((s) => (s.is('heatmap') && s.options.pointPlacement === 'between'))) {
                    this.min -= 0.5;
                    this.max += 0.5;
                }
                if (!tickPositionsOption && !tickPositionerResult) {
                    this.adjustTickAmount();
                }
            }
            fireEvent$6(this, 'afterSetTickPositions');
        }
        /**
         * Handle startOnTick and endOnTick by either adapting to padding min/max or
         * rounded min/max. Also handle single data points.
         *
         * @private
         * @function Highcharts.Axis#trimTicks
         *
         * @param {Array<number>} tickPositions
         * TO-DO: parameter description
         *
         * @param {boolean} [startOnTick]
         * TO-DO: parameter description
         *
         * @param {boolean} [endOnTick]
         * TO-DO: parameter description
         */
        trimTicks(tickPositions, startOnTick, endOnTick) {
            const roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = (!this.isOrdinal && this.minPointOffset) || 0; // (#12716)
            fireEvent$6(this, 'trimTicks');
            if (!this.isLinked) {
                if (startOnTick && roundedMin !== -Infinity) { // #6502
                    this.min = roundedMin;
                }
                else {
                    while (this.min - minPointOffset > tickPositions[0]) {
                        tickPositions.shift();
                    }
                }
                if (endOnTick) {
                    this.max = roundedMax;
                }
                else {
                    while (this.max + minPointOffset <
                        tickPositions[tickPositions.length - 1]) {
                        tickPositions.pop();
                    }
                }
                // If no tick are left, set one tick in the middle (#3195)
                if (tickPositions.length === 0 &&
                    defined$7(roundedMin) &&
                    !this.options.tickPositions) {
                    tickPositions.push((roundedMax + roundedMin) / 2);
                }
            }
        }
        /**
         * Check if there are multiple axes in the same pane.
         *
         * @private
         * @function Highcharts.Axis#alignToOthers
         *
         * @return {boolean|undefined}
         * True if there are other axes.
         */
        alignToOthers() {
            const axis = this, chart = axis.chart, alignedAxes = [this], options = axis.options, chartOptions = chart.options.chart, alignThresholds = (this.coll === 'yAxis' &&
                chartOptions.alignThresholds), thresholdAlignments = [];
            let hasOther;
            axis.thresholdAlignment = void 0;
            if ((
            // Only if alignTicks or alignThresholds is true
            (chartOptions.alignTicks !== false && options.alignTicks) ||
                alignThresholds) &&
                // Disabled when startOnTick or endOnTick are false (#7604)
                options.startOnTick !== false &&
                options.endOnTick !== false &&
                // Don't try to align ticks on a log axis, they are not evenly
                // spaced (#6021)
                !axis.logarithmic) {
                // Get a key identifying which pane the axis belongs to
                const getKey = (axis) => {
                    const { horiz, options } = axis;
                    return [
                        horiz ? options.left : options.top,
                        options.width,
                        options.height,
                        options.pane
                    ].join(',');
                };
                const thisKey = getKey(this);
                chart[this.coll].forEach(function (otherAxis) {
                    const { series } = otherAxis;
                    if (
                    // #4442
                    series.length &&
                        series.some((s) => s.visible) &&
                        otherAxis !== axis &&
                        getKey(otherAxis) === thisKey) {
                        hasOther = true; // #4201
                        alignedAxes.push(otherAxis);
                    }
                });
            }
            if (hasOther && alignThresholds) {
                // Handle alignThresholds. The `thresholdAlignments` array keeps
                // records of where each axis in the group wants its threshold, from
                // 0 which is on `axis.min`, to 1 which is on `axis.max`.
                alignedAxes.forEach((otherAxis) => {
                    const threshAlign = otherAxis.getThresholdAlignment(axis);
                    if (isNumber$7(threshAlign)) {
                        thresholdAlignments.push(threshAlign);
                    }
                });
                // For each of the axes in the group, record the average
                // `thresholdAlignment`.
                const thresholdAlignment = thresholdAlignments.length > 1 ?
                    thresholdAlignments.reduce((sum, n) => (sum += n), 0) / thresholdAlignments.length :
                    void 0;
                alignedAxes.forEach((axis) => {
                    axis.thresholdAlignment = thresholdAlignment;
                });
            }
            return hasOther;
        }
        /**
         * Where the axis wants its threshold, from 0 which is on `axis.min`, to 1 which
         * is on `axis.max`.
         *
         * @private
         * @function Highcharts.Axis#getThresholdAlignment
         */
        getThresholdAlignment(callerAxis) {
            if (!isNumber$7(this.dataMin) ||
                (this !== callerAxis &&
                    this.series.some((s) => (s.isDirty || s.isDirtyData)))) {
                this.getSeriesExtremes();
            }
            if (isNumber$7(this.threshold)) {
                let thresholdAlignment = clamp$2(((this.threshold - (this.dataMin || 0)) /
                    ((this.dataMax || 0) - (this.dataMin || 0))), 0, 1);
                if (this.options.reversed) {
                    thresholdAlignment = 1 - thresholdAlignment;
                }
                return thresholdAlignment;
            }
        }
        /**
         * Find the max ticks of either the x and y axis collection, and record it
         * in `this.tickAmount`.
         *
         * @private
         * @function Highcharts.Axis#getTickAmount
         */
        getTickAmount() {
            const axis = this, options = this.options, tickPixelInterval = options.tickPixelInterval;
            let tickAmount = options.tickAmount;
            if (!defined$7(options.tickInterval) &&
                !tickAmount &&
                this.len < tickPixelInterval &&
                !this.isRadial &&
                !axis.logarithmic &&
                options.startOnTick &&
                options.endOnTick) {
                tickAmount = 2;
            }
            if (!tickAmount && this.alignToOthers()) {
                // Add 1 because 4 tick intervals require 5 ticks (including first
                // and last)
                tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
            }
            // For tick amounts of 2 and 3, compute five ticks and remove the
            // intermediate ones. This prevents the axis from adding ticks that are
            // too far away from the data extremes.
            if (tickAmount < 4) {
                this.finalTickAmt = tickAmount;
                tickAmount = 5;
            }
            this.tickAmount = tickAmount;
        }
        /**
         * When using multiple axes, adjust the number of ticks to match the highest
         * number of ticks in that group.
         *
         * @private
         * @function Highcharts.Axis#adjustTickAmount
         */
        adjustTickAmount() {
            const axis = this, { finalTickAmt, max, min, options, tickPositions, tickAmount, thresholdAlignment } = axis, currentTickAmount = tickPositions?.length, threshold = pick$a(axis.threshold, axis.softThreshold ? 0 : null);
            let len, i, tickInterval = axis.tickInterval, thresholdTickIndex;
            const 
            // Extend the tickPositions by appending a position
            append = () => tickPositions.push(correctFloat$1(tickPositions[tickPositions.length - 1] +
                tickInterval)), 
            // Extend the tickPositions by prepending a position
            prepend = () => tickPositions.unshift(correctFloat$1(tickPositions[0] - tickInterval));
            // If `thresholdAlignment` is a number, it means the `alignThresholds`
            // option is true. The `thresholdAlignment` is a scalar value between 0
            // and 1 for where the threshold should be relative to `axis.min` and
            // `axis.max`. Now that we know the tick amount, convert this to the
            // tick index. Unless `thresholdAlignment` is exactly 0 or 1, avoid the
            // first or last tick because that would lead to series being clipped.
            if (isNumber$7(thresholdAlignment)) {
                thresholdTickIndex = thresholdAlignment < 0.5 ?
                    Math.ceil(thresholdAlignment * (tickAmount - 1)) :
                    Math.floor(thresholdAlignment * (tickAmount - 1));
                if (options.reversed) {
                    thresholdTickIndex = tickAmount - 1 - thresholdTickIndex;
                }
            }
            if (axis.hasData() && isNumber$7(min) && isNumber$7(max)) { // #14769
                // Adjust extremes and translation to the modified tick positions
                const adjustExtremes = () => {
                    axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
                    // Do not crop when ticks are not extremes (#9841)
                    axis.min = options.startOnTick ?
                        tickPositions[0] :
                        Math.min(min, tickPositions[0]);
                    axis.max = options.endOnTick ?
                        tickPositions[tickPositions.length - 1] :
                        Math.max(max, tickPositions[tickPositions.length - 1]);
                };
                // When the axis is subject to the alignThresholds option. Use
                // axis.threshold because the local threshold includes the
                // `softThreshold`.
                if (isNumber$7(thresholdTickIndex) && isNumber$7(axis.threshold)) {
                    // Throw away the previously computed tickPositions and start
                    // from scratch with only the threshold itself, then add ticks
                    // below the threshold first, then fill up above the threshold.
                    // If we are not able to fill up to axis.max, double the
                    // tickInterval and run again.
                    while (tickPositions[thresholdTickIndex] !== threshold ||
                        tickPositions.length !== tickAmount ||
                        tickPositions[0] > min ||
                        tickPositions[tickPositions.length - 1] < max) {
                        tickPositions.length = 0;
                        tickPositions.push(axis.threshold);
                        while (tickPositions.length < tickAmount) {
                            if (
                            // Start by prepending positions until the threshold
                            // is at the required index...
                            tickPositions[thresholdTickIndex] === void 0 ||
                                tickPositions[thresholdTickIndex] > axis.threshold) {
                                prepend();
                            }
                            else {
                                // ... then append positions until we have the
                                // required length
                                append();
                            }
                        }
                        // Safety vent
                        if (tickInterval > axis.tickInterval * 8) {
                            break;
                        }
                        tickInterval *= 2;
                    }
                    adjustExtremes();
                }
                else if (currentTickAmount < tickAmount) {
                    while (tickPositions.length < tickAmount) {
                        // Extend evenly for both sides unless we're on the
                        // threshold (#3965)
                        if (tickPositions.length % 2 || min === threshold) {
                            append();
                        }
                        else {
                            prepend();
                        }
                    }
                    adjustExtremes();
                }
                // The finalTickAmt property is set in getTickAmount
                if (defined$7(finalTickAmt)) {
                    i = len = tickPositions.length;
                    while (i--) {
                        if (
                        // Remove every other tick
                        (finalTickAmt === 3 && i % 2 === 1) ||
                            // Remove all but first and last
                            (finalTickAmt <= 2 && i > 0 && i < len - 1)) {
                            tickPositions.splice(i, 1);
                        }
                    }
                    axis.finalTickAmt = void 0;
                }
            }
        }
        /**
         * Set the scale based on data min and max, user set min and max or options.
         *
         * @private
         * @function Highcharts.Axis#setScale
         *
         * @emits Highcharts.Axis#event:afterSetScale
         */
        setScale() {
            const axis = this, { coll, stacking } = axis;
            let isDirtyData = false, isXAxisDirty = false;
            axis.series.forEach((series) => {
                isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
                // When x axis is dirty, we need new data extremes for y as
                // well:
                isXAxisDirty = (isXAxisDirty ||
                    (series.xAxis && series.xAxis.isDirty) ||
                    false);
            });
            // Set the new axisLength
            axis.setAxisSize();
            const isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);
            // Do we really need to go through all this?
            if (isDirtyAxisLength ||
                isDirtyData ||
                isXAxisDirty ||
                axis.isLinked ||
                axis.forceRedraw ||
                axis.userMin !== (axis.old && axis.old.userMin) ||
                axis.userMax !== (axis.old && axis.old.userMax) ||
                axis.alignToOthers()) {
                if (stacking && coll === 'yAxis') {
                    stacking.buildStacks();
                }
                axis.forceRedraw = false;
                // #18066 delete minRange property to ensure that it will be
                // calculated again after dirty data in series
                if (!axis.userMinRange) {
                    axis.minRange = void 0;
                }
                // Get data extremes if needed
                axis.getSeriesExtremes();
                // Get fixed positions based on tickInterval
                axis.setTickInterval();
                if (stacking && coll === 'xAxis') {
                    stacking.buildStacks();
                }
                // Mark as dirty if it is not already set to dirty and extremes have
                // changed. #595.
                if (!axis.isDirty) {
                    axis.isDirty =
                        isDirtyAxisLength ||
                            axis.min !== axis.old?.min ||
                            axis.max !== axis.old?.max;
                }
            }
            else if (stacking) {
                stacking.cleanStacks();
            }
            // Recalculate all extremes object when the data has changed. It is
            // required when vertical panning is enabled.
            if (isDirtyData) {
                delete axis.allExtremes;
            }
            fireEvent$6(this, 'afterSetScale');
        }
        /**
         * Set the minimum and maximum of the axes after render time. If the
         * `startOnTick` and `endOnTick` options are true, the minimum and maximum
         * values are rounded off to the nearest tick. To prevent this, these
         * options can be set to false before calling setExtremes. Also, setExtremes
         * will not allow a range lower than the `minRange` option, which by default
         * is the range of five points.
         *
         * @sample highcharts/members/axis-setextremes/
         *         Set extremes from a button
         * @sample highcharts/members/axis-setextremes-datetime/
         *         Set extremes on a datetime axis
         * @sample highcharts/members/axis-setextremes-off-ticks/
         *         Set extremes off ticks
         * @sample stock/members/axis-setextremes/
         *         Set extremes in Highcharts Stock
         *
         * @function Highcharts.Axis#setExtremes
         *
         * @param {number} [newMin]
         * The new minimum value.
         *
         * @param {number} [newMax]
         * The new maximum value.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart or wait for an explicit call to
         * {@link Highcharts.Chart#redraw}
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]
         * Enable or modify animations.
         *
         * @param {*} [eventArguments]
         * Arguments to be accessed in event handler.
         *
         * @emits Highcharts.Axis#event:setExtremes
         */
        setExtremes(min, max, redraw = true, animation, eventArguments) {
            this.series.forEach((serie) => {
                delete serie.kdTree;
            });
            // Extend the arguments with min and max
            eventArguments = extend$a(eventArguments, { min, max });
            // Fire the event
            fireEvent$6(this, 'setExtremes', eventArguments, (e) => {
                this.userMin = e.min;
                this.userMax = e.max;
                this.eventArgs = e;
                if (redraw) {
                    this.chart.redraw(animation);
                }
            });
        }
        /**
         * Update the axis metrics.
         *
         * @private
         * @function Highcharts.Axis#setAxisSize
         */
        setAxisSize() {
            const chart = this.chart, options = this.options, 
            // [top, right, bottom, left]
            offsets = options.offsets || [0, 0, 0, 0], horiz = this.horiz, 
            // Check for percentage based input values. Rounding fixes problems
            // with column overflow and plot line filtering (#4898, #4899)
            width = this.width = Math.round(relativeLength$1(pick$a(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)), height = this.height = Math.round(relativeLength$1(pick$a(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)), top = this.top = Math.round(relativeLength$1(pick$a(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)), left = this.left = Math.round(relativeLength$1(pick$a(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
            // Expose basic values to use in Series object and navigator
            this.bottom = chart.chartHeight - height - top;
            this.right = chart.chartWidth - width - left;
            // Direction agnostic properties
            this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905
            /**
             * The position of the axis in terms of pixels, compared to the chart
             * edge. In a horizontal axis it is the same as `chart.plotLeft` unless
             * the axis is explicitly positioned, and in a default vertical axis it
             * is the same as `chart.plotTop`.
             *
             * @name Highcharts.Axis#pos
             * @type {number}
             */
            this.pos = horiz ? left : top; // Distance from SVG origin
        }
        /**
         * Get the current extremes for the axis.
         *
         * @sample highcharts/members/axis-getextremes/
         *         Report extremes by click on a button
         *
         * @function Highcharts.Axis#getExtremes
         *
         * @return {Highcharts.ExtremesObject}
         * An object containing extremes information.
         */
        getExtremes() {
            const axis = this, log = axis.logarithmic;
            return {
                min: log ?
                    correctFloat$1(log.lin2log(axis.min)) :
                    axis.min,
                max: log ?
                    correctFloat$1(log.lin2log(axis.max)) :
                    axis.max,
                dataMin: axis.dataMin,
                dataMax: axis.dataMax,
                userMin: axis.userMin,
                userMax: axis.userMax
            };
        }
        /**
         * Get the zero plane either based on zero or on the min or max value.
         * Used in bar and area plots.
         *
         * @function Highcharts.Axis#getThreshold
         *
         * @param {number} threshold
         * The threshold in axis values.
         *
         * @return {number}
         * The translated threshold position in terms of pixels, and corrected to
         * stay within the axis bounds.
         */
        getThreshold(threshold) {
            const axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;
            if (threshold === null || threshold === -Infinity) {
                threshold = realMin;
            }
            else if (threshold === Infinity) {
                threshold = realMax;
            }
            else if (realMin > threshold) {
                threshold = realMin;
            }
            else if (realMax < threshold) {
                threshold = realMax;
            }
            return axis.translate(threshold, 0, 1, 0, 1);
        }
        /**
         * Compute auto alignment for the axis label based on which side the axis is
         * on and the given rotation for the label.
         *
         * @private
         * @function Highcharts.Axis#autoLabelAlign
         *
         * @param {number} rotation
         * The rotation in degrees as set by either the `rotation` or `autoRotation`
         * options.
         *
         * @return {Highcharts.AlignValue}
         * Can be `"center"`, `"left"` or `"right"`.
         */
        autoLabelAlign(rotation) {
            const angle = (pick$a(rotation, 0) - (this.side * 90) + 720) % 360, evt = { align: 'center' };
            fireEvent$6(this, 'autoLabelAlign', evt, function (e) {
                if (angle > 15 && angle < 165) {
                    e.align = 'right';
                }
                else if (angle > 195 && angle < 345) {
                    e.align = 'left';
                }
            });
            return evt.align;
        }
        /**
         * Get the tick length and width for the axis based on axis options.
         *
         * @private
         * @function Highcharts.Axis#tickSize
         *
         * @param {string} [prefix]
         * 'tick' or 'minorTick'
         *
         * @return {Array<number,number>|undefined}
         * An array of tickLength and tickWidth
         */
        tickSize(prefix) {
            const options = this.options, tickWidth = pick$a(options[prefix === 'tick' ? 'tickWidth' : 'minorTickWidth'], 
            // Default to 1 on linear and datetime X axes
            prefix === 'tick' && this.isXAxis && !this.categories ? 1 : 0);
            let tickLength = options[prefix === 'tick' ? 'tickLength' : 'minorTickLength'], tickSize;
            if (tickWidth && tickLength) {
                // Negate the length
                if (options[prefix + 'Position'] === 'inside') {
                    tickLength = -tickLength;
                }
                tickSize = [tickLength, tickWidth];
            }
            const e = { tickSize };
            fireEvent$6(this, 'afterTickSize', e);
            return e.tickSize;
        }
        /**
         * Return the size of the labels.
         *
         * @private
         * @function Highcharts.Axis#labelMetrics
         */
        labelMetrics() {
            const renderer = this.chart.renderer, ticks = this.ticks, tick = ticks[Object.keys(ticks)[0]] || {};
            return this.chart.renderer.fontMetrics(tick.label ||
                tick.movedLabel ||
                renderer.box);
        }
        /**
         * Prevent the ticks from getting so close we can't draw the labels. On a
         * horizontal axis, this is handled by rotating the labels, removing ticks
         * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.
         *
         * @private
         * @function Highcharts.Axis#unsquish
         */
        unsquish() {
            const labelOptions = this.options.labels, padding = labelOptions.padding || 0, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) +
                this.max -
                this.min) /
                tickInterval), rotationOption = labelOptions.rotation, 
            // We don't know the actual rendered line height at this point, but
            // it defaults to 0.8em
            lineHeight = correctFloat$1(this.labelMetrics().h * 0.8), range = Math.max(this.max - this.min, 0), 
            // Return the multiple of tickInterval that is needed to avoid
            // collision
            getStep = function (spaceNeeded) {
                let step = (spaceNeeded + 2 * padding) / (slotSize || 1);
                step = step > 1 ? Math.ceil(step) : 1;
                // Guard for very small or negative angles (#9835)
                if (step * tickInterval > range &&
                    spaceNeeded !== Infinity &&
                    slotSize !== Infinity &&
                    range) {
                    step = Math.ceil(range / tickInterval);
                }
                return correctFloat$1(step * tickInterval);
            };
            let newTickInterval = tickInterval, rotation, bestScore = Number.MAX_VALUE, autoRotation;
            if (horiz) {
                if (!labelOptions.staggerLines) {
                    if (isNumber$7(rotationOption)) {
                        autoRotation = [rotationOption];
                    }
                    else if (slotSize < labelOptions.autoRotationLimit) {
                        autoRotation = labelOptions.autoRotation;
                    }
                }
                if (autoRotation) {
                    let step, score;
                    // Loop over the given autoRotation options, and determine which
                    // gives the best score. The best score is that with the lowest
                    // number of steps and a rotation closest to horizontal.
                    for (const rot of autoRotation) {
                        if (rot === rotationOption ||
                            (rot && rot >= -90 && rot <= 90)) { // #3891
                            step = getStep(Math.abs(lineHeight / Math.sin(deg2rad$2 * rot)));
                            score = step + Math.abs(rot / 360);
                            if (score < bestScore) {
                                bestScore = score;
                                rotation = rot;
                                newTickInterval = step;
                            }
                        }
                    }
                }
            }
            else { // #4411
                newTickInterval = getStep(lineHeight * 0.75);
            }
            this.autoRotation = autoRotation;
            this.labelRotation = pick$a(rotation, isNumber$7(rotationOption) ? rotationOption : 0);
            return labelOptions.step ? tickInterval : newTickInterval;
        }
        /**
         * Get the general slot width for labels/categories on this axis. This may
         * change between the pre-render (from Axis.getOffset) and the final tick
         * rendering and placement.
         *
         * @private
         * @function Highcharts.Axis#getSlotWidth
         *
         * @param {Highcharts.Tick} [tick] Optionally, calculate the slot width
         * basing on tick label. It is used in highcharts-3d module, where the slots
         * has different widths depending on perspective angles.
         *
         * @return {number}
         * The pixel width allocated to each axis label.
         */
        getSlotWidth(tick) {
            // #5086, #1580, #1931
            const chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];
            // Used by grid axis
            if (tick && isNumber$7(tick.slotWidth)) { // #13221, can be 0
                return tick.slotWidth;
            }
            if (horiz && labelOptions.step < 2) {
                if (labelOptions.rotation) { // #4415
                    return 0;
                }
                return ((this.staggerLines || 1) * this.len) / slotCount;
            }
            if (!horiz) {
                // #7028
                const cssWidth = labelOptions.style.width;
                if (cssWidth !== void 0) {
                    return parseInt(String(cssWidth), 10);
                }
                if (marginLeft) {
                    return marginLeft - chart.spacing[3];
                }
            }
            // Last resort, a fraction of the available size
            return chart.chartWidth * 0.33;
        }
        /**
         * Render the axis labels and determine whether ellipsis or rotation need to
         * be applied.
         *
         * @private
         * @function Highcharts.Axis#renderUnsquish
         */
        renderUnsquish() {
            const chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(1, Math.round(slotWidth - (horiz ?
                2 * (labelOptions.padding || 0) :
                labelOptions.distance || 0 // #21172
            ))), attr = {}, labelMetrics = this.labelMetrics(), textOverflowOption = labelStyleOptions.textOverflow;
            let commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;
            // Set rotation option unless it is "auto", like in gauges
            if (!isString$6(labelOptions.rotation)) {
                // #4443
                attr.rotation = labelOptions.rotation || 0;
            }
            // Get the longest label length
            tickPositions.forEach(function (tickPosition) {
                const tick = ticks[tickPosition];
                // Replace label - sorting animation
                if (tick.movedLabel) {
                    tick.replaceMovedLabel();
                }
                if (tick &&
                    tick.label &&
                    tick.label.textPxLength > maxLabelLength) {
                    maxLabelLength = tick.label.textPxLength;
                }
            });
            this.maxLabelLength = maxLabelLength;
            // Handle auto rotation on horizontal axis
            if (this.autoRotation) {
                // Apply rotation only if the label is too wide for the slot, and
                // the label is wider than its height.
                if (maxLabelLength > innerWidth &&
                    maxLabelLength > labelMetrics.h) {
                    attr.rotation = this.labelRotation;
                }
                else {
                    this.labelRotation = 0;
                }
                // Handle word-wrap or ellipsis on vertical axis
            }
            else if (slotWidth) {
                // For word-wrap or ellipsis
                commonWidth = innerWidth;
                if (!textOverflowOption) {
                    commonTextOverflow = 'clip';
                    // On vertical axis, only allow word wrap if there is room
                    // for more lines.
                    i = tickPositions.length;
                    while (!horiz && i--) {
                        pos = tickPositions[i];
                        label = ticks[pos].label;
                        if (label) {
                            // Reset ellipsis in order to get the correct
                            // bounding box (#4070)
                            if (label.styles.textOverflow === 'ellipsis') {
                                label.css({ textOverflow: 'clip' });
                                // Set the correct width in order to read
                                // the bounding box height (#4678, #5034)
                            }
                            else if (label.textPxLength > slotWidth) {
                                label.css({ width: slotWidth + 'px' });
                            }
                            if (label.getBBox().height > (this.len / tickPositions.length -
                                (labelMetrics.h - labelMetrics.f))) {
                                label.specificTextOverflow = 'ellipsis';
                            }
                        }
                    }
                }
            }
            // Add ellipsis if the label length is significantly longer than ideal
            if (attr.rotation) {
                commonWidth = (maxLabelLength > chart.chartHeight * 0.5 ?
                    chart.chartHeight * 0.33 :
                    maxLabelLength);
                if (!textOverflowOption) {
                    commonTextOverflow = 'ellipsis';
                }
            }
            // Set the explicit or automatic label alignment
            this.labelAlign = labelOptions.align ||
                this.autoLabelAlign(this.labelRotation);
            if (this.labelAlign) {
                attr.align = this.labelAlign;
            }
            // Apply general and specific CSS
            tickPositions.forEach(function (pos) {
                const tick = ticks[pos], label = tick && tick.label, widthOption = labelStyleOptions.width, css = {};
                if (label) {
                    // This needs to go before the CSS in old IE (#4502)
                    label.attr(attr);
                    if (tick.shortenLabel) {
                        tick.shortenLabel();
                    }
                    else if (commonWidth &&
                        !widthOption &&
                        // Setting width in this case messes with the bounding box
                        // (#7975)
                        labelStyleOptions.whiteSpace !== 'nowrap' &&
                        (
                        // Speed optimizing, #7656
                        commonWidth < label.textPxLength ||
                            // Resetting CSS, #4928
                            label.element.tagName === 'SPAN')) {
                        css.width = commonWidth + 'px';
                        if (!textOverflowOption) {
                            css.textOverflow = (label.specificTextOverflow ||
                                commonTextOverflow);
                        }
                        label.css(css);
                        // Reset previously shortened label (#8210)
                    }
                    else if (label.styles.width && !css.width && !widthOption) {
                        label.css({ width: null });
                    }
                    delete label.specificTextOverflow;
                    tick.rotation = attr.rotation;
                }
            }, this);
            // Note: Why is this not part of getLabelPosition?
            this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
        }
        /**
         * Return true if the axis has associated data.
         *
         * @function Highcharts.Axis#hasData
         *
         * @return {boolean}
         * True if the axis has associated visible series and those series have
         * either valid data points or explicit `min` and `max` settings.
         */
        hasData() {
            return this.series.some(function (s) {
                return s.hasData();
            }) ||
                (this.options.showEmpty &&
                    defined$7(this.min) &&
                    defined$7(this.max));
        }
        /**
         * Adds the title defined in axis.options.title.
         *
         * @function Highcharts.Axis#addTitle
         *
         * @param {boolean} [display]
         * Whether or not to display the title.
         */
        addTitle(display) {
            const axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options = axis.options, axisTitleOptions = options.title, styledMode = axis.chart.styledMode;
            let textAlign;
            if (!axis.axisTitle) {
                textAlign = axisTitleOptions.textAlign;
                if (!textAlign) {
                    textAlign = (horiz ? {
                        low: 'left',
                        middle: 'center',
                        high: 'right'
                    } : {
                        low: opposite ? 'right' : 'left',
                        middle: 'center',
                        high: opposite ? 'left' : 'right'
                    })[axisTitleOptions.align];
                }
                axis.axisTitle = renderer
                    .text(axisTitleOptions.text || '', 0, 0, axisTitleOptions.useHTML)
                    .attr({
                    zIndex: 7,
                    rotation: axisTitleOptions.rotation || 0,
                    align: textAlign
                })
                    .addClass('highcharts-axis-title');
                // #7814, don't mutate style option
                if (!styledMode) {
                    axis.axisTitle.css(merge$9(axisTitleOptions.style));
                }
                axis.axisTitle.add(axis.axisGroup);
                axis.axisTitle.isNew = true;
            }
            // Max width defaults to the length of the axis
            if (!styledMode &&
                !axisTitleOptions.style.width &&
                !axis.isRadial) {
                axis.axisTitle.css({
                    width: axis.len + 'px'
                });
            }
            // Hide or show the title depending on whether showEmpty is set
            axis.axisTitle[display ? 'show' : 'hide'](display);
        }
        /**
         * Generates a tick for initial positioning.
         *
         * @private
         * @function Highcharts.Axis#generateTick
         *
         * @param {number} pos
         * The tick position in axis values.
         *
         * @param {number} [i]
         * The index of the tick in {@link Axis.tickPositions}.
         */
        generateTick(pos) {
            const axis = this, ticks = axis.ticks;
            if (!ticks[pos]) {
                ticks[pos] = new Tick(axis, pos);
            }
            else {
                ticks[pos].addLabel(); // Update labels depending on tick interval
            }
        }
        /**
         * Create the axisGroup and gridGroup elements on first iteration.
         *
         * @private
         * @function Highcharts.Axis#getOffset
         *
         * @emits Highcharts.Axis#event:afterGetOffset
         */
        createGroups() {
            const { axisParent, // Used in color axis
            chart, coll, options } = this, renderer = chart.renderer;
            const createGroup = (name, suffix, zIndex) => renderer.g(name)
                .attr({ zIndex })
                .addClass(`highcharts-${coll.toLowerCase()}${suffix} ` +
                (this.isRadial ? `highcharts-radial-axis${suffix} ` : '') +
                (options.className || ''))
                .add(axisParent);
            if (!this.axisGroup) {
                this.gridGroup = createGroup('grid', '-grid', options.gridZIndex);
                this.axisGroup = createGroup('axis', '', options.zIndex);
                this.labelGroup = createGroup('axis-labels', '-labels', options.labels.zIndex);
            }
        }
        /**
         * Render the tick labels to a preliminary position to get their sizes
         *
         * @private
         * @function Highcharts.Axis#getOffset
         *
         * @emits Highcharts.Axis#event:afterGetOffset
         */
        getOffset() {
            const axis = this, { chart, horiz, options, side, ticks, tickPositions, coll } = axis, invertedSide = (chart.inverted && !axis.isZAxis ?
                [1, 0, 3, 2][side] :
                side), hasData = axis.hasData(), axisTitleOptions = options.title, labelOptions = options.labels, hasCrossing = isNumber$7(options.crossing), axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side];
            let showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, // Reset
            labelOffsetPadded, lineHeightCorrection;
            // For reuse in Axis.render
            axis.showAxis = showAxis = hasData || options.showEmpty;
            // Set/reset staggerLines
            axis.staggerLines = (axis.horiz && labelOptions.staggerLines) || void 0;
            axis.createGroups();
            if (hasData || axis.isLinked) {
                // Generate ticks
                tickPositions.forEach(function (pos) {
                    axis.generateTick(pos);
                });
                axis.renderUnsquish();
                // Left side must be align: right and right side must
                // have align: left for labels
                axis.reserveSpaceDefault = (side === 0 ||
                    side === 2 ||
                    { 1: 'left', 3: 'right' }[side] === axis.labelAlign);
                if (pick$a(labelOptions.reserveSpace, hasCrossing ? false : null, axis.labelAlign === 'center' ? true : null, axis.reserveSpaceDefault)) {
                    tickPositions.forEach(function (pos) {
                        // Get the highest offset
                        labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
                    });
                }
                if (axis.staggerLines) {
                    labelOffset *= axis.staggerLines;
                }
                axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
            }
            else { // Doesn't have data
                objectEach$6(ticks, function (tick, n) {
                    tick.destroy();
                    delete ticks[n];
                });
            }
            if (axisTitleOptions?.text &&
                axisTitleOptions.enabled !== false) {
                axis.addTitle(showAxis);
                if (showAxis &&
                    !hasCrossing &&
                    axisTitleOptions.reserveSpace !== false) {
                    axis.titleOffset = titleOffset =
                        axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
                    titleOffsetOption = axisTitleOptions.offset;
                    titleMargin = defined$7(titleOffsetOption) ?
                        0 :
                        pick$a(axisTitleOptions.margin, horiz ? 5 : 10);
                }
            }
            // Render the axis line
            axis.renderLine();
            // Handle automatic or user set offset
            axis.offset = directionFactor * pick$a(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
            axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // Polar
            if (side === 0) {
                lineHeightCorrection = -axis.labelMetrics().h;
            }
            else if (side === 2) {
                lineHeightCorrection = axis.tickRotCorr.y;
            }
            else {
                lineHeightCorrection = 0;
            }
            // Find the padded label offset
            labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
            if (labelOffset) {
                labelOffsetPadded -= lineHeightCorrection;
                labelOffsetPadded += directionFactor * (horiz ?
                    pick$a(labelOptions.y, axis.tickRotCorr.y +
                        directionFactor * labelOptions.distance) :
                    pick$a(labelOptions.x, directionFactor * labelOptions.distance));
            }
            axis.axisTitleMargin = pick$a(titleOffsetOption, labelOffsetPadded);
            if (axis.getMaxLabelDimensions) {
                axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);
            }
            // Due to GridAxis.tickSize, tickSize should be calculated after ticks
            // has rendered.
            if (coll !== 'colorAxis' && clipOffset) {
                const tickSize = this.tickSize('tick');
                axisOffset[side] = Math.max(axisOffset[side], (axis.axisTitleMargin || 0) + titleOffset +
                    directionFactor * axis.offset, labelOffsetPadded, // #3027
                tickPositions && tickPositions.length && tickSize ?
                    tickSize[0] + directionFactor * axis.offset :
                    0 // #4866
                );
                // Decide the clipping needed to keep the graph inside
                // the plot area and axis lines
                const clip = !axis.axisLine || options.offset ?
                    0 :
                    // #4308, #4371
                    axis.axisLine.strokeWidth() / 2;
                clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
            }
            fireEvent$6(this, 'afterGetOffset');
        }
        /**
         * Internal function to get the path for the axis line. Extended for polar
         * charts.
         *
         * @function Highcharts.Axis#getLinePath
         *
         * @param {number} lineWidth
         * The line width in pixels.
         *
         * @return {Highcharts.SVGPathArray}
         * The SVG path definition in array form.
         */
        getLinePath(lineWidth) {
            const chart = this.chart, opposite = this.opposite, offset = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset, lineTop = chart.chartHeight - this.bottom -
                (opposite ? this.height : 0) + offset;
            if (opposite) {
                lineWidth *= -1; // Crispify the other way - #1480, #1687
            }
            return chart.renderer
                .crispLine([
                [
                    'M',
                    horiz ?
                        this.left :
                        lineLeft,
                    horiz ?
                        lineTop :
                        this.top
                ],
                [
                    'L',
                    horiz ?
                        chart.chartWidth - this.right :
                        lineLeft,
                    horiz ?
                        lineTop :
                        chart.chartHeight - this.bottom
                ]
            ], lineWidth);
        }
        /**
         * Render the axis line. Called internally when rendering and redrawing the
         * axis.
         *
         * @function Highcharts.Axis#renderLine
         */
        renderLine() {
            if (!this.axisLine) {
                this.axisLine = this.chart.renderer.path()
                    .addClass('highcharts-axis-line')
                    .add(this.axisGroup);
                if (!this.chart.styledMode) {
                    this.axisLine.attr({
                        stroke: this.options.lineColor,
                        'stroke-width': this.options.lineWidth,
                        zIndex: 7
                    });
                }
            }
        }
        /**
         * Position the axis title.
         *
         * @private
         * @function Highcharts.Axis#getTitlePosition
         *
         * @return {Highcharts.PositionObject}
         * X and Y positions for the title.
         */
        getTitlePosition(axisTitle) {
            // Compute anchor points for each of the title align options
            const horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, fontMetrics = this.chart.renderer.fontMetrics(axisTitle), 
            // The part of a multiline text that is below the baseline of the
            // first line. Subtract 1 to preserve pixel-perfectness from the
            // old behaviour (v5.0.12), where only one line was allowed.
            textHeightOvershoot = axisTitle ? Math.max(axisTitle.getBBox(false, 0).height - fontMetrics.h - 1, 0) : 0, 
            // The position in the length direction of the axis
            alongAxis = ({
                low: margin + (horiz ? 0 : axisLength),
                middle: margin + axisLength / 2,
                high: margin + (horiz ? axisLength : 0)
            })[axisTitleOptions.align], 
            // The position in the perpendicular direction of the axis
            offAxis = (horiz ? axisTop + this.height : axisLeft) +
                (horiz ? 1 : -1) * // Horizontal axis reverses the margin
                    (opposite ? -1 : 1) * // So does opposite axes
                    (this.axisTitleMargin || 0) +
                [
                    -textHeightOvershoot, // Top
                    textHeightOvershoot, // Right
                    fontMetrics.f, // Bottom
                    -textHeightOvershoot // Left
                ][this.side], titlePosition = {
                x: horiz ?
                    alongAxis + xOption :
                    offAxis + (opposite ? this.width : 0) + offset + xOption,
                y: horiz ?
                    offAxis + yOption - (opposite ? this.height : 0) + offset :
                    alongAxis + yOption
            };
            fireEvent$6(this, 'afterGetTitlePosition', { titlePosition: titlePosition });
            return titlePosition;
        }
        /**
         * Render a minor tick into the given position. If a minor tick already
         * exists in this position, move it.
         *
         * @function Highcharts.Axis#renderMinorTick
         *
         * @param {number} pos
         * The position in axis values.
         *
         * @param {boolean} slideIn
         * Whether the tick should animate in from last computed position
         */
        renderMinorTick(pos, slideIn) {
            const axis = this;
            const minorTicks = axis.minorTicks;
            if (!minorTicks[pos]) {
                minorTicks[pos] = new Tick(axis, pos, 'minor');
            }
            // Render new ticks in old position
            if (slideIn && minorTicks[pos].isNew) {
                minorTicks[pos].render(null, true);
            }
            minorTicks[pos].render(null, false, 1);
        }
        /**
         * Render a major tick into the given position. If a tick already exists
         * in this position, move it.
         *
         * @function Highcharts.Axis#renderTick
         *
         * @param {number} pos
         * The position in axis values.
         *
         * @param {number} i
         * The tick index.
         *
         * @param {boolean} slideIn
         * Whether the tick should animate in from last computed position
         */
        renderTick(pos, i, slideIn) {
            const axis = this, isLinked = axis.isLinked, ticks = axis.ticks;
            // Linked axes need an extra check to find out if
            if (!isLinked ||
                (pos >= axis.min && pos <= axis.max) ||
                (axis.grid && axis.grid.isColumn)) {
                if (!ticks[pos]) {
                    ticks[pos] = new Tick(axis, pos);
                }
                // NOTE this seems like overkill. Could be handled in tick.render by
                // setting old position in attr, then set new position in animate.
                // render new ticks in old position
                if (slideIn && ticks[pos].isNew) {
                    // Start with negative opacity so that it is visible from
                    // halfway into the animation
                    ticks[pos].render(i, true, -1);
                }
                ticks[pos].render(i);
            }
        }
        /**
         * Render the axis.
         *
         * @private
         * @function Highcharts.Axis#render
         *
         * @emits Highcharts.Axis#event:afterRender
         */
        render() {
            const axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, crossing = options.crossing, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject$5(renderer.globalAnimation);
            let from, to;
            // Reset
            axis.labelEdge.length = 0;
            axis.overlap = false;
            // Mark all elements inActive before we go over and mark the active ones
            [ticks, minorTicks, alternateBands].forEach(function (coll) {
                objectEach$6(coll, function (tick) {
                    tick.isActive = false;
                });
            });
            // Crossing
            if (isNumber$7(crossing)) {
                const otherAxis = this.isXAxis ? chart.yAxis[0] : chart.xAxis[0], directionFactor = [1, -1, -1, 1][this.side];
                if (otherAxis) {
                    let px = otherAxis.toPixels(crossing, true);
                    if (axis.horiz) {
                        px = otherAxis.len - px;
                    }
                    axis.offset = directionFactor * px;
                }
            }
            // If the series has data draw the ticks. Else only the line and title
            if (axis.hasData() || isLinked) {
                const slideInTicks = axis.chart.hasRendered &&
                    axis.old && isNumber$7(axis.old.min);
                // Minor ticks
                if (axis.minorTickInterval && !axis.categories) {
                    axis.getMinorTickPositions().forEach(function (pos) {
                        axis.renderMinorTick(pos, slideInTicks);
                    });
                }
                // Major ticks. Pull out the first item and render it last so that
                // we can get the position of the neighbour label. #808.
                if (tickPositions.length) { // #1300
                    tickPositions.forEach(function (pos, i) {
                        axis.renderTick(pos, i, slideInTicks);
                    });
                    // In a categorized axis, the tick marks are displayed
                    // between labels. So we need to add a tick mark and
                    // grid line at the left edge of the X axis.
                    if (tickmarkOffset && (axis.min === 0 || axis.single)) {
                        if (!ticks[-1]) {
                            ticks[-1] = new Tick(axis, -1, null, true);
                        }
                        ticks[-1].render(-1);
                    }
                }
                // Alternate grid color
                if (alternateGridColor) {
                    tickPositions.forEach(function (pos, i) {
                        to = typeof tickPositions[i + 1] !== 'undefined' ?
                            tickPositions[i + 1] + tickmarkOffset :
                            axis.max - tickmarkOffset;
                        if (i % 2 === 0 &&
                            pos < axis.max &&
                            to <= axis.max + (chart.polar ?
                                -tickmarkOffset :
                                tickmarkOffset)) { // #2248, #4660
                            if (!alternateBands[pos]) {
                                // Should be imported from PlotLineOrBand.js, but
                                // the dependency cycle with axis is a problem
                                alternateBands[pos] = new H.PlotLineOrBand(axis, {});
                            }
                            from = pos + tickmarkOffset; // #949
                            alternateBands[pos].options = {
                                from: log ? log.lin2log(from) : from,
                                to: log ? log.lin2log(to) : to,
                                color: alternateGridColor,
                                className: 'highcharts-alternate-grid'
                            };
                            alternateBands[pos].render();
                            alternateBands[pos].isActive = true;
                        }
                    });
                }
                // Custom plot lines and bands
                if (!axis._addedPlotLB) { // Only first time
                    axis._addedPlotLB = true;
                    (options.plotLines || [])
                        .concat(options.plotBands || [])
                        .forEach(function (plotLineOptions) {
                        axis
                            .addPlotBandOrLine(plotLineOptions);
                    });
                }
            } // End if hasData
            // Remove inactive ticks
            [ticks, minorTicks, alternateBands].forEach(function (coll) {
                const forDestruction = [], delay = animation.duration, destroyInactiveItems = function () {
                    let i = forDestruction.length;
                    while (i--) {
                        // When resizing rapidly, the same items
                        // may be destroyed in different timeouts,
                        // or the may be reactivated
                        if (coll[forDestruction[i]] &&
                            !coll[forDestruction[i]].isActive) {
                            coll[forDestruction[i]].destroy();
                            delete coll[forDestruction[i]];
                        }
                    }
                };
                objectEach$6(coll, function (tick, pos) {
                    if (!tick.isActive) {
                        // Render to zero opacity
                        tick.render(pos, false, 0);
                        tick.isActive = false;
                        forDestruction.push(pos);
                    }
                });
                // When the objects are finished fading out, destroy them
                syncTimeout$4(destroyInactiveItems, coll === alternateBands ||
                    !chart.hasRendered ||
                    !delay ?
                    0 :
                    delay);
            });
            // Set the axis line path
            if (axisLine) {
                axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
                    d: this.getLinePath(axisLine.strokeWidth())
                });
                axisLine.isPlaced = true;
                // Show or hide the line depending on options.showEmpty
                axisLine[showAxis ? 'show' : 'hide'](showAxis);
            }
            if (axisTitle && showAxis) {
                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](axis.getTitlePosition(axisTitle));
                axisTitle.isNew = false;
            }
            // Stacked totals:
            if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {
                axis.stacking.renderStackTotals();
            }
            // End stacked totals
            // Record old scaling for updating/animation. Pinch base must be
            // preserved until the pinch ends.
            axis.old = {
                len: axis.len,
                max: axis.max,
                min: axis.min,
                transA: axis.transA,
                userMax: axis.userMax,
                userMin: axis.userMin
            };
            axis.isDirty = false;
            fireEvent$6(this, 'afterRender');
        }
        /**
         * Redraw the axis to reflect changes in the data or axis extremes. Called
         * internally from Highcharts.Chart#redraw.
         *
         * @private
         * @function Highcharts.Axis#redraw
         */
        redraw() {
            if (this.visible) {
                // Render the axis
                this.render();
                // Move plot lines and bands
                this.plotLinesAndBands.forEach(function (plotLine) {
                    plotLine.render();
                });
            }
            // Mark associated series as dirty and ready for redraw
            this.series.forEach(function (series) {
                series.isDirty = true;
            });
        }
        /**
         * Returns an array of axis properties, that should be untouched during
         * reinitialization.
         *
         * @private
         * @function Highcharts.Axis#getKeepProps
         */
        getKeepProps() {
            return (this.keepProps || Axis.keepProps);
        }
        /**
         * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint
         * to fully remove the axis.
         *
         * @private
         * @function Highcharts.Axis#destroy
         *
         * @param {boolean} [keepEvents]
         * Whether to preserve events, used internally in Axis.update.
         */
        destroy(keepEvents) {
            const axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;
            fireEvent$6(this, 'destroy', { keepEvents: keepEvents });
            // Remove the events
            if (!keepEvents) {
                removeEvent$4(axis);
            }
            // Destroy collections
            [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function (coll) {
                destroyObjectProperties$2(coll);
            });
            if (plotLinesAndBands) {
                let i = plotLinesAndBands.length;
                while (i--) { // #1975
                    plotLinesAndBands[i].destroy();
                }
            }
            // Destroy elements
            [
                'axisLine', 'axisTitle', 'axisGroup',
                'gridGroup', 'labelGroup', 'cross', 'scrollbar'
            ].forEach(function (prop) {
                if (axis[prop]) {
                    axis[prop] = axis[prop].destroy();
                }
            });
            // Destroy each generated group for plotlines and plotbands
            for (const plotGroup in axis.plotLinesAndBandsGroups) { // eslint-disable-line guard-for-in
                axis.plotLinesAndBandsGroups[plotGroup] =
                    axis.plotLinesAndBandsGroups[plotGroup].destroy();
            }
            // Delete all properties and fall back to the prototype.
            objectEach$6(axis, function (val, key) {
                if (axis.getKeepProps().indexOf(key) === -1) {
                    delete axis[key];
                }
            });
            this.eventOptions = eventOptions;
        }
        /**
         * Internal function to draw a crosshair.
         *
         * @function Highcharts.Axis#drawCrosshair
         *
         * @param {Highcharts.PointerEventObject} [e]
         * The event arguments from the modified pointer event, extended with
         * `chartX` and `chartY`
         *
         * @param {Highcharts.Point} [point]
         * The Point object if the crosshair snaps to points.
         *
         * @emits Highcharts.Axis#event:afterDrawCrosshair
         * @emits Highcharts.Axis#event:drawCrosshair
         */
        drawCrosshair(e, point) {
            const options = this.crosshair, snap = pick$a(options && options.snap, true), chart = this.chart;
            let path, pos, categorized, graphic = this.cross, crossOptions;
            fireEvent$6(this, 'drawCrosshair', { e: e, point: point });
            // Use last available event when updating non-snapped crosshairs without
            // mouse interaction (#5287)
            if (!e) {
                e = this.cross && this.cross.e;
            }
            if (
            // Disabled in options
            !options ||
                // Snap
                ((defined$7(point) || !snap) === false)) {
                this.hideCrosshair();
            }
            else {
                // Get the path
                if (!snap) {
                    pos = e &&
                        (this.horiz ?
                            e.chartX - this.pos :
                            this.len - e.chartY + this.pos);
                }
                else if (defined$7(point)) {
                    // #3834
                    pos = pick$a(this.coll !== 'colorAxis' ?
                        point.crosshairPos : // 3D axis extension
                        null, this.isXAxis ?
                        point.plotX :
                        this.len - point.plotY);
                }
                if (defined$7(pos)) {
                    crossOptions = {
                        // Value, only used on radial
                        value: point && (this.isXAxis ?
                            point.x :
                            pick$a(point.stackY, point.y)),
                        translatedValue: pos
                    };
                    if (chart.polar) {
                        // Additional information required for crosshairs in
                        // polar chart
                        extend$a(crossOptions, {
                            isCrosshair: true,
                            chartX: e && e.chartX,
                            chartY: e && e.chartY,
                            point: point
                        });
                    }
                    path = this.getPlotLinePath(crossOptions) ||
                        null; // #3189
                }
                if (!defined$7(path)) {
                    this.hideCrosshair();
                    return;
                }
                categorized = this.categories && !this.isRadial;
                // Draw the cross
                if (!graphic) {
                    this.cross = graphic = chart.renderer
                        .path()
                        .addClass('highcharts-crosshair highcharts-crosshair-' +
                        (categorized ? 'category ' : 'thin ') +
                        (options.className || ''))
                        .attr({
                        zIndex: pick$a(options.zIndex, 2)
                    })
                        .add();
                    // Presentational attributes
                    if (!chart.styledMode) {
                        graphic.attr({
                            stroke: options.color ||
                                (categorized ?
                                    Color
                                        .parse("#ccd3ff" /* Palette.highlightColor20 */)
                                        .setOpacity(0.25)
                                        .get() :
                                    "#cccccc" /* Palette.neutralColor20 */),
                            'stroke-width': pick$a(options.width, 1)
                        }).css({
                            'pointer-events': 'none'
                        });
                        if (options.dashStyle) {
                            graphic.attr({
                                dashstyle: options.dashStyle
                            });
                        }
                    }
                }
                graphic.show().attr({
                    d: path
                });
                if (categorized && !options.width) {
                    graphic.attr({
                        'stroke-width': this.transA
                    });
                }
                this.cross.e = e;
            }
            fireEvent$6(this, 'afterDrawCrosshair', { e: e, point: point });
        }
        /**
         * Hide the crosshair if visible.
         *
         * @function Highcharts.Axis#hideCrosshair
         */
        hideCrosshair() {
            if (this.cross) {
                this.cross.hide();
            }
            fireEvent$6(this, 'afterHideCrosshair');
        }
        /**
         * Update an axis object with a new set of options. The options are merged
         * with the existing options, so only new or altered options need to be
         * specified.
         *
         * @sample highcharts/members/axis-update/
         *         Axis update demo
         *
         * @function Highcharts.Axis#update
         *
         * @param {Highcharts.AxisOptions} options
         * The new options that will be merged in with existing options on the axis.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart after the axis is altered. If doing more
         * operations on the chart, it is a good idea to set redraw to false and
         * call {@link Chart#redraw} after.
         */
        update(options, redraw) {
            const chart = this.chart;
            options = merge$9(this.userOptions, options);
            this.destroy(true);
            this.init(chart, options);
            chart.isDirtyBox = true;
            if (pick$a(redraw, true)) {
                chart.redraw();
            }
        }
        /**
         * Remove the axis from the chart.
         *
         * @sample highcharts/members/chart-addaxis/
         *         Add and remove axes
         *
         * @function Highcharts.Axis#remove
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart following the remove.
         */
        remove(redraw) {
            const chart = this.chart, coll = this.coll, axisSeries = this.series;
            let i = axisSeries.length;
            // Remove associated series (#2687)
            while (i--) {
                if (axisSeries[i]) {
                    axisSeries[i].remove(false);
                }
            }
            // Remove the axis
            erase$4(chart.axes, this);
            erase$4(chart[coll] || [], this);
            chart.orderItems(coll);
            this.destroy();
            chart.isDirtyBox = true;
            if (pick$a(redraw, true)) {
                chart.redraw();
            }
        }
        /**
         * Update the axis title by options after render time.
         *
         * @sample highcharts/members/axis-settitle/
         *         Set a new Y axis title
         *
         * @function Highcharts.Axis#setTitle
         *
         * @param {Highcharts.AxisTitleOptions} titleOptions
         * The additional title options.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart after setting the title.
         */
        setTitle(titleOptions, redraw) {
            this.update({ title: titleOptions }, redraw);
        }
        /**
         * Set new axis categories and optionally redraw.
         *
         * @sample highcharts/members/axis-setcategories/
         *         Set categories by click on a button
         *
         * @function Highcharts.Axis#setCategories
         *
         * @param {Array<string>} categories
         * The new categories.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart.
         */
        setCategories(categories, redraw) {
            this.update({ categories: categories }, redraw);
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    // Properties to survive after destroy, needed for Axis.update (#4317,
    // #5773, #5881).
    Axis.keepProps = [
        'coll',
        'extKey',
        'hcEvents',
        'len',
        'names',
        'series',
        'userMax',
        'userMin'
    ];

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  Namespace
     *
     * */
    var RendererRegistry;
    (function (RendererRegistry) {
        /* *
         *
         *  Constants
         *
         * */
        RendererRegistry.rendererTypes = {};
        /* *
         *
         *  Variables
         *
         * */
        let defaultRenderer;
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Gets a registered renderer class. If no renderer type is provided or the
         * requested renderer was not founded, the default renderer is returned.
         *
         * @param {string} [rendererType]
         * Renderer type or the default renderer.
         *
         * @return {Highcharts.Class<Highcharts.SVGRenderer>}
         * Returns the requested renderer class or the default renderer class.
         */
        function getRendererType(rendererType = defaultRenderer) {
            return (RendererRegistry.rendererTypes[rendererType] || RendererRegistry.rendererTypes[defaultRenderer]);
        }
        RendererRegistry.getRendererType = getRendererType;
        /**
         * Register a renderer class.
         *
         * @param {string} rendererType
         * Renderer type to register.
         *
         * @param {Highcharts.Class<Highcharts.SVGRenderer>} rendererClass
         * Returns the requested renderer class or the default renderer class.
         *
         * @param {boolean} setAsDefault
         * Sets the renderer class as the default renderer.
         */
        function registerRendererType(rendererType, rendererClass, setAsDefault) {
            RendererRegistry.rendererTypes[rendererType] = rendererClass;
            if (!defaultRenderer || setAsDefault) {
                defaultRenderer = rendererType;
                H.Renderer = rendererClass; // Compatibility
            }
        }
        RendererRegistry.registerRendererType = registerRendererType;
    })(RendererRegistry || (RendererRegistry = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var RendererRegistry$1 = RendererRegistry;

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { extend: extend$9, merge: merge$8, pick: pick$9 } = Utilities;
    /* *
     *
     *  Namespace
     *
     * */
    var LegendSymbol;
    (function (LegendSymbol) {
        /* *
        *
        *  Functions
        *
        * */
        /**
         * Draw a line, a point marker and an area in the legend.
         *
         * @private
         * @function Highcharts.LegendSymbolMixin.areaMarker
         *
         * @param {Highcharts.Legend} legend
         * The legend object.
         */
        function areaMarker(legend, item) {
            lineMarker.call(this, legend, item, true);
        }
        LegendSymbol.areaMarker = areaMarker;
        /**
         * Draw a line and a point marker in the legend.
         *
         * @private
         * @function Highcharts.LegendSymbolMixin.lineMarker
         *
         * @param {Highcharts.Legend} legend
         * The legend object.
         */
        function lineMarker(legend, item, hasArea) {
            const legendItem = this.legendItem = this.legendItem || {}, { chart, options } = this, { baseline = 0, symbolWidth, symbolHeight } = legend, symbol = this.symbol || 'circle', generalRadius = symbolHeight / 2, renderer = chart.renderer, legendItemGroup = legendItem.group, verticalCenter = baseline - Math.round((legend.fontMetrics?.b || symbolHeight) *
                // Render line and marker slightly higher to make room for the
                // area
                (hasArea ? 0.4 : 0.3)), attr = {};
            let legendSymbol, markerOptions = options.marker, lineSizer = 0;
            // Draw the line
            if (!chart.styledMode) {
                attr['stroke-width'] = Math.min(options.lineWidth || 0, 24);
                if (options.dashStyle) {
                    attr.dashstyle = options.dashStyle;
                }
                else if (options.linecap !== 'square') {
                    attr['stroke-linecap'] = 'round';
                }
            }
            legendItem.line = renderer
                .path()
                .addClass('highcharts-graph')
                .attr(attr)
                .add(legendItemGroup);
            if (hasArea) {
                legendItem.area = renderer
                    .path()
                    .addClass('highcharts-area')
                    .add(legendItemGroup);
            }
            if (attr['stroke-linecap']) {
                lineSizer = Math.min(legendItem.line.strokeWidth(), symbolWidth) / 2;
            }
            if (symbolWidth) {
                const d = [
                    ['M', lineSizer, verticalCenter],
                    ['L', symbolWidth - lineSizer, verticalCenter]
                ];
                legendItem.line.attr({ d });
                legendItem.area?.attr({
                    d: [
                        ...d,
                        ['L', symbolWidth - lineSizer, baseline],
                        ['L', lineSizer, baseline]
                    ]
                });
            }
            // Draw the marker
            if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
                // Do not allow the marker to be larger than the symbolHeight
                let radius = Math.min(pick$9(markerOptions.radius, generalRadius), generalRadius);
                // Restrict symbol markers size
                if (symbol.indexOf('url') === 0) {
                    markerOptions = merge$8(markerOptions, {
                        width: symbolHeight,
                        height: symbolHeight
                    });
                    radius = 0;
                }
                legendItem.symbol = legendSymbol = renderer
                    .symbol(symbol, (symbolWidth / 2) - radius, verticalCenter - radius, 2 * radius, 2 * radius, extend$9({ context: 'legend' }, markerOptions))
                    .addClass('highcharts-point')
                    .add(legendItemGroup);
                legendSymbol.isMarker = true;
            }
        }
        LegendSymbol.lineMarker = lineMarker;
        /**
         * Get the series' symbol in the legend.
         *
         * This method should be overridable to create custom symbols through
         * Highcharts.seriesTypes[type].prototype.drawLegendSymbol.
         *
         * @private
         * @function Highcharts.LegendSymbolMixin.rectangle
         *
         * @param {Highcharts.Legend} legend
         * The legend object
         *
         * @param {Highcharts.Point|Highcharts.Series} item
         * The series (this) or point
         */
        function rectangle(legend, item) {
            const legendItem = item.legendItem || {}, options = legend.options, symbolHeight = legend.symbolHeight, square = options.squareSymbol, symbolWidth = square ? symbolHeight : legend.symbolWidth;
            legendItem.symbol = this.chart.renderer
                .rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, // #3988
            symbolWidth, symbolHeight, pick$9(legend.options.symbolRadius, symbolHeight / 2))
                .addClass('highcharts-point')
                .attr({
                zIndex: 3
            })
                .add(legendItem.group);
        }
        LegendSymbol.rectangle = rectangle;
    })(LegendSymbol || (LegendSymbol = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var LegendSymbol$1 = LegendSymbol;

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { SVG_NS: SVG_NS$3, win: win$5 } = H;
    const { attr: attr$4, createElement: createElement$3, css: css$3, error: error$2, isFunction: isFunction$2, isString: isString$5, objectEach: objectEach$5, splat: splat$2 } = Utilities;
    const { trustedTypes } = win$5;
    /* *
     *
     *  Constants
     *
     * */
    // Create the trusted type policy. This should not be exposed.
    const trustedTypesPolicy = (trustedTypes &&
        isFunction$2(trustedTypes.createPolicy) &&
        trustedTypes.createPolicy('highcharts', {
            createHTML: (s) => s
        }));
    const emptyHTML = trustedTypesPolicy ?
        trustedTypesPolicy.createHTML('') :
        '';
    // IE9 and PhantomJS are only able to parse XML.
    const hasValidDOMParser = (function () {
        try {
            return Boolean(new DOMParser().parseFromString(emptyHTML, 'text/html'));
        }
        catch (e) {
            return false;
        }
    }());
    /* *
     *
     *  Class
     *
     * */
    /**
     * The AST class represents an abstract syntax tree of HTML or SVG content. It
     * can take HTML as an argument, parse it, optionally transform it to SVG, then
     * perform sanitation before inserting it into the DOM.
     *
     * @class
     * @name Highcharts.AST
     *
     * @param {string|Array<Highcharts.ASTNode>} source
     * Either an HTML string or an ASTNode list to populate the tree.
     */
    class AST {
        /* *
         *
         *  Static Functions
         *
         * */
        /**
         * Filter an object of SVG or HTML attributes against the allow list.
         *
         * @static
         *
         * @function Highcharts.AST#filterUserAttributes
         *
         * @param {Highcharts.SVGAttributes} attributes The attributes to filter
         *
         * @return {Highcharts.SVGAttributes}
         * The filtered attributes
         */
        static filterUserAttributes(attributes) {
            objectEach$5(attributes, (val, key) => {
                let valid = true;
                if (AST.allowedAttributes.indexOf(key) === -1) {
                    valid = false;
                }
                if (['background', 'dynsrc', 'href', 'lowsrc', 'src']
                    .indexOf(key) !== -1) {
                    valid = isString$5(val) && AST.allowedReferences.some((ref) => val.indexOf(ref) === 0);
                }
                if (!valid) {
                    error$2(33, false, void 0, {
                        'Invalid attribute in config': `${key}`
                    });
                    delete attributes[key];
                }
                // #17753, < is not allowed in SVG attributes
                if (isString$5(val) && attributes[key]) {
                    attributes[key] = val.replace(/</g, '&lt;');
                }
            });
            return attributes;
        }
        static parseStyle(style) {
            return style
                .split(';')
                .reduce((styles, line) => {
                const pair = line.split(':').map((s) => s.trim()), key = pair.shift();
                if (key && pair.length) {
                    styles[key.replace(/-([a-z])/g, (g) => g[1].toUpperCase())] = pair.join(':'); // #17146
                }
                return styles;
            }, {});
        }
        /**
         * Utility function to set html content for an element by passing in a
         * markup string. The markup is safely parsed by the AST class to avoid
         * XSS vulnerabilities. This function should be used instead of setting
         * `innerHTML` in all cases where the content is not fully trusted.
         *
         * @static
         * @function Highcharts.AST#setElementHTML
         *
         * @param {SVGDOMElement|HTMLDOMElement} el
         * Node to set content of.
         *
         * @param {string} html
         * Markup string
         */
        static setElementHTML(el, html) {
            el.innerHTML = AST.emptyHTML; // Clear previous
            if (html) {
                const ast = new AST(html);
                ast.addToDOM(el);
            }
        }
        /* *
         *
         *  Constructor
         *
         * */
        // Construct an AST from HTML markup, or wrap an array of existing AST nodes
        constructor(source) {
            this.nodes = typeof source === 'string' ?
                this.parseMarkup(source) : source;
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Add the tree defined as a hierarchical JS structure to the DOM
         *
         * @function Highcharts.AST#addToDOM
         *
         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} parent
         * The node where it should be added
         *
         * @return {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement}
         * The inserted node.
         */
        addToDOM(parent) {
            /**
             * @private
             * @param {Highcharts.ASTNode} subtree
             * HTML/SVG definition
             * @param {Element} [subParent]
             * parent node
             * @return {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}
             * The inserted node.
             */
            function recurse(subtree, subParent) {
                let ret;
                splat$2(subtree).forEach(function (item) {
                    const tagName = item.tagName;
                    const textNode = item.textContent ?
                        H.doc.createTextNode(item.textContent) :
                        void 0;
                    // Whether to ignore the AST filtering totally, #15345
                    const bypassHTMLFiltering = AST.bypassHTMLFiltering;
                    let node;
                    if (tagName) {
                        if (tagName === '#text') {
                            node = textNode;
                        }
                        else if (AST.allowedTags.indexOf(tagName) !== -1 ||
                            bypassHTMLFiltering) {
                            const NS = tagName === 'svg' ?
                                SVG_NS$3 :
                                (subParent.namespaceURI || SVG_NS$3);
                            const element = H.doc.createElementNS(NS, tagName);
                            const attributes = item.attributes || {};
                            // Apply attributes from root of AST node, legacy from
                            // from before TextBuilder
                            objectEach$5(item, function (val, key) {
                                if (key !== 'tagName' &&
                                    key !== 'attributes' &&
                                    key !== 'children' &&
                                    key !== 'style' &&
                                    key !== 'textContent') {
                                    attributes[key] = val;
                                }
                            });
                            attr$4(element, bypassHTMLFiltering ?
                                attributes :
                                AST.filterUserAttributes(attributes));
                            if (item.style) {
                                css$3(element, item.style);
                            }
                            // Add text content
                            if (textNode) {
                                element.appendChild(textNode);
                            }
                            // Recurse
                            recurse(item.children || [], element);
                            node = element;
                        }
                        else {
                            error$2(33, false, void 0, {
                                'Invalid tagName in config': tagName
                            });
                        }
                    }
                    // Add to the tree
                    if (node) {
                        subParent.appendChild(node);
                    }
                    ret = node;
                });
                // Return last node added (on top level it's the only one)
                return ret;
            }
            return recurse(this.nodes, parent);
        }
        /**
         * Parse HTML/SVG markup into AST Node objects. Used internally from the
         * constructor.
         *
         * @private
         *
         * @function Highcharts.AST#getNodesFromMarkup
         *
         * @param {string} markup The markup string.
         *
         * @return {Array<Highcharts.ASTNode>} The parsed nodes.
         */
        parseMarkup(markup) {
            const nodes = [];
            markup = markup
                .trim()
                // The style attribute throws a warning when parsing when CSP is
                // enabled (#6884), so use an alias and pick it up below
                // Make all quotation marks parse correctly to DOM (#17627)
                .replace(/ style=(["'])/g, ' data-style=$1');
            let doc;
            if (hasValidDOMParser) {
                doc = new DOMParser().parseFromString(trustedTypesPolicy ?
                    trustedTypesPolicy.createHTML(markup) :
                    markup, 'text/html');
            }
            else {
                const body = createElement$3('div');
                body.innerHTML = markup;
                doc = { body };
            }
            const appendChildNodes = (node, addTo) => {
                const tagName = node.nodeName.toLowerCase();
                // Add allowed tags
                const astNode = {
                    tagName
                };
                if (tagName === '#text') {
                    astNode.textContent = node.textContent || '';
                }
                const parsedAttributes = node.attributes;
                // Add attributes
                if (parsedAttributes) {
                    const attributes = {};
                    [].forEach.call(parsedAttributes, (attrib) => {
                        if (attrib.name === 'data-style') {
                            astNode.style = AST.parseStyle(attrib.value);
                        }
                        else {
                            attributes[attrib.name] = attrib.value;
                        }
                    });
                    astNode.attributes = attributes;
                }
                // Handle children
                if (node.childNodes.length) {
                    const children = [];
                    [].forEach.call(node.childNodes, (childNode) => {
                        appendChildNodes(childNode, children);
                    });
                    if (children.length) {
                        astNode.children = children;
                    }
                }
                addTo.push(astNode);
            };
            [].forEach.call(doc.body.childNodes, (childNode) => appendChildNodes(childNode, nodes));
            return nodes;
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    /**
     * The list of allowed SVG or HTML attributes, used for sanitizing
     * potentially harmful content from the chart configuration before adding to
     * the DOM.
     *
     * @see [Source code with default values](
     * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedAttributes)
     *
     * @example
     * // Allow a custom, trusted attribute
     * Highcharts.AST.allowedAttributes.push('data-value');
     *
     * @name Highcharts.AST.allowedAttributes
     * @type {Array<string>}
     */
    AST.allowedAttributes = [
        'alt',
        'aria-controls',
        'aria-describedby',
        'aria-expanded',
        'aria-haspopup',
        'aria-hidden',
        'aria-label',
        'aria-labelledby',
        'aria-live',
        'aria-pressed',
        'aria-readonly',
        'aria-roledescription',
        'aria-selected',
        'class',
        'clip-path',
        'color',
        'colspan',
        'cx',
        'cy',
        'd',
        'dx',
        'dy',
        'disabled',
        'fill',
        'filterUnits',
        'flood-color',
        'flood-opacity',
        'height',
        'href',
        'id',
        'in',
        'in2',
        'markerHeight',
        'markerWidth',
        'offset',
        'opacity',
        'operator',
        'orient',
        'padding',
        'paddingLeft',
        'paddingRight',
        'patternUnits',
        'r',
        'radius',
        'refX',
        'refY',
        'role',
        'scope',
        'slope',
        'src',
        'startOffset',
        'stdDeviation',
        'stroke',
        'stroke-linecap',
        'stroke-width',
        'style',
        'tableValues',
        'result',
        'rowspan',
        'summary',
        'target',
        'tabindex',
        'text-align',
        'text-anchor',
        'textAnchor',
        'textLength',
        'title',
        'type',
        'valign',
        'width',
        'x',
        'x1',
        'x2',
        'xlink:href',
        'y',
        'y1',
        'y2',
        'zIndex'
    ];
    /**
     * The list of allowed references for referring attributes like `href` and
     * `src`. Attribute values will only be allowed if they start with one of
     * these strings.
     *
     * @see [Source code with default values](
     * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedReferences)
     *
     * @example
     * // Allow tel:
     * Highcharts.AST.allowedReferences.push('tel:');
     *
     * @name    Highcharts.AST.allowedReferences
     * @type    {Array<string>}
     */
    AST.allowedReferences = [
        'https://',
        'http://',
        'mailto:',
        '/',
        '../',
        './',
        '#'
    ];
    /**
     * The list of allowed SVG or HTML tags, used for sanitizing potentially
     * harmful content from the chart configuration before adding to the DOM.
     *
     * @see [Source code with default values](
     * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedTags)
     *
     * @example
     * // Allow a custom, trusted tag
     * Highcharts.AST.allowedTags.push('blink'); // ;)
     *
     * @name    Highcharts.AST.allowedTags
     * @type    {Array<string>}
     */
    AST.allowedTags = [
        'a',
        'abbr',
        'b',
        'br',
        'button',
        'caption',
        'circle',
        'clipPath',
        'code',
        'dd',
        'defs',
        'div',
        'dl',
        'dt',
        'em',
        'feComponentTransfer',
        'feComposite',
        'feDropShadow',
        'feFlood',
        'feFuncA',
        'feFuncB',
        'feFuncG',
        'feFuncR',
        'feGaussianBlur',
        'feMorphology',
        'feOffset',
        'feMerge',
        'feMergeNode',
        'filter',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'hr',
        'i',
        'img',
        'li',
        'linearGradient',
        'marker',
        'ol',
        'p',
        'path',
        'pattern',
        'pre',
        'rect',
        'small',
        'span',
        'stop',
        'strong',
        'style',
        'sub',
        'sup',
        'svg',
        'table',
        'text',
        'textPath',
        'thead',
        'title',
        'tbody',
        'tspan',
        'td',
        'th',
        'tr',
        'u',
        'ul',
        '#text'
    ];
    AST.emptyHTML = emptyHTML;
    /**
     * Allow all custom SVG and HTML attributes, references and tags (together
     * with potentially harmful ones) to be added to the DOM from the chart
     * configuration. In other words, disable the allow-listing which is the
     * primary functionality of the AST.
     *
     * WARNING: Setting this property to `true` while allowing untrusted user
     * data in the chart configuration will expose your application to XSS
     * security risks!
     *
     * Note that in case you want to allow a known set of tags or attributes,
     * you should allow-list them instead of disabling the filtering totally.
     * See [allowedAttributes](Highcharts.AST#.allowedAttributes),
     * [allowedReferences](Highcharts.AST#.allowedReferences) and
     * [allowedTags](Highcharts.AST#.allowedTags). The `bypassHTMLFiltering`
     * setting is intended only for those cases where allow-listing is not
     * practical, and the chart configuration already comes from a secure
     * source.
     *
     * @example
     * // Allow all custom attributes, references and tags (disable DOM XSS
     * // filtering)
     * Highcharts.AST.bypassHTMLFiltering = true;
     *
     * @name Highcharts.AST.bypassHTMLFiltering
     * @static
     */
    AST.bypassHTMLFiltering = false;

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animObject: animObject$4 } = animationExports;
    const { defaultOptions: defaultOptions$4 } = DefaultOptions;
    const { format } = Templating;
    const { addEvent: addEvent$3, crisp: crisp$4, erase: erase$3, extend: extend$8, fireEvent: fireEvent$5, getNestedProperty: getNestedProperty$1, isArray: isArray$5, isFunction: isFunction$1, isNumber: isNumber$6, isObject: isObject$3, merge: merge$7, pick: pick$8, syncTimeout: syncTimeout$3, removeEvent: removeEvent$3, uniqueKey: uniqueKey$3 } = Utilities;
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /* *
     *
     *  Class
     *
     * */
    /**
     * The Point object. The point objects are generated from the `series.data`
     * configuration objects or raw numbers. They can be accessed from the
     * `Series.points` array. Other ways to instantiate points are through {@link
     * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.
     *
     * @class
     * @name Highcharts.Point
     */
    class Point {
        /**
         * For categorized axes this property holds the category name for the
         * point. For other axes it holds the X value.
         *
         * @name Highcharts.Point#category
         * @type {number|string}
         */
        /**
         * The name of the point. The name can be given as the first position of the
         * point configuration array, or as a `name` property in the configuration:
         *
         * @example
         * // Array config
         * data: [
         *     ['John', 1],
         *     ['Jane', 2]
         * ]
         *
         * // Object config
         * data: [{
         *        name: 'John',
         *        y: 1
         * }, {
         *     name: 'Jane',
         *     y: 2
         * }]
         *
         * @name Highcharts.Point#name
         * @type {string}
         */
        /**
         * The point's options as applied in the initial configuration, or
         * extended through `Point.update`.
         *
         * In TypeScript you have to extend `PointOptionsObject` via an
         * additional interface to allow custom data options:
         *
         * ```
         * declare interface PointOptionsObject {
         *     customProperty: string;
         * }
         * ```
         *
         * @name Highcharts.Point#options
         * @type {Highcharts.PointOptionsObject}
         */
        /**
         * The percentage for points in a stacked series, pies or gauges.
         *
         * @name Highcharts.Point#percentage
         * @type {number|undefined}
         */
        /**
         * The series object associated with the point.
         *
         * @name Highcharts.Point#series
         * @type {Highcharts.Series}
         */
        /**
         * The attributes of the rendered SVG shape like in `column` or `pie`
         * series.
         *
         * @readonly
         * @name Highcharts.Point#shapeArgs
         * @type {Readonly<Highcharts.SVGAttributes>|undefined}
         */
        /**
         * The total of values in either a stack for stacked series, or a pie in a
         * pie series.
         *
         * @name Highcharts.Point#total
         * @type {number|undefined}
         */
        /**
         * For certain series types, like pie charts, where individual points can
         * be shown or hidden.
         *
         * @name Highcharts.Point#visible
         * @type {boolean}
         * @default true
         */
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Animate SVG elements associated with the point.
         *
         * @private
         * @function Highcharts.Point#animateBeforeDestroy
         */
        animateBeforeDestroy() {
            const point = this, animateParams = { x: point.startXPos, opacity: 0 }, graphicalProps = point.getGraphicalProps();
            graphicalProps.singular.forEach(function (prop) {
                const isDataLabel = prop === 'dataLabel';
                point[prop] = point[prop].animate(isDataLabel ? {
                    x: point[prop].startXPos,
                    y: point[prop].startYPos,
                    opacity: 0
                } : animateParams);
            });
            graphicalProps.plural.forEach(function (plural) {
                point[plural].forEach(function (item) {
                    if (item.element) {
                        item.animate(extend$8({ x: point.startXPos }, (item.startYPos ? {
                            x: item.startXPos,
                            y: item.startYPos
                        } : {})));
                    }
                });
            });
        }
        /**
         * Apply the options containing the x and y data and possible some extra
         * properties. Called on point init or from point.update.
         *
         * @private
         * @function Highcharts.Point#applyOptions
         *
         * @param {Highcharts.PointOptionsType} options
         *        The point options as defined in series.data.
         *
         * @param {number} [x]
         *        Optionally, the x value.
         *
         * @return {Highcharts.Point}
         *         The Point instance.
         */
        applyOptions(options, x) {
            const point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
            options = Point.prototype.optionsToObject.call(this, options);
            // Copy options directly to point
            extend$8(point, options);
            point.options = point.options ?
                extend$8(point.options, options) :
                options;
            // Since options are copied into the Point instance, some accidental
            // options must be shielded (#5681)
            if (options.group) {
                delete point.group;
            }
            if (options.dataLabels) {
                delete point.dataLabels;
            }
            /**
             * The y value of the point.
             * @name Highcharts.Point#y
             * @type {number|undefined}
             */
            // For higher dimension series types. For instance, for ranges, point.y
            // is mapped to point.low.
            if (pointValKey) {
                point.y = Point.prototype.getNestedProperty.call(point, pointValKey);
            }
            // The point is initially selected by options (#5777)
            if (point.selected) {
                point.state = 'select';
            }
            /**
             * The x value of the point.
             * @name Highcharts.Point#x
             * @type {number}
             */
            // If no x is set by now, get auto incremented value. All points must
            // have an x value, however the y value can be null to create a gap in
            // the series
            if ('name' in point &&
                typeof x === 'undefined' &&
                series.xAxis &&
                series.xAxis.hasNames) {
                point.x = series.xAxis.nameToX(point);
            }
            if (typeof point.x === 'undefined' && series) {
                point.x = x ?? series.autoIncrement();
            }
            else if (isNumber$6(options.x) && series.options.relativeXValue) {
                point.x = series.autoIncrement(options.x);
            }
            point.isNull = this.isValid && !this.isValid();
            point.formatPrefix = point.isNull ? 'null' : 'point'; // #9233, #10874
            return point;
        }
        /**
         * Destroy a point to clear memory. Its reference still stays in
         * `series.data`.
         *
         * @private
         * @function Highcharts.Point#destroy
         */
        destroy() {
            if (!this.destroyed) {
                const point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject$4(globalAnimation);
                /**
                 * Allow to call after animation.
                 * @private
                 */
                const destroyPoint = () => {
                    // Remove all events and elements
                    if (point.graphic ||
                        point.graphics ||
                        point.dataLabel ||
                        point.dataLabels) {
                        removeEvent$3(point);
                        point.destroyElements();
                    }
                    for (const prop in point) { // eslint-disable-line guard-for-in
                        delete point[prop];
                    }
                };
                if (point.legendItem) {
                    // Pies have legend items
                    chart.legend.destroyItem(point);
                }
                if (hoverPoints) {
                    point.setState();
                    erase$3(hoverPoints, point);
                    if (!hoverPoints.length) {
                        chart.hoverPoints = null;
                    }
                }
                if (point === chart.hoverPoint) {
                    point.onMouseOut();
                }
                // Remove properties after animation
                if (!dataSorting || !dataSorting.enabled) {
                    destroyPoint();
                }
                else {
                    this.animateBeforeDestroy();
                    syncTimeout$3(destroyPoint, animation.duration);
                }
                chart.pointCount--;
            }
            this.destroyed = true;
        }
        /**
         * Destroy SVG elements associated with the point.
         *
         * @private
         * @function Highcharts.Point#destroyElements
         * @param {Highcharts.Dictionary<number>} [kinds]
         */
        destroyElements(kinds) {
            const point = this, props = point.getGraphicalProps(kinds);
            props.singular.forEach(function (prop) {
                point[prop] = point[prop].destroy();
            });
            props.plural.forEach(function (plural) {
                point[plural].forEach(function (item) {
                    if (item && item.element) {
                        item.destroy();
                    }
                });
                delete point[plural];
            });
        }
        /**
         * Fire an event on the Point object.
         *
         * @private
         * @function Highcharts.Point#firePointEvent
         *
         * @param {string} eventType
         *        Type of the event.
         *
         * @param {Highcharts.Dictionary<any>|Event} [eventArgs]
         *        Additional event arguments.
         *
         * @param {Highcharts.EventCallbackFunction<Highcharts.Point>|Function} [defaultFunction]
         *        Default event handler.
         *
         * @emits Highcharts.Point#event:*
         */
        firePointEvent(eventType, eventArgs, defaultFunction) {
            const point = this, series = this.series, seriesOptions = series.options;
            // Load event handlers on demand to save time on mouseover/out
            point.manageEvent(eventType);
            // Add default handler if in selection mode
            if (eventType === 'click' && seriesOptions.allowPointSelect) {
                defaultFunction = function (event) {
                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift
                    // for Opera.
                    if (!point.destroyed && point.select) { // #2911, #19075
                        point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                    }
                };
            }
            fireEvent$5(point, eventType, eventArgs, defaultFunction);
        }
        /**
         * Get the CSS class names for individual points. Used internally where the
         * returned value is set on every point.
         *
         * @function Highcharts.Point#getClassName
         *
         * @return {string}
         *         The class names.
         */
        getClassName() {
            const point = this;
            return 'highcharts-point' +
                (point.selected ? ' highcharts-point-select' : '') +
                (point.negative ? ' highcharts-negative' : '') +
                (point.isNull ? ' highcharts-null-point' : '') +
                (typeof point.colorIndex !== 'undefined' ?
                    ' highcharts-color-' + point.colorIndex : '') +
                (point.options.className ? ' ' + point.options.className : '') +
                (point.zone && point.zone.className ? ' ' +
                    point.zone.className.replace('highcharts-negative', '') : '');
        }
        /**
         * Get props of all existing graphical point elements.
         *
         * @private
         * @function Highcharts.Point#getGraphicalProps
         */
        getGraphicalProps(kinds) {
            const point = this, props = [], graphicalProps = { singular: [], plural: [] };
            let prop, i;
            kinds = kinds || { graphic: 1, dataLabel: 1 };
            if (kinds.graphic) {
                props.push('graphic', 'connector' // Used by dumbbell
                );
            }
            if (kinds.dataLabel) {
                props.push('dataLabel', 'dataLabelPath', 'dataLabelUpper');
            }
            i = props.length;
            while (i--) {
                prop = props[i];
                if (point[prop]) {
                    graphicalProps.singular.push(prop);
                }
            }
            [
                'graphic',
                'dataLabel'
            ].forEach(function (prop) {
                const plural = prop + 's';
                if (kinds[prop] && point[plural]) {
                    graphicalProps.plural.push(plural);
                }
            });
            return graphicalProps;
        }
        /**
         * Return the configuration hash needed for the data label and tooltip
         * formatters.
         *
         * @function Highcharts.Point#getLabelConfig
         *
         * @return {Highcharts.PointLabelObject}
         *         Abstract object used in formatters and formats.
         */
        getLabelConfig() {
            return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
            };
        }
        /**
         * Returns the value of the point property for a given value.
         * @private
         */
        getNestedProperty(key) {
            if (!key) {
                return;
            }
            if (key.indexOf('custom.') === 0) {
                return getNestedProperty$1(key, this.options);
            }
            return this[key];
        }
        /**
         * In a series with `zones`, return the zone that the point belongs to.
         *
         * @function Highcharts.Point#getZone
         *
         * @return {Highcharts.SeriesZonesOptionsObject}
         *         The zone item.
         */
        getZone() {
            const series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || 'y';
            let zone, i = 0;
            zone = zones[i];
            while (this[zoneAxis] >= zone.value) {
                zone = zones[++i];
            }
            // For resetting or reusing the point (#8100)
            if (!this.nonZonedColor) {
                this.nonZonedColor = this.color;
            }
            if (zone && zone.color && !this.options.color) {
                this.color = zone.color;
            }
            else {
                this.color = this.nonZonedColor;
            }
            return zone;
        }
        /**
         * Utility to check if point has new shape type. Used in column series and
         * all others that are based on column series.
         * @private
         */
        hasNewShapeType() {
            const point = this;
            const oldShapeType = point.graphic &&
                (point.graphic.symbolName || point.graphic.element.nodeName);
            return oldShapeType !== this.shapeType;
        }
        /**
         * Initialize the point. Called internally based on the `series.data`
         * option.
         *
         * @function Highcharts.Point#init
         *
         * @param {Highcharts.Series} series
         *        The series object containing this point.
         *
         * @param {Highcharts.PointOptionsType} options
         *        The data in either number, array or object format.
         *
         * @param {number} [x]
         *        Optionally, the X value of the point.
         *
         * @return {Highcharts.Point}
         *         The Point instance.
         *
         * @emits Highcharts.Point#event:afterInit
         */
        constructor(series, options, x) {
            this.formatPrefix = 'point';
            this.visible = true;
            this.series = series;
            this.applyOptions(options, x);
            // Add a unique ID to the point if none is assigned
            this.id ?? (this.id = uniqueKey$3());
            this.resolveColor();
            series.chart.pointCount++;
            fireEvent$5(this, 'afterInit');
        }
        /**
         * Determine if point is valid.
         * @private
         * @function Highcharts.Point#isValid
         */
        isValid() {
            return ((isNumber$6(this.x) ||
                this.x instanceof Date) &&
                isNumber$6(this.y));
        }
        /**
         * Transform number or array configs into objects. Also called for object
         * configs. Used internally to unify the different configuration formats for
         * points. For example, a simple number `10` in a line series will be
         * transformed to `{ y: 10 }`, and an array config like `[1, 10]` in a
         * scatter series will be transformed to `{ x: 1, y: 10 }`.
         *
         * @deprecated
         * @function Highcharts.Point#optionsToObject
         *
         * @param {Highcharts.PointOptionsType} options
         * Series data options.
         *
         * @return {Highcharts.Dictionary<*>}
         * Transformed point options.
         */
        optionsToObject(options) {
            const series = this.series, keys = series.options.keys, pointArrayMap = keys || series.pointArrayMap || ['y'], valueCount = pointArrayMap.length;
            let ret = {}, firstItemType, i = 0, j = 0;
            if (isNumber$6(options) || options === null) {
                ret[pointArrayMap[0]] = options;
            }
            else if (isArray$5(options)) {
                // With leading x value
                if (!keys && options.length > valueCount) {
                    firstItemType = typeof options[0];
                    if (firstItemType === 'string') {
                        ret.name = options[0];
                    }
                    else if (firstItemType === 'number') {
                        ret.x = options[0];
                    }
                    i++;
                }
                while (j < valueCount) {
                    // Skip undefined positions for keys
                    if (!keys || typeof options[i] !== 'undefined') {
                        if (pointArrayMap[j].indexOf('.') > 0) {
                            // Handle nested keys, e.g. ['color.pattern.image']
                            // Avoid function call unless necessary.
                            Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
                        }
                        else {
                            ret[pointArrayMap[j]] = options[i];
                        }
                    }
                    i++;
                    j++;
                }
            }
            else if (typeof options === 'object') {
                ret = options;
                // This is the fastest way to detect if there are individual point
                // dataLabels that need to be considered in drawDataLabels. These
                // can only occur in object configs.
                if (options.dataLabels) {
                    // Override the prototype function to always return true,
                    // regardless of whether data labels are enabled series-wide
                    series.hasDataLabels = () => true;
                }
                // Same approach as above for markers
                if (options.marker) {
                    series._hasPointMarkers = true;
                }
            }
            return ret;
        }
        /**
         * Get the pixel position of the point relative to the plot area.
         * @function Highcharts.Point#pos
         *
         * @sample highcharts/point/position
         *         Get point's position in pixels.
         *
         * @param {boolean} chartCoordinates
         * If true, the returned position is relative to the full chart area.
         * If false, it is relative to the plot area determined by the axes.
         *
         * @param {number|undefined} plotY
         * A custom plot y position to be computed. Used internally for some
         * series types that have multiple `y` positions, like area range (low
         * and high values).
         *
         * @return {Array<number>|undefined}
         * Coordinates of the point if the point exists.
         */
        pos(chartCoordinates, plotY = this.plotY) {
            if (!this.destroyed) {
                const { plotX, series } = this, { chart, xAxis, yAxis } = series;
                let posX = 0, posY = 0;
                if (isNumber$6(plotX) && isNumber$6(plotY)) {
                    if (chartCoordinates) {
                        posX = xAxis ? xAxis.pos : chart.plotLeft;
                        posY = yAxis ? yAxis.pos : chart.plotTop;
                    }
                    return chart.inverted && xAxis && yAxis ?
                        [yAxis.len - plotY + posY, xAxis.len - plotX + posX] :
                        [plotX + posX, plotY + posY];
                }
            }
        }
        /**
         * @private
         * @function Highcharts.Point#resolveColor
         */
        resolveColor() {
            const series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
            let color, colors, colorCount = optionsChart.colorCount, colorIndex;
            // Remove points nonZonedColor for later recalculation
            delete this.nonZonedColor;
            if (series.options.colorByPoint) {
                if (!styledMode) {
                    colors = series.options.colors || series.chart.options.colors;
                    color = colors[series.colorCounter];
                    colorCount = colors.length;
                }
                colorIndex = series.colorCounter;
                series.colorCounter++;
                // Loop back to zero
                if (series.colorCounter === colorCount) {
                    series.colorCounter = 0;
                }
            }
            else {
                if (!styledMode) {
                    color = series.color;
                }
                colorIndex = series.colorIndex;
            }
            /**
             * The point's current color index, used in styled mode instead of
             * `color`. The color index is inserted in class names used for styling.
             *
             * @name Highcharts.Point#colorIndex
             * @type {number|undefined}
             */
            this.colorIndex = pick$8(this.options.colorIndex, colorIndex);
            /**
             * The point's current color.
             *
             * @name Highcharts.Point#color
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}
             */
            this.color = pick$8(this.options.color, color);
        }
        /**
         * Set a value in an object, on the property defined by key. The key
         * supports nested properties using dot notation. The function modifies the
         * input object and does not make a copy.
         *
         * @function Highcharts.Point#setNestedProperty<T>
         *
         * @param {T} object
         *        The object to set the value on.
         *
         * @param {*} value
         *        The value to set.
         *
         * @param {string} key
         *        Key to the property to set.
         *
         * @return {T}
         *         The modified object.
         */
        setNestedProperty(object, value, key) {
            const nestedKeys = key.split('.');
            nestedKeys.reduce(function (result, key, i, arr) {
                const isLastKey = arr.length - 1 === i;
                result[key] = (isLastKey ?
                    value :
                    isObject$3(result[key], true) ?
                        result[key] :
                        {});
                return result[key];
            }, object);
            return object;
        }
        shouldDraw() {
            return !this.isNull;
        }
        /**
         * Extendable method for formatting each point's tooltip line.
         *
         * @function Highcharts.Point#tooltipFormatter
         *
         * @param {string} pointFormat
         *        The point format.
         *
         * @return {string}
         *         A string to be concatenated in to the common tooltip text.
         */
        tooltipFormatter(pointFormat) {
            // Insert options for valueDecimals, valuePrefix, and valueSuffix
            const series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick$8(seriesTooltipOptions.valueDecimals, ''), valuePrefix = seriesTooltipOptions.valuePrefix || '', valueSuffix = seriesTooltipOptions.valueSuffix || '';
            // Replace default point style with class name
            if (series.chart.styledMode) {
                pointFormat =
                    series.chart.tooltip.styledModeFormat(pointFormat);
            }
            // Loop over the point array map and replace unformatted values with
            // sprintf formatting markup
            (series.pointArrayMap || ['y']).forEach(function (key) {
                key = '{point.' + key; // Without the closing bracket
                if (valuePrefix || valueSuffix) {
                    pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix);
                }
                pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}');
            });
            return format(pointFormat, {
                point: this,
                series: this.series
            }, series.chart);
        }
        /**
         * Update point with new options (typically x/y data) and optionally redraw
         * the series.
         *
         * @sample highcharts/members/point-update-column/
         *         Update column value
         * @sample highcharts/members/point-update-pie/
         *         Update pie slice
         * @sample maps/members/point-update/
         *         Update map area value in Highmaps
         *
         * @function Highcharts.Point#update
         *
         * @param {Highcharts.PointOptionsType} options
         *        The point options. Point options are handled as described under
         *        the `series.type.data` item for each series type. For example
         *        for a line series, if options is a single number, the point will
         *        be given that number as the marin y value. If it is an array, it
         *        will be interpreted as x and y values respectively. If it is an
         *        object, advanced options are applied.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the point is updated. If doing
         *        more operations on the chart, it is best practice to set
         *        `redraw` to false and call `chart.redraw()` after.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]
         *        Whether to apply animation, and optionally animation
         *        configuration.
         *
         * @emits Highcharts.Point#event:update
         */
        update(options, redraw, animation, runEvent) {
            const point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
            let i;
            redraw = pick$8(redraw, true);
            /**
             * @private
             */
            function update() {
                point.applyOptions(options);
                // Update visuals, #4146
                // Handle mock graphic elements for a11y, #12718
                const hasMockGraphic = graphic && point.hasMockGraphic;
                const shouldDestroyGraphic = point.y === null ?
                    !hasMockGraphic :
                    hasMockGraphic;
                if (graphic && shouldDestroyGraphic) {
                    point.graphic = graphic.destroy();
                    delete point.hasMockGraphic;
                }
                if (isObject$3(options, true)) {
                    // Destroy so we can get new elements
                    if (graphic && graphic.element) {
                        // "null" is also a valid symbol
                        if (options &&
                            options.marker &&
                            typeof options.marker.symbol !== 'undefined') {
                            point.graphic = graphic.destroy();
                        }
                    }
                    if (options?.dataLabels && point.dataLabel) {
                        point.dataLabel = point.dataLabel.destroy(); // #2468
                    }
                }
                // Record changes in the parallel arrays
                i = point.index;
                series.updateParallelArrays(point, i);
                // Record the options to options.data. If the old or the new config
                // is an object, use point options, otherwise use raw options
                // (#4701, #4916).
                seriesOptions.data[i] = (isObject$3(seriesOptions.data[i], true) ||
                    isObject$3(options, true)) ?
                    point.options :
                    pick$8(options, seriesOptions.data[i]);
                // Redraw
                series.isDirty = series.isDirtyData = true;
                if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
                    chart.isDirtyBox = true;
                }
                if (seriesOptions.legendType === 'point') { // #1831, #1885
                    chart.isDirtyLegend = true;
                }
                if (redraw) {
                    chart.redraw(animation);
                }
            }
            // Fire the event with a default handler of doing the update
            if (runEvent === false) { // When called from setData
                update();
            }
            else {
                point.firePointEvent('update', { options: options }, update);
            }
        }
        /**
         * Remove a point and optionally redraw the series and if necessary the axes
         *
         * @sample highcharts/plotoptions/series-point-events-remove/
         *         Remove point and confirm
         * @sample highcharts/members/point-remove/
         *         Remove pie slice
         * @sample maps/members/point-remove/
         *         Remove selected points in Highmaps
         *
         * @function Highcharts.Point#remove
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart or wait for an explicit call. When
         *        doing more operations on the chart, for example running
         *        `point.remove()` in a loop, it is best practice to set `redraw`
         *        to false and call `chart.redraw()` after.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=false]
         *        Whether to apply animation, and optionally animation
         *        configuration.
         */
        remove(redraw, animation) {
            this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
        }
        /**
         * Toggle the selection status of a point.
         *
         * @see Highcharts.Chart#getSelectedPoints
         *
         * @sample highcharts/members/point-select/
         *         Select a point from a button
         * @sample highcharts/members/point-select-lasso/
         *         Lasso selection
         * @sample highcharts/chart/events-selection-points/
         *         Rectangle selection
         * @sample maps/series/data-id/
         *         Select a point in Highmaps
         *
         * @function Highcharts.Point#select
         *
         * @param {boolean} [selected]
         * When `true`, the point is selected. When `false`, the point is
         * unselected. When `null` or `undefined`, the selection state is toggled.
         *
         * @param {boolean} [accumulate=false]
         * When `true`, the selection is added to other selected points.
         * When `false`, other selected points are deselected. Internally in
         * Highcharts, when
         * [allowPointSelect](https://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect)
         * is `true`, selected points are accumulated on Control, Shift or Cmd
         * clicking the point.
         *
         * @emits Highcharts.Point#event:select
         * @emits Highcharts.Point#event:unselect
         */
        select(selected, accumulate) {
            const point = this, series = point.series, chart = series.chart;
            selected = pick$8(selected, !point.selected);
            this.selectedStaging = selected;
            // Fire the event with the default handler
            point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
                /**
                 * Whether the point is selected or not.
                 *
                 * @see Point#select
                 * @see Chart#getSelectedPoints
                 *
                 * @name Highcharts.Point#selected
                 * @type {boolean}
                 */
                point.selected = point.options.selected = selected;
                series.options.data[series.data.indexOf(point)] =
                    point.options;
                point.setState(selected && 'select');
                // Unselect all other points unless Ctrl or Cmd + click
                if (!accumulate) {
                    chart.getSelectedPoints().forEach(function (loopPoint) {
                        const loopSeries = loopPoint.series;
                        if (loopPoint.selected && loopPoint !== point) {
                            loopPoint.selected = loopPoint.options.selected =
                                false;
                            loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
                            // Programmatically selecting a point should restore
                            // normal state, but when click happened on other
                            // point, set inactive state to match other points
                            loopPoint.setState(chart.hoverPoints &&
                                loopSeries.options.inactiveOtherPoints ?
                                'inactive' : '');
                            loopPoint.firePointEvent('unselect');
                        }
                    });
                }
            });
            delete this.selectedStaging;
        }
        /**
         * Runs on mouse over the point. Called internally from mouse and touch
         * events.
         *
         * @function Highcharts.Point#onMouseOver
         *
         * @param {Highcharts.PointerEventObject} [e]
         *        The event arguments.
         */
        onMouseOver(e) {
            const point = this, series = point.series, { inverted, pointer } = series.chart;
            if (pointer) {
                e = e ?
                    pointer.normalize(e) :
                    // In cases where onMouseOver is called directly without an
                    // event
                    pointer.getChartCoordinatesFromPoint(point, inverted);
                pointer.runPointActions(e, point);
            }
        }
        /**
         * Runs on mouse out from the point. Called internally from mouse and touch
         * events.
         *
         * @function Highcharts.Point#onMouseOut
         * @emits Highcharts.Point#event:mouseOut
         */
        onMouseOut() {
            const point = this, chart = point.series.chart;
            point.firePointEvent('mouseOut');
            if (!point.series.options.inactiveOtherPoints) {
                (chart.hoverPoints || []).forEach(function (p) {
                    p.setState();
                });
            }
            chart.hoverPoints = chart.hoverPoint = null;
        }
        /**
         * Manage specific event from the series' and point's options. Only do it on
         * demand, to save processing time on hovering.
         *
         * @private
         * @function Highcharts.Point#importEvents
         */
        manageEvent(eventType) {
            const point = this, options = merge$7(point.series.options.point, point.options), userEvent = options.events?.[eventType];
            if (isFunction$1(userEvent) &&
                (!point.hcEvents?.[eventType] ||
                    // Some HC modules, like marker-clusters, draggable-poins etc.
                    // use events in their logic, so we need to be sure, that
                    // callback function is different
                    point.hcEvents?.[eventType]?.map((el) => el.fn)
                        .indexOf(userEvent) === -1)) {
                // While updating the existing callback event the old one should be
                // removed
                point.importedUserEvent?.();
                point.importedUserEvent = addEvent$3(point, eventType, userEvent);
            }
            else if (point.importedUserEvent &&
                !userEvent &&
                point.hcEvents?.[eventType]) {
                removeEvent$3(point, eventType);
                delete point.hcEvents[eventType];
                if (!Object.keys(point.hcEvents)) {
                    delete point.importedUserEvent;
                }
            }
        }
        /**
         * Set the point's state.
         *
         * @function Highcharts.Point#setState
         *
         * @param {Highcharts.PointStateValue|""} [state]
         *        The new state, can be one of `'hover'`, `'select'`, `'inactive'`,
         *        or `''` (an empty string), `'normal'` or `undefined` to set to
         *        normal state.
         * @param {boolean} [move]
         *        State for animation.
         *
         * @emits Highcharts.Point#event:afterSetState
         */
        setState(state, move) {
            const point = this, series = point.series, previousState = point.state, stateOptions = (series.options.states[state || 'normal'] ||
                {}), markerOptions = (defaultOptions$4.plotOptions[series.type].marker &&
                series.options.marker), normalDisabled = (markerOptions && markerOptions.enabled === false), markerStateOptions = ((markerOptions &&
                markerOptions.states &&
                markerOptions.states[state || 'normal']) || {}), stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = (markerOptions && series.markerAttribs);
            let halo = series.halo, markerAttribs, pointAttribs, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
            state = state || ''; // Empty string
            if (
            // Already has this state
            (state === point.state && !move) ||
                // Selected points don't respond to hover
                (point.selected && state !== 'select') ||
                // Series' state options is disabled
                (stateOptions.enabled === false) ||
                // General point marker's state options is disabled
                (state && (stateDisabled ||
                    (normalDisabled &&
                        markerStateOptions.enabled === false))) ||
                // Individual point marker's state options is disabled
                (state &&
                    pointMarker.states &&
                    pointMarker.states[state] &&
                    pointMarker.states[state].enabled === false) // #1610
            ) {
                return;
            }
            point.state = state;
            if (hasMarkers) {
                markerAttribs = series.markerAttribs(point, state);
            }
            // Apply hover styles to the existing point
            // Prevent from mocked null points (#14966)
            if (point.graphic && !point.hasMockGraphic) {
                if (previousState) {
                    point.graphic.removeClass('highcharts-point-' + previousState);
                }
                if (state) {
                    point.graphic.addClass('highcharts-point-' + state);
                }
                if (!chart.styledMode) {
                    pointAttribs = series.pointAttribs(point, state);
                    pointAttribsAnimation = pick$8(chart.options.chart.animation, stateOptions.animation);
                    const opacity = pointAttribs.opacity;
                    // Some inactive points (e.g. slices in pie) should apply
                    // opacity also for their labels
                    if (series.options.inactiveOtherPoints && isNumber$6(opacity)) {
                        (point.dataLabels || []).forEach(function (label) {
                            if (label &&
                                !label.hasClass('highcharts-data-label-hidden')) {
                                label.animate({ opacity }, pointAttribsAnimation);
                                if (label.connector) {
                                    label.connector.animate({ opacity }, pointAttribsAnimation);
                                }
                            }
                        });
                    }
                    point.graphic.animate(pointAttribs, pointAttribsAnimation);
                }
                if (markerAttribs) {
                    point.graphic.animate(markerAttribs, pick$8(
                    // Turn off globally:
                    chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation));
                }
                // Zooming in from a range with no markers to a range with markers
                if (stateMarkerGraphic) {
                    stateMarkerGraphic.hide();
                }
            }
            else {
                // If a graphic is not applied to each point in the normal state,
                // create a shared graphic for the hover state
                if (state && markerStateOptions) {
                    newSymbol = pointMarker.symbol || series.symbol;
                    // If the point has another symbol than the previous one, throw
                    // away the state marker graphic and force a new one (#1459)
                    if (stateMarkerGraphic &&
                        stateMarkerGraphic.currentSymbol !== newSymbol) {
                        stateMarkerGraphic = stateMarkerGraphic.destroy();
                    }
                    // Add a new state marker graphic
                    if (markerAttribs) {
                        if (!stateMarkerGraphic) {
                            if (newSymbol) {
                                series.stateMarkerGraphic = stateMarkerGraphic =
                                    chart.renderer
                                        .symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height)
                                        .add(series.markerGroup);
                                stateMarkerGraphic.currentSymbol = newSymbol;
                            }
                            // Move the existing graphic
                        }
                        else {
                            stateMarkerGraphic[move ? 'animate' : 'attr']({
                                x: markerAttribs.x,
                                y: markerAttribs.y
                            });
                        }
                    }
                    if (!chart.styledMode && stateMarkerGraphic &&
                        point.state !== 'inactive') {
                        stateMarkerGraphic.attr(series.pointAttribs(point, state));
                    }
                }
                if (stateMarkerGraphic) {
                    stateMarkerGraphic[state && point.isInside ? 'show' : 'hide'](); // #2450
                    stateMarkerGraphic.element.point = point; // #4310
                    stateMarkerGraphic.addClass(point.getClassName(), true);
                }
            }
            // Show me your halo
            const haloOptions = stateOptions.halo;
            const markerGraphic = (point.graphic || stateMarkerGraphic);
            const markerVisibility = (markerGraphic && markerGraphic.visibility || 'inherit');
            if (haloOptions &&
                haloOptions.size &&
                markerGraphic &&
                markerVisibility !== 'hidden' &&
                !point.isCluster) {
                if (!halo) {
                    series.halo = halo = chart.renderer.path()
                        // #5818, #5903, #6705
                        .add(markerGraphic.parentGroup);
                }
                halo.show()[move ? 'animate' : 'attr']({
                    d: point.haloPath(haloOptions.size)
                });
                halo.attr({
                    'class': 'highcharts-halo highcharts-color-' +
                        pick$8(point.colorIndex, series.colorIndex) +
                        (point.className ? ' ' + point.className : ''),
                    'visibility': markerVisibility,
                    'zIndex': -1 // #4929, #8276
                });
                halo.point = point; // #6055
                if (!chart.styledMode) {
                    halo.attr(extend$8({
                        'fill': point.color || series.color,
                        'fill-opacity': haloOptions.opacity
                    }, AST.filterUserAttributes(haloOptions.attributes || {})));
                }
            }
            else if (halo?.point?.haloPath &&
                !halo.point.destroyed) {
                // Animate back to 0 on the current halo point (#6055)
                halo.animate({ d: halo.point.haloPath(0) }, null, 
                // Hide after unhovering. The `complete` callback runs in the
                // halo's context (#7681).
                halo.hide);
            }
            fireEvent$5(point, 'afterSetState', { state });
        }
        /**
         * Get the path definition for the halo, which is usually a shadow-like
         * circle around the currently hovered point.
         *
         * @function Highcharts.Point#haloPath
         *
         * @param {number} size
         *        The radius of the circular halo.
         *
         * @return {Highcharts.SVGPathArray}
         *         The path definition.
         */
        haloPath(size) {
            const pos = this.pos();
            return pos ? this.series.chart.renderer.symbols.circle(crisp$4(pos[0], 1) - size, pos[1] - size, size * 2, size * 2) : [];
        }
    }

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  API Options
     *
     * */
    /**
     * General options for all series types.
     *
     * @optionparent plotOptions.series
     */
    const seriesDefaults = {
        // Base series options
        /**
         * The SVG value used for the `stroke-linecap` and `stroke-linejoin`
         * of a line graph. Round means that lines are rounded in the ends and
         * bends.
         *
         * @type       {Highcharts.SeriesLinecapValue}
         * @default    round
         * @since      3.0.7
         * @apioption  plotOptions.line.linecap
         */
        /**
         * Pixel width of the graph line.
         *
         * @see In styled mode, the line stroke-width can be set with the
         *      `.highcharts-graph` class name.
         *
         * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/
         *         On all series
         * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/
         *         On one single series
         *
         * @product highcharts highstock
         */
        lineWidth: 2,
        /**
         * For some series, there is a limit that shuts down animation
         * by default when the total number of points in the chart is too high.
         * For example, for a column chart and its derivatives, animation does
         * not run if there is more than 250 points totally. To disable this
         * cap, set `animationLimit` to `Infinity`. This option works if animation
         * is fired on individual points, not on a group of points like e.g. during
         * the initial animation.
         *
         * @sample {highcharts} highcharts/plotoptions/series-animationlimit/
         *         Animation limit on updating individual points
         *
         * @type      {number}
         * @apioption plotOptions.series.animationLimit
         */
        /**
         * Allow this series' points to be selected by clicking on the graphic
         * (columns, point markers, pie slices, map areas etc).
         *
         * The selected points can be handled by point select and unselect
         * events, or collectively by the [getSelectedPoints
         * ](/class-reference/Highcharts.Chart#getSelectedPoints) function.
         *
         * And alternative way of selecting points is through dragging.
         *
         * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
         *         Line
         * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
         *         Column
         * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
         *         Pie
         * @sample {highcharts} highcharts/chart/events-selection-points/
         *         Select a range of points through a drag selection
         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
         *         Map area
         * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
         *         Map bubble
         *
         * @since 1.2.0
         *
         * @private
         */
        allowPointSelect: false,
        /**
         * When true, each point or column edge is rounded to its nearest pixel
         * in order to render sharp on screen. In some cases, when there are a
         * lot of densely packed columns, this leads to visible difference
         * in column widths or distance between columns. In these cases,
         * setting `crisp` to `false` may look better, even though each column
         * is rendered blurry.
         *
         * @sample {highcharts} highcharts/plotoptions/column-crisp-false/
         *         Crisp is false
         *
         * @since   5.0.10
         * @product highcharts highstock gantt
         *
         * @private
         */
        crisp: true,
        /**
         * If true, a checkbox is displayed next to the legend item to allow
         * selecting the series. The state of the checkbox is determined by
         * the `selected` option.
         *
         * @productdesc {highmaps}
         * Note that if a `colorAxis` is defined, the color axis is represented
         * in the legend, not the series.
         *
         * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
         *         Show select box
         *
         * @since 1.2.0
         *
         * @private
         */
        showCheckbox: false,
        /**
         * Enable or disable the initial animation when a series is displayed.
         * The animation can also be set as a configuration object. Please
         * note that this option only applies to the initial animation of the
         * series itself. For other animations, see [chart.animation](
         * #chart.animation) and the animation parameter under the API methods.
         * The following properties are supported:
         *
         * - `defer`: The animation delay time in milliseconds.
         *
         * - `duration`: The duration of the animation in milliseconds. (Defaults to
         *   `1000`)
         *
         * - `easing`: Can be a string reference to an easing function set on
         *   the `Math` object or a function. See the _Custom easing function_
         *   demo below. (Defaults to `easeInOutSine`)
         *
         * Due to poor performance, animation is disabled in old IE browsers
         * for several chart types.
         *
         * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
         *         Animation disabled
         * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
         *         Slower animation
         * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
         *         Custom easing function
         * @sample {highstock} stock/plotoptions/animation-slower/
         *         Slower animation
         * @sample {highstock} stock/plotoptions/animation-easing/
         *         Custom easing function
         * @sample {highmaps} maps/plotoptions/series-animation-true/
         *         Animation enabled on map series
         * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
         *         Disabled on mapbubble series
         *
         * @type    {boolean|Highcharts.AnimationOptionsObject}
         * @default {highcharts} true
         * @default {highstock} true
         * @default {highmaps} false
         *
         * @private
         */
        animation: {
            /** @ignore-option */
            duration: 1000
        },
        /**
         * An additional class name to apply to the series' graphical elements.
         * This option does not replace default class names of the graphical
         * element. Changes to the series' color will also be reflected in a
         * chart's legend and tooltip.
         *
         * @sample {highcharts} highcharts/css/point-series-classname
         *         Series and point class name
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption plotOptions.series.className
         */
        /**
         * Disable this option to allow series rendering in the whole plotting
         * area.
         *
         * **Note:** Clipping should be always enabled when
         * [chart.zoomType](#chart.zoomType) is set
         *
         * @sample {highcharts} highcharts/plotoptions/series-clip/
         *         Disabled clipping
         *
         * @default   true
         * @type      {boolean}
         * @since     3.0.0
         * @apioption plotOptions.series.clip
         */
        /**
         * The main color of the series. In line type series it applies to the
         * line and the point markers unless otherwise specified. In bar type
         * series it applies to the bars unless a color is specified per point.
         * The default value is pulled from the `options.colors` array.
         *
         * In styled mode, the color can be defined by the
         * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
         * color can be set with the `.highcharts-series`,
         * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
         * `.highcharts-series-{n}` class, or individual classes given by the
         * `className` option.
         *
         * @productdesc {highmaps}
         * In maps, the series color is rarely used, as most choropleth maps use
         * the color to denote the value of each point. The series color can
         * however be used in a map with multiple series holding categorized
         * data.
         *
         * @sample {highcharts} highcharts/plotoptions/series-color-general/
         *         General plot option
         * @sample {highcharts} highcharts/plotoptions/series-color-specific/
         *         One specific series
         * @sample {highcharts} highcharts/plotoptions/series-color-area/
         *         Area color
         * @sample {highcharts} highcharts/series/infographic/
         *         Pattern fill
         * @sample {highmaps} maps/demo/category-map/
         *         Category map by multiple series
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.series.color
         */
        /**
         * Styled mode only. A specific color index to use for the series, so its
         * graphic representations are given the class name `highcharts-color-{n}`.
         *
         * Since v11, CSS variables on the form `--highcharts-color-{n}` make
         * changing the color scheme very convenient.
         *
         * @sample    {highcharts} highcharts/css/colorindex/ Series and point color
         *            index
         *
         * @type      {number}
         * @since     5.0.0
         * @apioption plotOptions.series.colorIndex
         */
        /**
         * Whether to connect a graph line across null points, or render a gap
         * between the two points on either side of the null.
         *
         * In stacked area chart, if `connectNulls` is set to true,
         * null points are interpreted as 0.
         *
         * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
         *         False by default
         * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
         *         True
         *
         * @type      {boolean}
         * @default   false
         * @product   highcharts highstock
         * @apioption plotOptions.series.connectNulls
         */
        /**
         * You can set the cursor to "pointer" if you have click events attached
         * to the series, to signal to the user that the points and lines can
         * be clicked.
         *
         * In styled mode, the series cursor can be set with the same classes
         * as listed under [series.color](#plotOptions.series.color).
         *
         * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
         *         On line graph
         * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
         *         On columns
         * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
         *         On scatter markers
         * @sample {highstock} stock/plotoptions/cursor/
         *         Pointer on a line graph
         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
         *         Map area
         * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
         *         Map bubble
         *
         * @type      {string|Highcharts.CursorValue}
         * @apioption plotOptions.series.cursor
         */
        /**
         * A reserved subspace to store options and values for customized
         * functionality. Here you can add additional data for your own event
         * callbacks and formatter callbacks.
         *
         * @sample {highcharts} highcharts/point/custom/
         *         Point and series with custom data
         *
         * @type      {Highcharts.Dictionary<*>}
         * @apioption plotOptions.series.custom
         */
        /**
         * Name of the dash style to use for the graph, or for some series types
         * the outline of each shape.
         *
         * In styled mode, the
         * [stroke dash-array](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-dashstyle/)
         * can be set with the same classes as listed under
         * [series.color](#plotOptions.series.color).
         *
         * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
         *         Possible values demonstrated
         * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
         *         Chart suitable for printing in black and white
         * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
         *         Possible values demonstrated
         * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
         *         Possible values demonstrated
         * @sample {highmaps} maps/plotoptions/series-dashstyle/
         *         Dotted borders on a map
         *
         * @type      {Highcharts.DashStyleValue}
         * @default   Solid
         * @since     2.1
         * @apioption plotOptions.series.dashStyle
         */
        /**
         * A description of the series to add to the screen reader information
         * about the series.
         *
         * @type      {string}
         * @since     5.0.0
         * @requires  modules/accessibility
         * @apioption plotOptions.series.description
         */
        /**
         * Options for the series data sorting.
         *
         * @type      {Highcharts.DataSortingOptionsObject}
         * @since     8.0.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.dataSorting
         */
        /**
         * Enable or disable data sorting for the series. Use [xAxis.reversed](
         * #xAxis.reversed) to change the sorting order.
         *
         * @sample {highcharts} highcharts/datasorting/animation/
         *         Data sorting in scatter-3d
         * @sample {highcharts} highcharts/datasorting/labels-animation/
         *         Axis labels animation
         * @sample {highcharts} highcharts/datasorting/dependent-sorting/
         *         Dependent series sorting
         * @sample {highcharts} highcharts/datasorting/independent-sorting/
         *         Independent series sorting
         *
         * @type      {boolean}
         * @since     8.0.0
         * @apioption plotOptions.series.dataSorting.enabled
         */
        /**
         * Whether to allow matching points by name in an update. If this option
         * is disabled, points will be matched by order.
         *
         * @sample {highcharts} highcharts/datasorting/match-by-name/
         *         Enabled match by name
         *
         * @type      {boolean}
         * @since     8.0.0
         * @apioption plotOptions.series.dataSorting.matchByName
         */
        /**
         * Determines what data value should be used to sort by.
         *
         * @sample {highcharts} highcharts/datasorting/sort-key/
         *         Sort key as `z` value
         *
         * @type      {string}
         * @since     8.0.0
         * @default   y
         * @apioption plotOptions.series.dataSorting.sortKey
         */
        /**
         * Enable or disable the mouse tracking for a specific series. This
         * includes point tooltips and click events on graphs and points. For
         * large datasets it improves performance.
         *
         * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/
         *         No mouse tracking
         * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/
         *         No mouse tracking
         *
         * @type      {boolean}
         * @default   true
         * @apioption plotOptions.series.enableMouseTracking
         */
        enableMouseTracking: true,
        /**
         * Whether to use the Y extremes of the total chart width or only the
         * zoomed area when zooming in on parts of the X axis. By default, the
         * Y axis adjusts to the min and max of the visible data. Cartesian
         * series only.
         *
         * @type      {boolean}
         * @default   false
         * @since     4.1.6
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.getExtremesFromAll
         */
        /**
         * Highlight only the hovered point and fade the remaining points.
         *
         * Scatter-type series require enabling the 'inactive' marker state and
         * adjusting opacity. Note that this approach could affect performance
         * with large datasets.
         *
         * @sample {highcharts} highcharts/plotoptions/series-inactiveotherpoints-enabled/
         *         Chart with inactiveOtherPoints option enabled.
         *
         * @type      {boolean}
         * @default   false
         * @apioption plotOptions.series.inactiveOtherPoints
         */
        /**
         * An array specifying which option maps to which key in the data point
         * array. This makes it convenient to work with unstructured data arrays
         * from different sources.
         *
         * @see [series.data](#series.line.data)
         *
         * @sample {highcharts|highstock} highcharts/series/data-keys/
         *         An extended data array with keys
         * @sample {highcharts|highstock} highcharts/series/data-nested-keys/
         *         Nested keys used to access object properties
         *
         * @type      {Array<string>}
         * @since     4.1.6
         * @apioption plotOptions.series.keys
         */
        /**
         * The line cap used for line ends and line joins on the graph.
         *
         * @sample highcharts/series-line/linecap/
         *         Line cap comparison
         *
         * @type       {Highcharts.SeriesLinecapValue}
         * @default    round
         * @product    highcharts highstock
         * @apioption  plotOptions.series.linecap
         */
        /**
         * The [id](#series.id) of another series to link to. Additionally,
         * the value can be ":previous" to link to the previous series. When
         * two series are linked, only the first one appears in the legend.
         * Toggling the visibility of this also toggles the linked series.
         *
         * If master series uses data sorting and linked series does not have
         * its own sorting definition, the linked series will be sorted in the
         * same order as the master one.
         *
         * @sample {highcharts|highstock} highcharts/demo/arearange-line/
         *         Linked series
         *
         * @type      {string}
         * @since     3.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.linkedTo
         */
        /**
         * Options for the corresponding navigator series if `showInNavigator`
         * is `true` for this series. Available options are the same as any
         * series, documented at [plotOptions](#plotOptions.series) and
         * [series](#series).
         *
         * These options are merged with options in [navigator.series](
         * #navigator.series), and will take precedence if the same option is
         * defined both places.
         *
         * @see [navigator.series](#navigator.series)
         *
         * @type      {Highcharts.PlotSeriesOptions}
         * @since     5.0.0
         * @product   highstock
         * @apioption plotOptions.series.navigatorOptions
         */
        /**
         * The color for the parts of the graph or points that are below the
         * [threshold](#plotOptions.series.threshold). Note that `zones` takes
         * precedence over the negative color. Using `negativeColor` is
         * equivalent to applying a zone with value of 0.
         *
         * @see In styled mode, a negative color is applied by setting this option
         *      to `true` combined with the `.highcharts-negative` class name.
         *
         * @sample {highcharts} highcharts/plotoptions/series-negative-color/
         *         Spline, area and column
         * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
         *         Arearange
         * @sample {highcharts} highcharts/css/series-negative-color/
         *         Styled mode
         * @sample {highstock} highcharts/plotoptions/series-negative-color/
         *         Spline, area and column
         * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
         *         Arearange
         * @sample {highmaps} highcharts/plotoptions/series-negative-color/
         *         Spline, area and column
         * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
         *         Arearange
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     3.0
         * @apioption plotOptions.series.negativeColor
         */
        /**
         * Same as
         * [accessibility.point.descriptionFormat](#accessibility.point.descriptionFormat),
         * but for an individual series. Overrides the chart wide configuration.
         *
         * @type      {Function}
         * @since 11.1.0
         * @apioption plotOptions.series.pointDescriptionFormat
         */
        /**
         * Same as
         * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
         * but for an individual series. Overrides the chart wide configuration.
         *
         * @type      {Function}
         * @since     5.0.12
         * @apioption plotOptions.series.pointDescriptionFormatter
         */
        /**
         * If no x values are given for the points in a series, `pointInterval`
         * defines the interval of the x values. For example, if a series
         * contains one value every decade starting from year 0, set
         * `pointInterval` to `10`. In true `datetime` axes, the `pointInterval`
         * is set in milliseconds.
         *
         * It can be also be combined with `pointIntervalUnit` to draw irregular
         * time intervals.
         *
         * If combined with `relativeXValue`, an x value can be set on each
         * point, and the `pointInterval` is added x times to the `pointStart`
         * setting.
         *
         * Please note that this options applies to the _series data_, not the
         * interval of the axis ticks, which is independent.
         *
         * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
         *         Datetime X axis
         * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
         *         Relative x value
         * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
         *         Using pointStart and pointInterval
         * @sample {highstock} stock/plotoptions/relativexvalue/
         *         Relative x value
         *
         * @type      {number}
         * @default   1
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.pointInterval
         */
        /**
         * On datetime series, this allows for setting the
         * [pointInterval](#plotOptions.series.pointInterval) to irregular time
         * units, `day`, `month` and `year`. A day is usually the same as 24
         * hours, but `pointIntervalUnit` also takes the DST crossover into
         * consideration when dealing with local time. Combine this option with
         * `pointInterval` to draw weeks, quarters, 6 months, 10 years etc.
         *
         * Please note that this options applies to the _series data_, not the
         * interval of the axis ticks, which is independent.
         *
         * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
         *         One point a month
         * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
         *         One point a month
         *
         * @type       {string}
         * @since      4.1.0
         * @product    highcharts highstock gantt
         * @validvalue ["day", "month", "year"]
         * @apioption  plotOptions.series.pointIntervalUnit
         */
        /**
         * Possible values: `"on"`, `"between"`, `number`.
         *
         * In a column chart, when pointPlacement is `"on"`, the point will not
         * create any padding of the X axis. In a polar column chart this means
         * that the first column points directly north. If the pointPlacement is
         * `"between"`, the columns will be laid out between ticks. This is
         * useful for example for visualising an amount between two points in
         * time or in a certain sector of a polar chart.
         *
         * Since Highcharts 3.0.2, the point placement can also be numeric,
         * where 0 is on the axis value, -0.5 is between this value and the
         * previous, and 0.5 is between this value and the next. Unlike the
         * textual options, numeric point placement options won't affect axis
         * padding.
         *
         * Note that pointPlacement needs a [pointRange](
         * #plotOptions.series.pointRange) to work. For column series this is
         * computed, but for line-type series it needs to be set.
         *
         * For the `xrange` series type and gantt charts, if the Y axis is a
         * category axis, the `pointPlacement` applies to the Y axis rather than
         * the (typically datetime) X axis.
         *
         * Defaults to `undefined` in cartesian charts, `"between"` in polar
         * charts.
         *
         * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
         *
         * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/
         *         Between in a column chart
         * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/
         *         Numeric placement for custom layout
         * @sample {highcharts|highstock} maps/plotoptions/heatmap-pointplacement/
         *         Placement in heatmap
         *
         * @type      {string|number}
         * @since     2.3.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.pointPlacement
         */
        /**
         * If no x values are given for the points in a series, pointStart
         * defines on what value to start. For example, if a series contains one
         * yearly value starting from 1945, set pointStart to 1945.
         *
         * If combined with `relativeXValue`, an x value can be set on each
         * point. The x value from the point options is multiplied by
         * `pointInterval` and added to `pointStart` to produce a modified x
         * value.
         *
         * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
         *         Linear
         * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
         *         Datetime
         * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
         *         Relative x value
         * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
         *         Using pointStart and pointInterval
         * @sample {highstock} stock/plotoptions/relativexvalue/
         *         Relative x value
         *
         * @type      {number}
         * @default   0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.pointStart
         */
        /**
         * When true, X values in the data set are relative to the current
         * `pointStart`, `pointInterval` and `pointIntervalUnit` settings. This
         * allows compression of the data for datasets with irregular X values.
         *
         * The real X values are computed on the formula `f(x) = ax + b`, where
         * `a` is the `pointInterval` (optionally with a time unit given by
         * `pointIntervalUnit`), and `b` is the `pointStart`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
         *         Relative X value
         * @sample {highstock} stock/plotoptions/relativexvalue/
         *         Relative X value
         *
         * @type      {boolean}
         * @default   false
         * @product   highcharts highstock
         * @apioption plotOptions.series.relativeXValue
         */
        /**
         * Whether to select the series initially. If `showCheckbox` is true,
         * the checkbox next to the series name in the legend will be checked
         * for a selected series.
         *
         * @sample {highcharts} highcharts/plotoptions/series-selected/
         *         One out of two series selected
         *
         * @type      {boolean}
         * @default   false
         * @since     1.2.0
         * @apioption plotOptions.series.selected
         */
        /**
         * Whether to apply a drop shadow to the graph line. Since 2.3 the
         * shadow can be an object configuration containing `color`, `offsetX`,
         * `offsetY`, `opacity` and `width`.
         *
         * Note that in some cases, like stacked columns or other dense layouts, the
         * series may cast shadows on each other. In that case, the
         * `chart.seriesGroupShadow` allows applying a common drop shadow to the
         * whole series group.
         *
         * @sample {highcharts} highcharts/plotoptions/series-shadow/
         *         Shadow enabled
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @apioption plotOptions.series.shadow
         */
        /**
         * Whether to display this particular series or series type in the
         * legend. Standalone series are shown in legend by default, and linked
         * series are not. Since v7.2.0 it is possible to show series that use
         * colorAxis by setting this option to `true`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
         *         One series in the legend, one hidden
         *
         * @type      {boolean}
         * @apioption plotOptions.series.showInLegend
         */
        /**
         * Whether or not to show the series in the navigator. Takes precedence
         * over [navigator.baseSeries](#navigator.baseSeries) if defined.
         *
         * @type      {boolean}
         * @since     5.0.0
         * @product   highstock
         * @apioption plotOptions.series.showInNavigator
         */
        /**
         * If set to `true`, the accessibility module will skip past the points
         * in this series for keyboard navigation.
         *
         * @type      {boolean}
         * @since     5.0.12
         * @apioption plotOptions.series.skipKeyboardNavigation
         */
        /**
         * Whether to stack the values of each series on top of each other.
         * Possible values are `undefined` to disable, `"normal"` to stack by
         * value or `"percent"`.
         *
         * When stacking is enabled, data must be sorted
         * in ascending X order.
         *
         * Some stacking options are related to specific series types. In the
         * streamgraph series type, the stacking option is set to `"stream"`.
         * The second one is `"overlap"`, which only applies to waterfall
         * series.
         *
         * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
         *
         * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
         *         Line
         * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
         *         Column
         * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
         *         Bar
         * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
         *         Area
         * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
         *         Line
         * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/
         *         Column
         * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
         *         Bar
         * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
         *         Area
         * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-normal-stacking
         *         Waterfall with normal stacking
         * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-overlap-stacking
         *         Waterfall with overlap stacking
         * @sample {highstock} stock/plotoptions/stacking/
         *         Area
         *
         * @type       {string}
         * @product    highcharts highstock
         * @validvalue ["normal", "overlap", "percent", "stream"]
         * @apioption  plotOptions.series.stacking
         */
        /**
         * Whether to apply steps to the line. Possible values are `left`,
         * `center` and `right`.
         *
         * @sample {highcharts} highcharts/plotoptions/line-step/
         *         Different step line options
         * @sample {highcharts} highcharts/plotoptions/area-step/
         *         Stepped, stacked area
         * @sample {highstock} stock/plotoptions/line-step/
         *         Step line
         *
         * @type       {string}
         * @since      1.2.5
         * @product    highcharts highstock
         * @validvalue ["left", "center", "right"]
         * @apioption  plotOptions.series.step
         */
        /**
         * The threshold, also called zero level or base level. For line type
         * series this is only used in conjunction with
         * [negativeColor](#plotOptions.series.negativeColor).
         *
         * @see [softThreshold](#plotOptions.series.softThreshold).
         *
         * @type      {number|null}
         * @default   0
         * @since     3.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.threshold
         */
        /**
         * Set the initial visibility of the series.
         *
         * @sample {highcharts} highcharts/plotoptions/series-visible/
         *         Two series, one hidden and one visible
         * @sample {highstock} stock/plotoptions/series-visibility/
         *         Hidden series
         *
         * @type      {boolean}
         * @default   true
         * @apioption plotOptions.series.visible
         */
        /**
         * Defines the Axis on which the zones are applied.
         *
         * @see [zones](#plotOptions.series.zones)
         *
         * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
         *         Zones on the X-Axis
         * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
         *         Zones on the X-Axis
         *
         * @type      {string}
         * @default   y
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zoneAxis
         */
        /**
         * General event handlers for the series items. These event hooks can
         * also be attached to the series at run time using the
         * `Highcharts.addEvent` function.
         *
         * @declare Highcharts.SeriesEventsOptionsObject
         *
         * @private
         */
        events: {},
        /**
         * Fires after the series has finished its initial animation, or in case
         * animation is disabled, immediately as the series is displayed.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/
         *         Show label after animate
         * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/
         *         Show label after animate
         *
         * @type      {Highcharts.SeriesAfterAnimateCallbackFunction}
         * @since     4.0
         * @product   highcharts highstock gantt
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.afterAnimate
         */
        /**
         * Fires when the checkbox next to the series' name in the legend is
         * clicked. One parameter, `event`, is passed to the function. The state
         * of the checkbox is found by `event.checked`. The checked item is
         * found by `event.item`. Return `false` to prevent the default action
         * which is to toggle the select state of the series.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
         *         Alert checkbox status
         *
         * @type      {Highcharts.SeriesCheckboxClickCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.checkboxClick
         */
        /**
         * Fires when the series is clicked. One parameter, `event`, is passed
         * to the function, containing common event information. Additionally,
         * `event.point` holds a pointer to the nearest point on the graph.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-click/
         *         Alert click info
         * @sample {highstock} stock/plotoptions/series-events-click/
         *         Alert click info
         * @sample {highmaps} maps/plotoptions/series-events-click/
         *         Display click info in subtitle
         *
         * @type      {Highcharts.SeriesClickCallbackFunction}
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.click
         */
        /**
         * Fires when the series is hidden after chart generation time, either
         * by clicking the legend item or by calling `.hide()`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-hide/
         *         Alert when the series is hidden by clicking the legend item
         *
         * @type      {Highcharts.SeriesHideCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.hide
         */
        /**
         * Fires when the legend item belonging to the series is clicked. One
         * parameter, `event`, is passed to the function. The default action
         * is to toggle the visibility of the series. This can be prevented
         * by returning `false` or calling `event.preventDefault()`.
         *
         * **Note:** This option is deprecated in favor of
         * [legend.events.itemClick](#legend.events.itemClick).
         *
         * @type       {Highcharts.SeriesLegendItemClickCallbackFunction}
         * @deprecated 11.4.4
         * @context    Highcharts.Series
         * @apioption  plotOptions.series.events.legendItemClick
         */
        /**
         * Fires when the mouse leaves the graph. One parameter, `event`, is
         * passed to the function, containing common event information. If the
         * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
         * doesn't happen before the mouse enters another graph or leaves the
         * plot area.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
         *         With sticky tracking by default
         * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
         *         Without sticky tracking
         *
         * @type      {Highcharts.SeriesMouseOutCallbackFunction}
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.mouseOut
         */
        /**
         * Fires when the mouse enters the graph. One parameter, `event`, is
         * passed to the function, containing common event information.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
         *         With sticky tracking by default
         * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
         *         Without sticky tracking
         *
         * @type      {Highcharts.SeriesMouseOverCallbackFunction}
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.mouseOver
         */
        /**
         * Fires when the series is shown after chart generation time, either
         * by clicking the legend item or by calling `.show()`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-show/
         *         Alert when the series is shown by clicking the legend item.
         *
         * @type      {Highcharts.SeriesShowCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.show
         */
        /**
         * Options for the point markers of line and scatter-like series. Properties
         * like `fillColor`, `lineColor` and `lineWidth` define the visual
         * appearance of the markers. The `symbol` option defines the shape. Other
         * series types, like column series, don't have markers, but have visual
         * options on the series level instead.
         *
         * In styled mode, the markers can be styled with the `.highcharts-point`,
         * `.highcharts-point-hover` and `.highcharts-point-select` class names.
         *
         * @declare Highcharts.PointMarkerOptionsObject
         *
         * @sample {highmaps} maps/demo/mappoint-mapmarker
         *         Using the mapmarker symbol for points
         *
         * @private
         */
        marker: {
            /**
             * Enable or disable the point marker. If `undefined`, the markers
             * are hidden when the data is dense, and shown for more widespread
             * data points.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
             *         Disabled markers
             * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/
             *         Disabled in normal state but enabled on hover
             * @sample {highstock} stock/plotoptions/series-marker/
             *         Enabled markers
             *
             * @type      {boolean}
             * @default   {highcharts} undefined
             * @default   {highstock} false
             * @apioption plotOptions.series.marker.enabled
             */
            /**
             * The threshold for how dense the point markers should be before
             * they are hidden, given that `enabled` is not defined. The number
             * indicates the horizontal distance between the two closest points
             * in the series, as multiples of the `marker.radius`. In other
             * words, the default value of 2 means points are hidden if
             * overlapping horizontally.
             *
             * @sample highcharts/plotoptions/series-marker-enabledthreshold
             *         A higher threshold
             *
             * @since 6.0.5
             */
            enabledThreshold: 2,
            /**
             * The fill color of the point marker. When `undefined`, the series'
             * or point's color is used.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
             *         White fill
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption plotOptions.series.marker.fillColor
             */
            /**
             * Image markers only. Set the image width explicitly. When using
             * this option, a `width` must also be set.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
             *         Fixed width and height
             * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
             *         Fixed width and height
             *
             * @type      {number}
             * @since     4.0.4
             * @apioption plotOptions.series.marker.height
             */
            /**
             * The color of the point marker's outline. When `undefined`, the
             * series' or point's color is used.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
             *         Inherit from series color (undefined)
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            lineColor: "#ffffff" /* Palette.backgroundColor */,
            /**
             * The width of the point marker's outline.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
             *         2px blue marker
             */
            lineWidth: 0,
            /**
             * The radius of the point marker.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
             *         Bigger markers
             *
             * @default {highstock} 2
             * @default {highcharts} 4
             *
             */
            radius: 4,
            /**
             * A predefined shape or symbol for the marker. When undefined, the
             * symbol is pulled from options.symbols. Other possible values are
             * `'circle'`, `'square'`,`'diamond'`, `'triangle'` and
             * `'triangle-down'`.
             *
             * Additionally, the URL to a graphic can be given on this form:
             * `'url(graphic.png)'`. Note that for the image to be applied to
             * exported charts, its URL needs to be accessible by the export
             * server.
             *
             * Custom callbacks for symbol path generation can also be added to
             * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
             * used by its method name, as shown in the demo.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
             *         Predefined, graphic and custom markers
             * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
             *         Predefined, graphic and custom markers
             * @sample {highmaps} maps/demo/mappoint-mapmarker
             *         Using the mapmarker symbol for points
             *
             * @type      {string}
             * @apioption plotOptions.series.marker.symbol
             */
            /**
             * Image markers only. Set the image width explicitly. When using
             * this option, a `height` must also be set.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
             *         Fixed width and height
             * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
             *         Fixed width and height
             *
             * @type      {number}
             * @since     4.0.4
             * @apioption plotOptions.series.marker.width
             */
            /**
             * States for a single point marker.
             *
             * @declare Highcharts.PointStatesOptionsObject
             */
            states: {
                /**
                 * The normal state of a single point marker. Currently only
                 * used for setting animation when returning to normal state
                 * from hover.
                 *
                 * @declare Highcharts.PointStatesNormalOptionsObject
                 */
                normal: {
                    /**
                     * Animation when returning to normal state after hovering.
                     *
                     * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                     */
                    animation: true
                },
                /**
                 * The hover state for a single point marker.
                 *
                 * @declare Highcharts.PointStatesHoverOptionsObject
                 */
                hover: {
                    /**
                     * Animation when hovering over the marker.
                     *
                     * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                     */
                    animation: {
                        /** @internal */
                        duration: 150
                    },
                    /**
                     * Enable or disable the point marker.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/
                     *         Disabled hover state
                     */
                    enabled: true,
                    /**
                     * The fill color of the marker in hover state. When
                     * `undefined`, the series' or point's fillColor for normal
                     * state is used.
                     *
                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                     * @apioption plotOptions.series.marker.states.hover.fillColor
                     */
                    /**
                     * The color of the point marker's outline. When
                     * `undefined`, the series' or point's lineColor for normal
                     * state is used.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/
                     *         White fill color, black line color
                     *
                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                     * @apioption plotOptions.series.marker.states.hover.lineColor
                     */
                    /**
                     * The width of the point marker's outline. When
                     * `undefined`, the series' or point's lineWidth for normal
                     * state is used.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/
                     *         3px line width
                     *
                     * @type      {number}
                     * @apioption plotOptions.series.marker.states.hover.lineWidth
                     */
                    /**
                     * The radius of the point marker. In hover state, it
                     * defaults to the normal state's radius + 2 as per the
                     * [radiusPlus](#plotOptions.series.marker.states.hover.radiusPlus)
                     * option.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/
                     *         10px radius
                     *
                     * @type      {number}
                     * @apioption plotOptions.series.marker.states.hover.radius
                     */
                    /**
                     * The number of pixels to increase the radius of the
                     * hovered point.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                     *         5 pixels greater radius on hover
                     * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                     *         5 pixels greater radius on hover
                     *
                     * @since 4.0.3
                     */
                    radiusPlus: 2,
                    /**
                     * The additional line width for a hovered point.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                     *         2 pixels wider on hover
                     * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                     *         2 pixels wider on hover
                     *
                     * @since 4.0.3
                     */
                    lineWidthPlus: 1
                },
                /**
                 * The appearance of the point marker when selected. In order to
                 * allow a point to be selected, set the
                 * `series.allowPointSelect` option to true.
                 *
                 * @declare Highcharts.PointStatesSelectOptionsObject
                 */
                select: {
                    /**
                     * Enable or disable visible feedback for selection.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-enabled/
                     *         Disabled select state
                     *
                     * @type      {boolean}
                     * @default   true
                     * @apioption plotOptions.series.marker.states.select.enabled
                     */
                    /**
                     * The radius of the point marker. In hover state, it
                     * defaults to the normal state's radius + 2.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-radius/
                     *         10px radius for selected points
                     *
                     * @type      {number}
                     * @apioption plotOptions.series.marker.states.select.radius
                     */
                    /**
                     * The fill color of the point marker.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/
                     *         Solid red discs for selected points
                     *
                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                     */
                    fillColor: "#cccccc" /* Palette.neutralColor20 */,
                    /**
                     * The color of the point marker's outline. When
                     * `undefined`, the series' or point's color is used.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/
                     *         Red line color for selected points
                     *
                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                     */
                    lineColor: "#000000" /* Palette.neutralColor100 */,
                    /**
                     * The width of the point marker's outline.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/
                     *         3px line width for selected points
                     */
                    lineWidth: 2
                }
            }
        },
        /**
         * Properties for each single point.
         *
         * @declare Highcharts.PlotSeriesPointOptions
         *
         * @private
         */
        point: {
            /**
             * Fires when a point is clicked. One parameter, `event`, is passed
             * to the function, containing common event information.
             *
             * If the `series.allowPointSelect` option is true, the default
             * action for the point's click event is to toggle the point's
             * select state. Returning `false` cancels this action.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-click/
             *         Click marker to alert values
             * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/
             *         Click column
             * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/
             *         Go to URL
             * @sample {highmaps} maps/plotoptions/series-point-events-click/
             *         Click marker to display values
             * @sample {highmaps} maps/plotoptions/series-point-events-click-url/
             *         Go to URL
             *
             * @type      {Highcharts.PointClickCallbackFunction}
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.click
             */
            /**
             * Fires when the mouse leaves the area close to the point. One
             * parameter, `event`, is passed to the function, containing common
             * event information.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
             *         Show values in the chart's corner on mouse over
             *
             * @type      {Highcharts.PointMouseOutCallbackFunction}
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.mouseOut
             */
            /**
             * Fires when the mouse enters the area close to the point. One
             * parameter, `event`, is passed to the function, containing common
             * event information.
             *
             * Returning `false` cancels the default behavior, which is to show a
             * tooltip for the point.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
             *         Show values in the chart's corner on mouse over
             *
             * @type      {Highcharts.PointMouseOverCallbackFunction}
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.mouseOver
             */
            /**
             * Fires when the point is removed using the `.remove()` method. One
             * parameter, `event`, is passed to the function. Returning `false`
             * cancels the operation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/
             *         Remove point and confirm
             *
             * @type      {Highcharts.PointRemoveCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.remove
             */
            /**
             * Fires when the point is selected either programmatically or
             * following a click on the point. One parameter, `event`, is passed
             * to the function. Returning `false` cancels the operation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-select/
             *         Report the last selected point
             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
             *         Report select and unselect
             *
             * @type      {Highcharts.PointSelectCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.select
             */
            /**
             * Fires when the point is unselected either programmatically or
             * following a click on the point. One parameter, `event`, is passed
             * to the function.
             *  Returning `false` cancels the operation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/
             *         Report the last unselected point
             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
             *         Report select and unselect
             *
             * @type      {Highcharts.PointUnselectCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.unselect
             */
            /**
             * Fires when the point is updated programmatically through the
             * `.update()` method. One parameter, `event`, is passed to the
             * function. The new point options can be accessed through
             * `event.options`. Returning `false` cancels the operation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-update/
             *         Confirm point updating
             *
             * @type      {Highcharts.PointUpdateCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.update
             */
            /**
             * Events for each single point.
             *
             * @declare Highcharts.PointEventsOptionsObject
             */
            events: {}
        },
        /**
         * Options for the series data labels, appearing next to each data
         * point.
         *
         * Since v6.2.0, multiple data labels can be applied to each single
         * point by defining them as an array of configs.
         *
         * In styled mode, the data labels can be styled with the
         * `.highcharts-data-label-box` and `.highcharts-data-label` class names
         * ([see example](https://www.highcharts.com/samples/highcharts/css/series-datalabels)).
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled
         *         Data labels enabled
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-multiple
         *         Multiple data labels on a bar series
         * @sample {highcharts} highcharts/css/series-datalabels
         *         Styled mode example
         * @sample {highmaps} maps/demo/color-axis
         *         Choropleth map with data labels
         * @sample {highmaps} maps/demo/mappoint-datalabels-mapmarker
         *         Using data labels as map markers
         *
         * @type    {*|Array<*>}
         * @product highcharts highstock highmaps gantt
         *
         * @private
         */
        dataLabels: {
            /**
             * Enable or disable the initial animation when a series is displayed
             * for the `dataLabels`. The animation can also be set as a
             * configuration object. Please note that this option only applies to
             * the initial animation.
             *
             * For other animations, see [chart.animation](#chart.animation) and the
             * animation parameter under the API methods. The following properties
             * are supported:
             *
             * - `defer`: The animation delay time in milliseconds.
             *
             * @sample {highcharts} highcharts/plotoptions/animation-defer/
             *          Animation defer settings
             *
             * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
             * @since     8.2.0
             * @apioption plotOptions.series.dataLabels.animation
             */
            animation: {},
            /**
             * The animation delay time in milliseconds. Set to `0` to render the
             * data labels immediately. As `undefined` inherits defer time from the
             * [series.animation.defer](#plotOptions.series.animation.defer).
             *
             * @type      {number}
             * @since     8.2.0
             * @apioption plotOptions.series.dataLabels.animation.defer
             */
            /**
             * The alignment of the data label compared to the point. If `right`,
             * the right side of the label should be touching the point. For points
             * with an extent, like columns, the alignments also dictates how to
             * align it inside the box, as given with the
             * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of
             * `left`, `center` or `right`.
             *
             * @sample {highcharts}
             *         highcharts/plotoptions/series-datalabels-align-left/ Left
             *         aligned
             * @sample {highcharts}
             *         highcharts/plotoptions/bar-datalabels-align-inside-bar/ Data
             *         labels inside the bar
             *
             * @type {Highcharts.AlignValue|null}
             */
            align: 'center',
            /**
             * Alignment method for data labels. If set to `plotEdges`, the labels
             * are aligned within the plot area in the direction of the y-axis. So
             * in a regular column chart, the labels are aligned vertically
             * according to the `verticalAlign` setting. In a bar chart, which is
             * inverted, the labels are aligned horizontally according to the
             * `align` setting. Applies to cartesian series only.
             *
             * @sample {highcharts} highcharts/series-bar/datalabels-alignto/
             *         Align to plot edges
             *
             * @type      {string}
             * @since 11.4.2
             * @apioption plotOptions.series.dataLabels.alignTo
             */
            /**
             * Whether to allow data labels to overlap. To make the labels less
             * sensitive for overlapping, the
             * [dataLabels.padding](#plotOptions.series.dataLabels.padding)
             * can be set to 0.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/
             *         Don't allow overlap
             *
             * @type      {boolean}
             * @default   false
             * @since     4.1.0
             * @apioption plotOptions.series.dataLabels.allowOverlap
             */
            /**
             * The background color or gradient for the data label. Setting it to
             * `auto` will use the point's color.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             * @sample {highmaps} maps/plotoptions/series-datalabels-box/
             *         Data labels box options
             * @sample {highmaps} maps/demo/mappoint-datalabels-mapmarker
             *         Data labels as map markers
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.backgroundColor
             */
            /**
             * The border color for the data label. Setting it to `auto` will use
             * the point's color. Defaults to `undefined`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.borderColor
             */
            /**
             * The border radius in pixels for the data label.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             * @sample {highmaps} maps/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @type      {number}
             * @default   0
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.borderRadius
             */
            /**
             * The border width in pixels for the data label.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @type      {number}
             * @default   0
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.borderWidth
             */
            borderWidth: 0,
            /**
             * A class name for the data label. Particularly in styled mode,
             * this can be used to give each series' or point's data label
             * unique styling. In addition to this option, a default color class
             * name is added so that we can give the labels a contrast text
             * shadow.
             *
             * @sample {highcharts} highcharts/css/data-label-contrast/
             *         Contrast text shadow
             * @sample {highcharts} highcharts/css/series-datalabels/
             *         Styling by CSS
             *
             * @type      {string}
             * @since     5.0.0
             * @apioption plotOptions.series.dataLabels.className
             */
            /**
             * This options is deprecated.
             * Use [style.color](#plotOptions.series.dataLabels.style) instead.
             *
             * The text color for the data labels. Defaults to `undefined`. For
             * certain series types, like column or map, the data labels can be
             * drawn inside the points. In this case the data label will be
             * drawn with maximum contrast by default. Additionally, it will be
             * given a `text-outline` style with the opposite color, to further
             * increase the contrast. This can be overridden by setting the
             * `text-outline` style to `none` in the `dataLabels.style` option.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
             *         Red data labels
             * @sample {highmaps} maps/demo/color-axis/
             *         White data labels
             *
             * @see [style.color](#plotOptions.series.dataLabels.style)
             *
             * @type       {Highcharts.ColorType}
             * @deprecated 10.3
             * @apioption  plotOptions.series.dataLabels.color
             */
            /**
             * Whether to hide data labels that are outside the plot area. By
             * default, the data label is moved inside the plot area according
             * to the
             * [overflow](#plotOptions.series.dataLabels.overflow)
             * option.
             *
             * @type      {boolean}
             * @default   true
             * @since     2.3.3
             * @apioption plotOptions.series.dataLabels.crop
             */
            /**
             * Whether to defer displaying the data labels until the initial
             * series animation has finished. Setting to `false` renders the
             * data label immediately. If set to `true` inherits the defer
             * time set in [plotOptions.series.animation](#plotOptions.series.animation).
             *
             * @since     4.0.0
             * @type      {boolean}
             * @product   highcharts highstock gantt
             */
            defer: true,
            /**
             * Enable or disable the data labels.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/
             *         Data labels enabled
             * @sample {highmaps} maps/demo/color-axis/
             *         Data labels enabled
             *
             * @type      {boolean}
             * @default   false
             * @apioption plotOptions.series.dataLabels.enabled
             */
            /**
             * A declarative filter to control of which data labels to display.
             * The declarative filter is designed for use when callback
             * functions are not available, like when the chart options require
             * a pure JSON structure or for use with graphical editors. For
             * programmatic control, use the `formatter` instead, and return
             * `undefined` to disable a single data label.
             *
             * @example
             * filter: {
             *     property: 'percentage',
             *     operator: '>',
             *     value: 4
             * }
             *
             * @sample {highcharts} highcharts/demo/pie-monochrome
             *         Data labels filtered by percentage
             *
             * @declare   Highcharts.DataLabelsFilterOptionsObject
             * @since     6.0.3
             * @apioption plotOptions.series.dataLabels.filter
             */
            /**
             * The operator to compare by. Can be one of `>`, `<`, `>=`, `<=`,
             * `==`, `===`, `!=` and `!==`.
             *
             * @type       {string}
             * @validvalue [">", "<", ">=", "<=", "==", "===", "!=", "!=="]
             * @apioption  plotOptions.series.dataLabels.filter.operator
             */
            /**
             * The point property to filter by. Point options are passed
             * directly to properties, additionally there are `y` value,
             * `percentage` and others listed under {@link Highcharts.Point}
             * members.
             *
             * @type      {string}
             * @apioption plotOptions.series.dataLabels.filter.property
             */
            /**
             * The value to compare against.
             *
             * @type      {number}
             * @apioption plotOptions.series.dataLabels.filter.value
             */
            /**
             * A
             * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * for the data label. Available variables are the same as for
             * `formatter`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
             *         Add a unit
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-format-subexpression/
             *         Complex logic in the format string
             * @sample {highmaps} maps/plotoptions/series-datalabels-format/
             *         Formatted value in the data label
             *
             * @type      {string}
             * @default   y
             * @default   point.value
             * @since     3.0
             * @apioption plotOptions.series.dataLabels.format
             */
            // eslint-disable-next-line valid-jsdoc
            /**
             * Callback JavaScript function to format the data label. Note that if a
             * `format` is defined, the format takes precedence and the formatter is
             * ignored.
             *
             * @sample {highmaps} maps/plotoptions/series-datalabels-format/
             *         Formatted value
             *
             * @type {Highcharts.DataLabelsFormatterCallbackFunction}
             */
            formatter: function () {
                const { numberFormatter } = this.series.chart;
                return typeof this.y !== 'number' ?
                    '' : numberFormatter(this.y, -1);
            },
            /**
             * For points with an extent, like columns or map areas, whether to
             * align the data label inside the box or to the actual value point.
             * Defaults to `false` in most cases, `true` in stacked columns.
             *
             * @type      {boolean}
             * @since     3.0
             * @apioption plotOptions.series.dataLabels.inside
             */
            /**
             * Format for points with the value of null. Works analogously to
             * [format](#plotOptions.series.dataLabels.format). `nullFormat` can
             * be applied only to series which support displaying null points
             * i.e `heatmap` or `tilemap`. Does not work with series that don't
             * display null points, like `line`, `column`, `bar` or `pie`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-nullformat/
             *         Format data label for null points in heat map
             *
             * @type      {boolean|string}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.nullFormat
             */
            /**
             * Callback JavaScript function that defines formatting for points
             * with the value of null. Works analogously to
             * [formatter](#plotOptions.series.dataLabels.formatter).
             * `nullFormatter` can be applied only to series which support
             * displaying null points i.e `heatmap` or `tilemap`. Does not work
             * with series that don't display null points, like `line`, `column`,
             * `bar` or `pie`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-nullformat/
             *         Format data label for null points in heat map
             *
             * @type      {Highcharts.DataLabelsFormatterCallbackFunction}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.nullFormatter
             */
            /**
             * How to handle data labels that flow outside the plot area. The
             * default is `"justify"`, which aligns them inside the plot area.
             * For columns and bars, this means it will be moved inside the bar.
             * To display data labels outside the plot area, set `crop` to
             * `false` and `overflow` to `"allow"`.
             *
             * @type       {Highcharts.DataLabelsOverflowValue}
             * @default    justify
             * @since      3.0.6
             * @apioption  plotOptions.series.dataLabels.overflow
             */
            /**
             * When either the `borderWidth` or the `backgroundColor` is set,
             * this is the padding within the box.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             * @sample {highmaps} maps/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @since 2.2.1
             */
            padding: 5,
            /**
             * Aligns data labels relative to points. If `center` alignment is
             * not possible, it defaults to `right`.
             *
             * @type      {Highcharts.AlignValue}
             * @default   center
             * @apioption plotOptions.series.dataLabels.position
             */
            /**
             * Text rotation in degrees. Note that due to a more complex
             * structure, backgrounds, borders and padding will be lost on a
             * rotated data label.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
             *         Vertical labels
             *
             * @type      {number}
             * @default   0
             * @apioption plotOptions.series.dataLabels.rotation
             */
            /**
             * The shadow of the box. Works best with `borderWidth` or
             * `backgroundColor`. Since 2.3 the shadow can be an object
             * configuration containing `color`, `offsetX`, `offsetY`, `opacity`
             * and `width`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @type      {boolean|Highcharts.ShadowOptionsObject}
             * @default   false
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.shadow
             */
            /**
             * The name of a symbol to use for the border around the label.
             * Symbols are predefined functions on the Renderer object.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/
             *         A callout for annotations
             *
             * @type      {string}
             * @default   square
             * @since     4.1.2
             * @apioption plotOptions.series.dataLabels.shape
             */
            /**
             * Styles for the label. The default `color` setting is
             * `"contrast"`, which is a pseudo color that Highcharts picks up
             * and applies the maximum contrast to the underlying point item,
             * for example the bar in a bar chart.
             *
             * The `textOutline` is a pseudo property that applies an outline of
             * the given width with the given color, which by default is the
             * maximum contrast to the text. So a bright text color will result
             * in a black text outline for maximum readability on a mixed
             * background. In some cases, especially with grayscale text, the
             * text outline doesn't work well, in which cases it can be disabled
             * by setting it to `"none"`. When `useHTML` is true, the
             * `textOutline` will not be picked up. In this, case, the same
             * effect can be acheived through the `text-shadow` CSS property.
             *
             * For some series types, where each point has an extent, like for
             * example tree maps, the data label may overflow the point. There
             * are two strategies for handling overflow. By default, the text
             * will wrap to multiple lines. The other strategy is to set
             * `style.textOverflow` to `ellipsis`, which will keep the text on
             * one line plus it will break inside long words.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
             *         Bold labels
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow/
             *         Long labels truncated with an ellipsis in a pie
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap/
             *         Long labels are wrapped in a pie
             * @sample {highmaps} maps/demo/color-axis/
             *         Bold labels
             *
             * @type      {Highcharts.CSSObject}
             * @since     4.1.0
             * @apioption plotOptions.series.dataLabels.style
             */
            style: {
                /** @internal */
                fontSize: '0.7em',
                /** @internal */
                fontWeight: 'bold',
                /** @internal */
                color: 'contrast',
                /** @internal */
                textOutline: '1px contrast'
            },
            /**
             * Options for a label text which should follow marker's shape.
             * Border and background are disabled for a label that follows a
             * path.
             *
             * **Note:** Only SVG-based renderer supports this option. Setting
             * `useHTML` to true will disable this option.
             *
             * @declare   Highcharts.DataLabelsTextPathOptionsObject
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.textPath
             */
            /**
             * Presentation attributes for the text path.
             *
             * @type      {Highcharts.SVGAttributes}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.textPath.attributes
             */
            /**
             * Enable or disable `textPath` option for link's or marker's data
             * labels.
             *
             * @type      {boolean}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.textPath.enabled
             */
            /**
             * Whether to
             * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the labels.
             *
             * @type      {boolean}
             * @default   false
             * @apioption plotOptions.series.dataLabels.useHTML
             */
            /**
             * The vertical alignment of a data label. Can be one of `top`,
             * `middle` or `bottom`. The default value depends on the data, for
             * instance in a column chart, the label is above positive values
             * and below negative values.
             *
             * @type  {Highcharts.VerticalAlignValue|null}
             * @since 2.3.3
             */
            verticalAlign: 'bottom',
            /**
             * The x position offset of the label relative to the point in
             * pixels.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
             *         Vertical and positioned
             * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
             *         Data labels inside the bar
             */
            x: 0,
            /**
             * The z index of the data labels. Use a `zIndex` of 6 to display it above
             * the series, or use a `zIndex` of 2 to display it behind the series.
             *
             * @type      {number}
             * @default   6
             * @since     2.3.5
             * @apioption plotOptions.series.dataLabels.zIndex
             */
            /**
             * The y position offset of the label relative to the point in
             * pixels.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
             *         Vertical and positioned
             */
            y: 0
        },
        /**
         * When the series contains less points than the crop threshold, all
         * points are drawn, even if the points fall outside the visible plot
         * area at the current zoom. The advantage of drawing all points
         * (including markers and columns), is that animation is performed on
         * updates. On the other hand, when the series contains more points than
         * the crop threshold, the series data is cropped to only contain points
         * that fall within the plot area. The advantage of cropping away
         * invisible points is to increase performance on large series.
         *
         * @since   2.2
         * @product highcharts highstock
         *
         * @private
         */
        cropThreshold: 300,
        /**
         * Opacity of a series parts: line, fill (e.g. area) and dataLabels.
         *
         * @see [states.inactive.opacity](#plotOptions.series.states.inactive.opacity)
         *
         * @since 7.1.0
         *
         * @private
         */
        opacity: 1,
        /**
         * The width of each point on the x axis. For example in a column chart
         * with one value each day, the pointRange would be 1 day (= 24 * 3600
         * * 1000 milliseconds). This is normally computed automatically, but
         * this option can be used to override the automatic value.
         *
         * @product highstock
         *
         * @private
         */
        pointRange: 0,
        /**
         * When this is true, the series will not cause the Y axis to cross
         * the zero plane (or [threshold](#plotOptions.series.threshold) option)
         * unless the data actually crosses the plane.
         *
         * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
         * 3 will make the Y axis show negative values according to the
         * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
         * at 0.
         *
         * @since   4.1.9
         * @product highcharts highstock
         *
         * @private
         */
        softThreshold: true,
        /**
         * @declare Highcharts.SeriesStatesOptionsObject
         *
         * @private
         */
        states: {
            /**
             * The normal state of a series, or for point items in column, pie
             * and similar series. Currently only used for setting animation
             * when returning to normal state from hover.
             *
             * @declare Highcharts.SeriesStatesNormalOptionsObject
             */
            normal: {
                /**
                 * Animation when returning to normal state after hovering.
                 *
                     * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 */
                animation: true
            },
            /**
             * Options for the hovered series. These settings override the
             * normal state options when a series is moused over or touched.
             *
             * @declare Highcharts.SeriesStatesHoverOptionsObject
             */
            hover: {
                /**
                 * Enable separate styles for the hovered series to visualize
                 * that the user hovers either the series itself or the legend.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/
                 *         Line
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/
                 *         Column
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/
                 *         Pie
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     1.2
                 * @apioption plotOptions.series.states.hover.enabled
                 */
                /**
                 * Animation setting for hovering the graph in line-type series.
                 *
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @since   5.0.8
                 * @product highcharts highstock
                 */
                animation: {
                    /**
                     * The duration of the hover animation in milliseconds. By
                     * default the hover state animates quickly in, and slowly
                     * back to normal.
                     *
                     * @internal
                     */
                    duration: 150
                },
                /**
                 * Pixel width of the graph line. By default this property is
                 * undefined, and the `lineWidthPlus` property dictates how much
                 * to increase the linewidth from normal state.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
                 *         5px line on hover
                 *
                 * @type      {number}
                 * @product   highcharts highstock
                 * @apioption plotOptions.series.states.hover.lineWidth
                 */
                /**
                 * The additional line width for the graph of a hovered series.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                 *         5 pixels wider
                 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                 *         5 pixels wider
                 *
                 * @since   4.0.3
                 * @product highcharts highstock
                 */
                lineWidthPlus: 1,
                /**
                 * In Highcharts 1.0, the appearance of all markers belonging
                 * to the hovered series. For settings on the hover state of the
                 * individual point, see
                 * [marker.states.hover](#plotOptions.series.marker.states.hover).
                 *
                 * @deprecated
                 *
                 * @extends   plotOptions.series.marker
                 * @excluding states, symbol
                 * @product   highcharts highstock
                 */
                marker: {
                // `lineWidth: base + 1`,
                // `radius: base + 1`
                },
                /**
                 * Options for the halo appearing around the hovered point in
                 * line-type series as well as outside the hovered slice in pie
                 * charts. By default the halo is filled by the current point or
                 * series color with an opacity of 0.25\. The halo can be
                 * disabled by setting the `halo` option to `null`.
                 *
                 * In styled mode, the halo is styled with the
                 * `.highcharts-halo` class, with colors inherited from
                 * `.highcharts-color-{n}`.
                 *
                 * @sample {highcharts} highcharts/plotoptions/halo/
                 *         Halo options
                 * @sample {highstock} highcharts/plotoptions/halo/
                 *         Halo options
                 *
                 * @declare Highcharts.SeriesStatesHoverHaloOptionsObject
                 * @type    {null|*}
                 * @since   4.0
                 * @product highcharts highstock
                 */
                halo: {
                    /**
                     * A collection of SVG attributes to override the appearance
                     * of the halo, for example `fill`, `stroke` and
                     * `stroke-width`.
                     *
                     * @type      {Highcharts.SVGAttributes}
                     * @since     4.0
                     * @product   highcharts highstock
                     * @apioption plotOptions.series.states.hover.halo.attributes
                     */
                    /**
                     * The pixel size of the halo. For point markers this is the
                     * radius of the halo. For pie slices it is the width of the
                     * halo outside the slice. For bubbles it defaults to 5 and
                     * is the width of the halo outside the bubble.
                     *
                     * @since   4.0
                     * @product highcharts highstock
                     */
                    size: 10,
                    /**
                     * Opacity for the halo unless a specific fill is overridden
                     * using the `attributes` setting. Note that Highcharts is
                     * only able to apply opacity to colors of hex or rgb(a)
                     * formats.
                     *
                     * @since   4.0
                     * @product highcharts highstock
                     */
                    opacity: 0.25
                }
            },
            /**
             * Specific options for point in selected states, after being
             * selected by
             * [allowPointSelect](#plotOptions.series.allowPointSelect)
             * or programmatically.
             *
             * @sample maps/plotoptions/series-allowpointselect/
             *         Allow point select demo
             *
             * @declare   Highcharts.SeriesStatesSelectOptionsObject
             * @extends   plotOptions.series.states.hover
             * @excluding brightness
             */
            select: {
                animation: {
                    /** @internal */
                    duration: 0
                }
            },
            /**
             * The opposite state of a hover for series.
             *
             * @sample highcharts/plotoptions/series-states-inactive-disabled
             *         Disabled inactive state
             *
             * @declare Highcharts.SeriesStatesInactiveOptionsObject
             */
            inactive: {
                /**
                 * Enable or disable the inactive state for a series
                 *
                 * @sample highcharts/plotoptions/series-states-inactive-disabled
                 *         Disabled inactive state
                 *
                 * @type {boolean}
                 * @default true
                 * @apioption plotOptions.series.states.inactive.enabled
                 */
                /**
                 * The animation for entering the inactive state.
                 *
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 */
                animation: {
                    /** @internal */
                    duration: 150
                },
                /**
                 * Opacity of series elements (dataLabels, line, area).
                 *
                 * @type {number}
                 */
                opacity: 0.2
            }
        },
        /**
         * Sticky tracking of mouse events. When true, the `mouseOut` event on a
         * series isn't triggered until the mouse moves over another series, or
         * out of the plot area. When false, the `mouseOut` event on a series is
         * triggered when the mouse leaves the area around the series' graph or
         * markers. This also implies the tooltip when not shared. When
         * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
         * will be hidden when moving the mouse between series. Defaults to true
         * for line and area type series, but to false for columns, pies etc.
         *
         * **Note:** The boost module will force this option because of
         * technical limitations.
         *
         * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
         *         True by default
         * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
         *         False
         *
         * @default {highcharts} true
         * @default {highstock} true
         * @default {highmaps} false
         * @since   2.0
         *
         * @private
         */
        stickyTracking: true,
        /**
         * A configuration object for the tooltip rendering of each single
         * series. Properties are inherited from [tooltip](#tooltip), but only
         * the following properties can be defined on a series level.
         *
         * @declare   Highcharts.SeriesTooltipOptionsObject
         * @since     2.3
         * @extends   tooltip
         * @excluding animation, backgroundColor, borderColor, borderRadius,
         *            borderWidth, className, crosshairs, enabled, formatter,
         *            headerShape, hideDelay, outside, padding, positioner,
         *            shadow, shape, shared, snap, split, stickOnContact,
         *            style, useHTML
         * @apioption plotOptions.series.tooltip
         */
        /**
         * When a series contains a `data` array that is longer than this, the
         * Series class looks for data configurations of plain numbers or arrays of
         * numbers. The first and last valid points are checked. If found, the rest
         * of the data is assumed to be the same. This saves expensive data checking
         * and indexing in long series, and makes data-heavy charts render faster.
         *
         * Set it to `0` disable.
         *
         * Note:
         * - In boost mode turbo threshold is forced. Only array of numbers or two
         *   dimensional arrays are allowed.
         * - In version 11.4.3 and earlier, if object configurations were passed
         *   beyond the turbo threshold, a warning was logged in the console and the
         *   data series didn't render.
         *
         * @since   2.2
         * @product highcharts highstock gantt
         *
         * @private
         */
        turboThreshold: 1000,
        /**
         * An array defining zones within a series. Zones can be applied to the
         * X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
         * option. The zone definitions have to be in ascending order regarding
         * to the value.
         *
         * In styled mode, the color zones are styled with the
         * `.highcharts-zone-{n}` class, or custom classed from the `className`
         * option
         * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).
         *
         * @see [zoneAxis](#plotOptions.series.zoneAxis)
         *
         * @sample {highcharts} highcharts/series/color-zones-simple/
         *         Color zones
         * @sample {highstock} highcharts/series/color-zones-simple/
         *         Color zones
         *
         * @declare   Highcharts.SeriesZonesOptionsObject
         * @type      {Array<*>}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones
         */
        /**
         * Styled mode only. A custom class name for the zone.
         *
         * @sample highcharts/css/color-zones/
         *         Zones styled by class name
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption plotOptions.series.zones.className
         */
        /**
         * Defines the color of the series.
         *
         * @see [series color](#plotOptions.series.color)
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones.color
         */
        /**
         * A name for the dash style to use for the graph.
         *
         * @see [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
         *
         * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/
         *         Dashed line indicates prognosis
         *
         * @type      {Highcharts.DashStyleValue}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones.dashStyle
         */
        /**
         * Defines the fill color for the series (in area type series)
         *
         * @see [fillColor](#plotOptions.area.fillColor)
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones.fillColor
         */
        /**
         * The value up to where the zone extends, if undefined the zones
         * stretches to the last value in the series.
         *
         * @type      {number}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones.value
         */
        /**
         * When using dual or multiple color axes, this number defines which
         * colorAxis the particular series is connected to. It refers to
         * either the
         * {@link #colorAxis.id|axis id}
         * or the index of the axis in the colorAxis array, with 0 being the
         * first. Set this option to false to prevent a series from connecting
         * to the default color axis.
         *
         * Since v7.2.0 the option can also be an axis id or an axis index
         * instead of a boolean flag.
         *
         * @sample highcharts/coloraxis/coloraxis-with-pie/
         *         Color axis with pie series
         * @sample highcharts/coloraxis/multiple-coloraxis/
         *         Multiple color axis
         *
         * @type      {number|string|boolean}
         * @default   0
         * @product   highcharts highstock highmaps
         * @apioption plotOptions.series.colorAxis
         */
        /**
         * Determines what data value should be used to calculate point color
         * if `colorAxis` is used. Requires to set `min` and `max` if some
         * custom point property is used or if approximation for data grouping
         * is set to `'sum'`.
         *
         * @sample highcharts/coloraxis/custom-color-key/
         *         Custom color key
         * @sample highcharts/coloraxis/color-key-with-stops/
         *         Custom colorKey with color axis stops
         * @sample highcharts/coloraxis/changed-default-color-key/
         *         Changed default color key
         *
         * @type      {string}
         * @default   y
         * @since     7.2.0
         * @product   highcharts highstock highmaps
         * @apioption plotOptions.series.colorKey
         */
        /**
         * What type of legend symbol to render for this series. Can be one of
         * `areaMarker`, `lineMarker` or `rectangle`.
         *
         * @validvalue ["areaMarker", "lineMarker", "rectangle"]
         *
         * @sample {highcharts} highcharts/series/legend-symbol/
         *         Change the legend symbol
         *
         * @type      {string}
         * @default   rectangle
         * @since     11.0.1
         * @apioption plotOptions.series.legendSymbol
         */
        /**
         * Determines whether the series should look for the nearest point
         * in both dimensions or just the x-dimension when hovering the series.
         * Defaults to `'xy'` for scatter series and `'x'` for most other
         * series. If the data has duplicate x-values, it is recommended to
         * set this to `'xy'` to allow hovering over all points.
         *
         * Applies only to series types using nearest neighbor search (not
         * direct hover) for tooltip.
         *
         * @sample {highcharts} highcharts/series/findnearestpointby/
         *         Different hover behaviors
         * @sample {highstock} highcharts/series/findnearestpointby/
         *         Different hover behaviors
         * @sample {highmaps} highcharts/series/findnearestpointby/
         *         Different hover behaviors
         *
         * @since      5.0.10
         * @validvalue ["x", "xy"]
         *
         * @private
         */
        findNearestPointBy: 'x'
    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defaultOptions: defaultOptions$3 } = DefaultOptions;
    const { extend: extend$7, extendClass, merge: merge$6 } = Utilities;
    /* *
     *
     *  Namespace
     *
     * */
    var SeriesRegistry;
    (function (SeriesRegistry) {
        /* *
         *
         *  Properties
         *
         * */
        /**
         * @internal
         * @todo Move `Globals.seriesTypes` code to her.
         */
        SeriesRegistry.seriesTypes = H.seriesTypes;
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Registers class pattern of a series.
         *
         * @private
         */
        function registerSeriesType(seriesType, SeriesClass) {
            const defaultPlotOptions = defaultOptions$3.plotOptions || {}, seriesOptions = SeriesClass.defaultOptions, seriesProto = SeriesClass.prototype;
            seriesProto.type = seriesType;
            if (!seriesProto.pointClass) {
                seriesProto.pointClass = Point;
            }
            if (SeriesRegistry.seriesTypes[seriesType]) {
                return false;
            }
            if (seriesOptions) {
                defaultPlotOptions[seriesType] = seriesOptions;
            }
            SeriesRegistry.seriesTypes[seriesType] = SeriesClass;
            return true;
        }
        SeriesRegistry.registerSeriesType = registerSeriesType;
        /**
         * Old factory to create new series prototypes.
         *
         * @deprecated
         * @function Highcharts.seriesType
         *
         * @param {string} type
         * The series type name.
         *
         * @param {string} parent
         * The parent series type name. Use `line` to inherit from the basic
         * {@link Series} object.
         *
         * @param {Highcharts.SeriesOptionsType|Highcharts.Dictionary<*>} options
         * The additional default options that are merged with the parent's options.
         *
         * @param {Highcharts.Dictionary<*>} [props]
         * The properties (functions and primitives) to set on the new prototype.
         *
         * @param {Highcharts.Dictionary<*>} [pointProps]
         * Members for a series-specific extension of the {@link Point} prototype if
         * needed.
         *
         * @return {Highcharts.Series}
         * The newly created prototype as extended from {@link Series} or its
         * derivatives.
         */
        function seriesType(type, parent, options, seriesProto, pointProto) {
            const defaultPlotOptions = defaultOptions$3.plotOptions || {};
            parent = parent || '';
            // Merge the options
            defaultPlotOptions[type] = merge$6(defaultPlotOptions[parent], options);
            // Create the class
            delete SeriesRegistry.seriesTypes[type];
            registerSeriesType(type, extendClass(SeriesRegistry.seriesTypes[parent] || function () { }, seriesProto));
            SeriesRegistry.seriesTypes[type].prototype.type = type;
            // Create the point class if needed
            if (pointProto) {
                class PointClass extends Point {
                }
                extend$7(PointClass.prototype, pointProto);
                SeriesRegistry.seriesTypes[type].prototype.pointClass = PointClass;
            }
            return SeriesRegistry.seriesTypes[type];
        }
        SeriesRegistry.seriesType = seriesType;
    })(SeriesRegistry || (SeriesRegistry = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var SeriesRegistry$1 = SeriesRegistry;

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animate: animate$1, animObject: animObject$3, stop } = animationExports;
    const { deg2rad: deg2rad$1, doc: doc$3, svg: svg$2, SVG_NS: SVG_NS$2, win: win$4 } = H;
    const { addEvent: addEvent$2, attr: attr$3, createElement: createElement$2, crisp: crisp$3, css: css$2, defined: defined$6, erase: erase$2, extend: extend$6, fireEvent: fireEvent$4, isArray: isArray$4, isFunction, isObject: isObject$2, isString: isString$4, merge: merge$5, objectEach: objectEach$4, pick: pick$7, pInt: pInt$2, pushUnique, replaceNested: replaceNested$1, syncTimeout: syncTimeout$2, uniqueKey: uniqueKey$2 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the
     * rendering layer of Highcharts. Combined with the
     * {@link Highcharts.SVGRenderer}
     * object, these prototypes allow freeform annotation in the charts or even in
     * HTML pages without instanciating a chart. The SVGElement can also wrap HTML
     * labels, when `text` or `label` elements are created with the `useHTML`
     * parameter.
     *
     * The SVGElement instances are created through factory functions on the
     * {@link Highcharts.SVGRenderer}
     * object, like
     * {@link Highcharts.SVGRenderer#rect|rect},
     * {@link Highcharts.SVGRenderer#path|path},
     * {@link Highcharts.SVGRenderer#text|text},
     * {@link Highcharts.SVGRenderer#label|label},
     * {@link Highcharts.SVGRenderer#g|g}
     * and more.
     *
     * See [How to use the SVG Renderer](
     * https://www.highcharts.com/docs/advanced-chart-features/renderer) for a
     * comprehensive tutorial on how to draw SVG elements on a chart.
     *
     * @class
     * @name Highcharts.SVGElement
     */
    class SVGElement {
        // @todo public zIndex?: number;
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Get the current value of an attribute or pseudo attribute,
         * used mainly for animation. Called internally from
         * the {@link Highcharts.SVGRenderer#attr} function.
         *
         * @private
         * @function Highcharts.SVGElement#_defaultGetter
         *
         * @param {string} key
         *        Property key.
         *
         * @return {number|string}
         *         Property value.
         */
        _defaultGetter(key) {
            let ret = pick$7(this[key + 'Value'], // Align getter
            this[key], this.element ? this.element.getAttribute(key) : null, 0);
            if (/^-?[\d\.]+$/.test(ret)) { // Is numerical
                ret = parseFloat(ret);
            }
            return ret;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#_defaultSetter
         *
         * @param {string} value
         *
         * @param {string} key
         *
         * @param {Highcharts.SVGDOMElement} element
         *
         */
        _defaultSetter(value, key, element) {
            element.setAttribute(key, value);
        }
        /**
         * Add the element to the DOM. All elements must be added this way.
         *
         * @sample highcharts/members/renderer-g
         *         Elements added to a group
         *
         * @function Highcharts.SVGElement#add
         *
         * @param {Highcharts.SVGElement} [parent]
         *        The parent item to add it to. If undefined, the element is added
         *        to the {@link Highcharts.SVGRenderer.box}.
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVGElement for chaining.
         */
        add(parent) {
            const renderer = this.renderer, element = this.element;
            let inserted;
            if (parent) {
                this.parentGroup = parent;
            }
            // Build formatted text
            if (typeof this.textStr !== 'undefined' &&
                this.element.nodeName === 'text' // Not for SVGLabel instances
            ) {
                renderer.buildText(this);
            }
            // Mark as added
            this.added = true;
            // If we're adding to renderer root, or other elements in the group
            // have a z index, we need to handle it
            if (!parent || parent.handleZ || this.zIndex) {
                inserted = this.zIndexSetter();
            }
            // If zIndex is not handled, append at the end
            if (!inserted) {
                (parent ?
                    parent.element :
                    renderer.box).appendChild(element);
            }
            // Fire an event for internal hooks
            if (this.onAdd) {
                this.onAdd();
            }
            return this;
        }
        /**
         * Add a class name to an element.
         *
         * @function Highcharts.SVGElement#addClass
         *
         * @param {string} className
         * The new class name to add.
         *
         * @param {boolean} [replace=false]
         * When true, the existing class name(s) will be overwritten with the new
         * one. When false, the new one is added.
         *
         * @return {Highcharts.SVGElement}
         * Return the SVG element for chainability.
         */
        addClass(className, replace) {
            const currentClassName = replace ? '' : (this.attr('class') || '');
            // Trim the string and remove duplicates
            className = (className || '')
                .split(/ /g)
                .reduce(function (newClassName, name) {
                if (currentClassName.indexOf(name) === -1) {
                    newClassName.push(name);
                }
                return newClassName;
            }, (currentClassName ?
                [currentClassName] :
                []))
                .join(' ');
            if (className !== currentClassName) {
                this.attr('class', className);
            }
            return this;
        }
        /**
         * This method is executed in the end of `attr()`, after setting all
         * attributes in the hash. In can be used to efficiently consolidate
         * multiple attributes in one SVG property -- e.g., translate, rotate and
         * scale are merged in one "transform" attribute in the SVG node.
         *
         * @private
         * @function Highcharts.SVGElement#afterSetters
         */
        afterSetters() {
            // Update transform. Do this outside the loop to prevent redundant
            // updating for batch setting of attributes.
            if (this.doTransform) {
                this.updateTransform();
                this.doTransform = false;
            }
        }
        /**
         * Align the element relative to the chart or another box.
         *
         * @function Highcharts.SVGElement#align
         *
         * @param {Highcharts.AlignObject} [alignOptions]
         *        The alignment options. The function can be called without this
         *        parameter in order to re-align an element after the box has been
         *        updated.
         *
         * @param {boolean} [alignByTranslate]
         *        Align element by translation.
         *
         * @param {string|Highcharts.BBoxObject} [alignTo]
         *        The box to align to, needs a width and height. When the box is a
         *        string, it refers to an object in the Renderer. For example, when
         *        box is `spacingBox`, it refers to `Renderer.spacingBox` which
         *        holds `width`, `height`, `x` and `y` properties.
         *
         * @param {boolean} [redraw]
         *        Decide if SVGElement should be redrawn with new alignment or
         *        just change its attributes.
         *
         * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
         */
        align(alignOptions, alignByTranslate, alignTo, redraw = true) {
            const attribs = {}, renderer = this.renderer, alignedObjects = renderer.alignedObjects, initialAlignment = Boolean(alignOptions);
            let x, y, alignFactor, vAlignFactor;
            // First call on instanciate
            if (alignOptions) {
                this.alignOptions = alignOptions;
                this.alignByTranslate = alignByTranslate;
                this.alignTo = alignTo;
                // When called on resize, no arguments are supplied
            }
            else {
                alignOptions = this.alignOptions || {};
                alignByTranslate = this.alignByTranslate;
                alignTo = this.alignTo;
            }
            const alignToKey = !alignTo || isString$4(alignTo) ?
                alignTo || 'renderer' :
                void 0;
            // When aligned to a key, automatically re-align on redraws
            if (alignToKey) {
                // Prevent duplicates, like legendGroup after resize
                if (initialAlignment) {
                    pushUnique(alignedObjects, this);
                }
                alignTo = void 0; // Do not use the box
            }
            const alignToBox = pick$7(alignTo, renderer[alignToKey], renderer);
            // Assign variables
            const align = alignOptions.align, vAlign = alignOptions.verticalAlign;
            // Default: left align
            x = (alignToBox.x || 0) + (alignOptions.x || 0);
            // Default: top align
            y = (alignToBox.y || 0) + (alignOptions.y || 0);
            // Align
            if (align === 'right') {
                alignFactor = 1;
            }
            else if (align === 'center') {
                alignFactor = 2;
            }
            if (alignFactor) {
                x += ((alignToBox.width || 0) - (alignOptions.width || 0)) /
                    alignFactor;
            }
            attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);
            // Vertical align
            if (vAlign === 'bottom') {
                vAlignFactor = 1;
            }
            else if (vAlign === 'middle') {
                vAlignFactor = 2;
            }
            if (vAlignFactor) {
                y += ((alignToBox.height || 0) - (alignOptions.height || 0)) /
                    vAlignFactor;
            }
            attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);
            // Animate only if already placed
            if (redraw) {
                this[this.placed ? 'animate' : 'attr'](attribs);
                this.placed = true;
            }
            this.alignAttr = attribs;
            return this;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#alignSetter
         * @param {"left"|"center"|"right"} value
         */
        alignSetter(value) {
            const convert = {
                left: 'start',
                center: 'middle',
                right: 'end'
            };
            if (convert[value]) {
                this.alignValue = value;
                this.element.setAttribute('text-anchor', convert[value]);
            }
        }
        /**
         * Animate to given attributes or CSS properties.
         *
         * @sample highcharts/members/element-on/
         *         Setting some attributes by animation
         *
         * @function Highcharts.SVGElement#animate
         *
         * @param {Highcharts.SVGAttributes} params
         *        SVG attributes or CSS to animate.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [options]
         *        Animation options.
         *
         * @param {Function} [complete]
         *        Function to perform at the end of animation.
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVGElement for chaining.
         */
        animate(params, options, complete) {
            const animOptions = animObject$3(pick$7(options, this.renderer.globalAnimation, true)), deferTime = animOptions.defer;
            // When the page is hidden save resources in the background by not
            // running animation at all (#9749).
            if (doc$3.hidden) {
                animOptions.duration = 0;
            }
            if (animOptions.duration !== 0) {
                // Allows using a callback with the global animation without
                // overwriting it
                if (complete) {
                    animOptions.complete = complete;
                }
                // If defer option is defined delay the animation #12901
                syncTimeout$2(() => {
                    if (this.element) {
                        animate$1(this, params, animOptions);
                    }
                }, deferTime);
            }
            else {
                this.attr(params, void 0, complete || animOptions.complete);
                // Call the end step synchronously
                objectEach$4(params, function (val, prop) {
                    if (animOptions.step) {
                        animOptions.step.call(this, val, { prop: prop, pos: 1, elem: this });
                    }
                }, this);
            }
            return this;
        }
        /**
         * Apply a text outline through a custom CSS property, by copying the text
         * element and apply stroke to the copy. Used internally. Contrast checks at
         * [example](https://jsfiddle.net/highcharts/43soe9m1/2/).
         *
         * @example
         * // Specific color
         * text.css({
         *    textOutline: '1px black'
         * });
         * // Automatic contrast
         * text.css({
         *    color: '#000000', // black text
         *    textOutline: '1px contrast' // => white outline
         * });
         *
         * @private
         * @function Highcharts.SVGElement#applyTextOutline
         *
         * @param {string} textOutline
         *        A custom CSS `text-outline` setting, defined by `width color`.
         */
        applyTextOutline(textOutline) {
            const elem = this.element, hasContrast = textOutline.indexOf('contrast') !== -1;
            // When the text shadow is set to contrast, use dark stroke for light
            // text and vice versa.
            if (hasContrast) {
                textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
            }
            // Extract the stroke width and color
            const parts = textOutline.split(' ');
            const color = parts[parts.length - 1];
            let strokeWidth = parts[0];
            if (strokeWidth && strokeWidth !== 'none' && H.svg) {
                this.fakeTS = true; // Fake text shadow
                // Since the stroke is applied on center of the actual outline, we
                // need to double it to get the correct stroke-width outside the
                // glyphs.
                strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function (match, digit, unit) {
                    return (2 * Number(digit)) + unit;
                });
                // Remove shadows from previous runs.
                this.removeTextOutline();
                const outline = doc$3.createElementNS(SVG_NS$2, 'tspan');
                attr$3(outline, {
                    'class': 'highcharts-text-outline',
                    fill: color,
                    stroke: color,
                    'stroke-width': strokeWidth,
                    'stroke-linejoin': 'round'
                });
                // For each of the tspans and text nodes, create a copy in the
                // outline.
                const parentElem = elem.querySelector('textPath') || elem;
                [].forEach.call(parentElem.childNodes, (childNode) => {
                    const clone = childNode.cloneNode(true);
                    if (clone.removeAttribute) {
                        ['fill', 'stroke', 'stroke-width', 'stroke'].forEach((prop) => clone
                            .removeAttribute(prop));
                    }
                    outline.appendChild(clone);
                });
                // Collect the sum of dy from all children, included nested ones
                let totalHeight = 0;
                [].forEach.call(parentElem.querySelectorAll('text tspan'), (element) => {
                    totalHeight += Number(element.getAttribute('dy'));
                });
                // Insert an absolutely positioned break before the original text
                // to keep it in place
                const br = doc$3.createElementNS(SVG_NS$2, 'tspan');
                br.textContent = '\u200B';
                // Reset the position for the following text
                attr$3(br, {
                    x: Number(elem.getAttribute('x')),
                    dy: -totalHeight
                });
                // Insert the outline
                outline.appendChild(br);
                parentElem.insertBefore(outline, parentElem.firstChild);
            }
        }
        /**
         * @function Highcharts.SVGElement#attr
         * @param {string} key
         * @return {number|string}
         */ /**
        * Apply native and custom attributes to the SVG elements.
        *
        * In order to set the rotation center for rotation, set x and y to 0 and
        * use `translateX` and `translateY` attributes to position the element
        * instead.
        *
        * Attributes frequently used in Highcharts are `fill`, `stroke`,
        * `stroke-width`.
        *
        * @sample highcharts/members/renderer-rect/
        *         Setting some attributes
        *
        * @example
        * // Set multiple attributes
        * element.attr({
        *     stroke: 'red',
        *     fill: 'blue',
        *     x: 10,
        *     y: 10
        * });
        *
        * // Set a single attribute
        * element.attr('stroke', 'red');
        *
        * // Get an attribute
        * element.attr('stroke'); // => 'red'
        *
        * @function Highcharts.SVGElement#attr
        *
        * @param {string|Highcharts.SVGAttributes} [hash]
        *        The native and custom SVG attributes.
        *
        * @param {number|string|Highcharts.SVGPathArray} [val]
        *        If the type of the first argument is `string`, the second can be a
        *        value, which will serve as a single attribute setter. If the first
        *        argument is a string and the second is undefined, the function
        *        serves as a getter and the current value of the property is
        *        returned.
        *
        * @param {Function} [complete]
        *        A callback function to execute after setting the attributes. This
        *        makes the function compliant and interchangeable with the
        *        {@link SVGElement#animate} function.
        *
        * @param {boolean} [continueAnimation=true]
        *        Used internally when `.attr` is called as part of an animation
        *        step. Otherwise, calling `.attr` for an attribute will stop
        *        animation for that attribute.
        *
        * @return {Highcharts.SVGElement}
        *         If used as a setter, it returns the current
        *         {@link Highcharts.SVGElement} so the calls can be chained. If
        *         used as a getter, the current value of the attribute is returned.
        */
        attr(hash, val, complete, continueAnimation) {
            const { element } = this, symbolCustomAttribs = SVGElement.symbolCustomAttribs;
            let key, hasSetSymbolSize, ret = this, skipAttr, setter;
            // Single key-value pair
            if (typeof hash === 'string' && typeof val !== 'undefined') {
                key = hash;
                hash = {};
                hash[key] = val;
            }
            // Used as a getter: first argument is a string, second is undefined
            if (typeof hash === 'string') {
                ret = (this[hash + 'Getter'] ||
                    this._defaultGetter).call(this, hash, element);
                // Setter
            }
            else {
                objectEach$4(hash, function eachAttribute(val, key) {
                    skipAttr = false;
                    // Unless .attr is from the animator update, stop current
                    // running animation of this property
                    if (!continueAnimation) {
                        stop(this, key);
                    }
                    // Special handling of symbol attributes
                    if (this.symbolName &&
                        symbolCustomAttribs.indexOf(key) !== -1) {
                        if (!hasSetSymbolSize) {
                            this.symbolAttr(hash);
                            hasSetSymbolSize = true;
                        }
                        skipAttr = true;
                    }
                    if (this.rotation && (key === 'x' || key === 'y')) {
                        this.doTransform = true;
                    }
                    if (!skipAttr) {
                        setter = (this[key + 'Setter'] ||
                            this._defaultSetter);
                        setter.call(this, val, key, element);
                    }
                }, this);
                this.afterSetters();
            }
            // In accordance with animate, run a complete callback
            if (complete) {
                complete.call(this);
            }
            return ret;
        }
        /**
         * Apply a clipping shape to this element.
         *
         * @function Highcharts.SVGElement#clip
         *
         * @param {SVGElement} [clipElem]
         *        The clipping shape. If skipped, the current clip is removed.
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVG element to allow chaining.
         */
        clip(clipElem) {
            if (clipElem && !clipElem.clipPath) {
                // Add a hyphen at the end to avoid confusion in testing indexes
                // -1 and -10, -11 etc (#6550)
                const id = uniqueKey$2() + '-', clipPath = this.renderer.createElement('clipPath')
                    .attr({ id })
                    .add(this.renderer.defs);
                extend$6(clipElem, { clipPath, id, count: 0 });
                clipElem.add(clipPath);
            }
            return this.attr('clip-path', clipElem ?
                `url(${this.renderer.url}#${clipElem.id})` :
                'none');
        }
        /**
         * Calculate the coordinates needed for drawing a rectangle crisply and
         * return the calculated attributes.
         *
         * @function Highcharts.SVGElement#crisp
         *
         * @param {Highcharts.RectangleObject} rect
         * Rectangle to crisp.
         *
         * @param {number} [strokeWidth]
         * The stroke width to consider when computing crisp positioning. It can
         * also be set directly on the rect parameter.
         *
         * @return {Highcharts.RectangleObject}
         * The modified rectangle arguments.
         */
        crisp(rect, strokeWidth) {
            // Math.round because strokeWidth can sometimes have roundoff errors
            strokeWidth = Math.round(strokeWidth || rect.strokeWidth || 0);
            const x1 = rect.x || this.x || 0, y1 = rect.y || this.y || 0, x2 = (rect.width || this.width || 0) + x1, y2 = (rect.height || this.height || 0) + y1, 
            // Find all the rounded coordinates for corners
            x = crisp$3(x1, strokeWidth), y = crisp$3(y1, strokeWidth), x2Crisp = crisp$3(x2, strokeWidth), y2Crisp = crisp$3(y2, strokeWidth);
            extend$6(rect, {
                x,
                y,
                width: x2Crisp - x,
                height: y2Crisp - y
            });
            if (defined$6(rect.strokeWidth)) {
                rect.strokeWidth = strokeWidth;
            }
            return rect;
        }
        /**
         * Build and apply an SVG gradient out of a common JavaScript configuration
         * object. This function is called from the attribute setters. An event
         * hook is added for supporting other complex color types.
         *
         * @private
         * @function Highcharts.SVGElement#complexColor
         *
         * @param {Highcharts.GradientColorObject|Highcharts.PatternObject} colorOptions
         * The gradient or pattern options structure.
         *
         * @param {string} prop
         * The property to apply, can either be `fill` or `stroke`.
         *
         * @param {Highcharts.SVGDOMElement} elem
         * SVG element to apply the gradient on.
         */
        complexColor(colorOptions, prop, elem) {
            const renderer = this.renderer;
            let colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;
            fireEvent$4(this.renderer, 'complexColor', {
                args: arguments
            }, function () {
                // Apply linear or radial gradients
                if (colorOptions.radialGradient) {
                    gradName = 'radialGradient';
                }
                else if (colorOptions.linearGradient) {
                    gradName = 'linearGradient';
                }
                if (gradName) {
                    gradAttr = colorOptions[gradName];
                    gradients = renderer.gradients;
                    stops = colorOptions.stops;
                    radialReference = elem.radialReference;
                    // Keep < 2.2 compatibility
                    if (isArray$4(gradAttr)) {
                        colorOptions[gradName] = gradAttr = {
                            x1: gradAttr[0],
                            y1: gradAttr[1],
                            x2: gradAttr[2],
                            y2: gradAttr[3],
                            gradientUnits: 'userSpaceOnUse'
                        };
                    }
                    // Correct the radial gradient for the radial reference system
                    if (gradName === 'radialGradient' &&
                        radialReference &&
                        !defined$6(gradAttr.gradientUnits)) {
                        // Save the radial attributes for updating
                        radAttr = gradAttr;
                        gradAttr = merge$5(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: 'userSpaceOnUse' });
                    }
                    // Build the unique key to detect whether we need to create a
                    // new element (#1282)
                    objectEach$4(gradAttr, function (value, n) {
                        if (n !== 'id') {
                            key.push(n, value);
                        }
                    });
                    objectEach$4(stops, function (val) {
                        key.push(val);
                    });
                    key = key.join(',');
                    // Check if a gradient object with the same config object is
                    // created within this renderer
                    if (gradients[key]) {
                        id = gradients[key].attr('id');
                    }
                    else {
                        // Set the id and create the element
                        gradAttr.id = id = uniqueKey$2();
                        const gradientObject = gradients[key] =
                            renderer.createElement(gradName)
                                .attr(gradAttr)
                                .add(renderer.defs);
                        gradientObject.radAttr = radAttr;
                        // The gradient needs to keep a list of stops to be able to
                        // destroy them
                        gradientObject.stops = [];
                        stops.forEach(function (stop) {
                            if (stop[1].indexOf('rgba') === 0) {
                                colorObject = Color.parse(stop[1]);
                                stopColor = colorObject.get('rgb');
                                stopOpacity = colorObject.get('a');
                            }
                            else {
                                stopColor = stop[1];
                                stopOpacity = 1;
                            }
                            const stopObject = renderer.createElement('stop').attr({
                                offset: stop[0],
                                'stop-color': stopColor,
                                'stop-opacity': stopOpacity
                            }).add(gradientObject);
                            // Add the stop element to the gradient
                            gradientObject.stops.push(stopObject);
                        });
                    }
                    // Set the reference to the gradient object
                    value = 'url(' + renderer.url + '#' + id + ')';
                    elem.setAttribute(prop, value);
                    elem.gradient = key;
                    // Allow the color to be concatenated into tooltips formatters
                    // etc. (#2995)
                    colorOptions.toString = function () {
                        return value;
                    };
                }
            });
        }
        /**
         * Set styles for the element. In addition to CSS styles supported by
         * native SVG and HTML elements, there are also some custom made for
         * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text
         * elements.
         *
         * @sample highcharts/members/renderer-text-on-chart/
         *         Styled text
         *
         * @function Highcharts.SVGElement#css
         *
         * @param {Highcharts.CSSObject} styles
         *        The new CSS styles.
         *
         * @return {Highcharts.SVGElement}
         *         Return the SVG element for chaining.
         */
        css(styles) {
            const oldStyles = this.styles, newStyles = {}, elem = this.element;
            let textWidth, hasNew = !oldStyles;
            // Filter out existing styles to increase performance (#2640)
            if (oldStyles) {
                objectEach$4(styles, function (value, n) {
                    if (oldStyles && oldStyles[n] !== value) {
                        newStyles[n] = value;
                        hasNew = true;
                    }
                });
            }
            if (hasNew) {
                // Merge the new styles with the old ones
                if (oldStyles) {
                    styles = extend$6(oldStyles, newStyles);
                }
                // Get the text width from style
                // Previously set, unset it (#8234)
                if (styles.width === null || styles.width === 'auto') {
                    delete this.textWidth;
                    // Apply new
                }
                else if (elem.nodeName.toLowerCase() === 'text' &&
                    styles.width) {
                    textWidth = this.textWidth = pInt$2(styles.width);
                }
                // Store object
                extend$6(this.styles, styles);
                if (textWidth && (!svg$2 && this.renderer.forExport)) {
                    delete styles.width;
                }
                const stylesToApply = merge$5(styles);
                if (elem.namespaceURI === this.SVG_NS) {
                    // These CSS properties are interpreted internally by the SVG
                    // renderer, but are not supported by SVG and should not be
                    // added to the DOM. In styled mode, no CSS should find its way
                    // to the DOM whatsoever (#6173, #6474).
                    ['textOutline', 'textOverflow', 'width'].forEach((key) => (stylesToApply &&
                        delete stylesToApply[key]));
                    // SVG requires fill for text
                    if (stylesToApply.color) {
                        stylesToApply.fill = stylesToApply.color;
                    }
                }
                css$2(elem, stylesToApply);
            }
            if (this.added) {
                // Rebuild text after added. Cache mechanisms in the buildText will
                // prevent building if there are no significant changes.
                if (this.element.nodeName === 'text') {
                    this.renderer.buildText(this);
                }
                // Apply text outline after added
                if (styles.textOutline) {
                    this.applyTextOutline(styles.textOutline);
                }
            }
            return this;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#dashstyleSetter
         * @param {string} value
         */
        dashstyleSetter(value) {
            let i, strokeWidth = this['stroke-width'];
            // If "inherit", like maps in IE, assume 1 (#4981). With HC5 and the new
            // strokeWidth function, we should be able to use that instead.
            if (strokeWidth === 'inherit') {
                strokeWidth = 1;
            }
            value = value && value.toLowerCase();
            if (value) {
                const v = value
                    .replace('shortdashdotdot', '3,1,1,1,1,1,')
                    .replace('shortdashdot', '3,1,1,1')
                    .replace('shortdot', '1,1,')
                    .replace('shortdash', '3,1,')
                    .replace('longdash', '8,3,')
                    .replace(/dot/g, '1,3,')
                    .replace('dash', '4,3,')
                    .replace(/,$/, '')
                    .split(','); // Ending comma
                i = v.length;
                while (i--) {
                    v[i] = '' + (pInt$2(v[i]) * pick$7(strokeWidth, NaN));
                }
                value = v.join(',').replace(/NaN/g, 'none'); // #3226
                this.element.setAttribute('stroke-dasharray', value);
            }
        }
        /**
         * Destroy the element and element wrapper and clear up the DOM and event
         * hooks.
         *
         * @function Highcharts.SVGElement#destroy
         */
        destroy() {
            const wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;
            let parentToClean = (element.nodeName === 'SPAN' &&
                wrapper.parentGroup ||
                void 0), grandParent, i;
            // Remove events
            element.onclick = element.onmouseout = element.onmouseover =
                element.onmousemove = element.point = null;
            stop(wrapper); // Stop running animations
            if (wrapper.clipPath && ownerSVGElement) {
                const clipPath = wrapper.clipPath;
                // Look for existing references to this clipPath and remove them
                // before destroying the element (#6196).
                // The upper case version is for Edge
                [].forEach.call(ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'), function (el) {
                    if (el.getAttribute('clip-path').indexOf(clipPath.element.id) > -1) {
                        el.removeAttribute('clip-path');
                    }
                });
                wrapper.clipPath = clipPath.destroy();
            }
            wrapper.connector = wrapper.connector?.destroy();
            // Destroy stops in case this is a gradient object @todo old code?
            if (wrapper.stops) {
                for (i = 0; i < wrapper.stops.length; i++) {
                    wrapper.stops[i].destroy();
                }
                wrapper.stops.length = 0;
                wrapper.stops = void 0;
            }
            // Remove element
            wrapper.safeRemoveChild(element);
            // In case of useHTML, clean up empty containers emulating SVG groups
            // (#1960, #2393, #2697).
            while (parentToClean &&
                parentToClean.div &&
                parentToClean.div.childNodes.length === 0) {
                grandParent = parentToClean.parentGroup;
                wrapper.safeRemoveChild(parentToClean.div);
                delete parentToClean.div;
                parentToClean = grandParent;
            }
            // Remove from alignObjects
            if (wrapper.alignOptions) {
                erase$2(renderer.alignedObjects, wrapper);
            }
            objectEach$4(wrapper, function (val, key) {
                // Destroy child elements of a group
                if (wrapper[key] &&
                    wrapper[key].parentGroup === wrapper &&
                    wrapper[key].destroy) {
                    wrapper[key].destroy();
                }
                // Delete all properties
                delete wrapper[key];
            });
            return;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#dSettter
         * @param {number|string|Highcharts.SVGPathArray} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        dSetter(value, key, element) {
            if (isArray$4(value)) {
                // Backwards compatibility, convert one-dimensional array into an
                // array of segments
                if (typeof value[0] === 'string') {
                    value = this.renderer.pathToSegments(value);
                }
                this.pathArray = value;
                value = value.reduce((acc, seg, i) => {
                    if (!seg || !seg.join) {
                        return (seg || '').toString();
                    }
                    return (i ? acc + ' ' : '') + seg.join(' ');
                }, '');
            }
            if (/(NaN| {2}|^$)/.test(value)) {
                value = 'M 0 0';
            }
            // Check for cache before resetting. Resetting causes disturbance in the
            // DOM, causing flickering in some cases in Edge/IE (#6747). Also
            // possible performance gain.
            if (this[key] !== value) {
                element.setAttribute(key, value);
                this[key] = value;
            }
        }
        /**
         * @private
         * @function Highcharts.SVGElement#fillSetter
         * @param {Highcharts.ColorType} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        fillSetter(value, key, element) {
            if (typeof value === 'string') {
                element.setAttribute(key, value);
            }
            else if (value) {
                this.complexColor(value, key, element);
            }
        }
        /**
         * @private
         * @function Highcharts.SVGElement#hrefSetter
         * @param {Highcharts.ColorType} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        hrefSetter(value, key, element) {
            // Namespace is needed for offline export, #19106
            element.setAttributeNS('http://www.w3.org/1999/xlink', key, value);
        }
        /**
         * Get the bounding box (width, height, x and y) for the element. Generally
         * used to get rendered text size. Since this is called a lot in charts,
         * the results are cached based on text properties, in order to save DOM
         * traffic. The returned bounding box includes the rotation, so for example
         * a single text line of rotation 90 will report a greater height, and a
         * width corresponding to the line-height.
         *
         * @sample highcharts/members/renderer-on-chart/
         *         Draw a rectangle based on a text's bounding box
         *
         * @function Highcharts.SVGElement#getBBox
         *
         * @param {boolean} [reload]
         *        Skip the cache and get the updated DOM bounding box.
         *
         * @param {number} [rot]
         *        Override the element's rotation. This is internally used on axis
         *        labels with a value of 0 to find out what the bounding box would
         *        be have been if it were not rotated.
         *
         * @return {Highcharts.BBoxObject}
         *         The bounding box with `x`, `y`, `width` and `height` properties.
         */
        getBBox(reload, rot) {
            const wrapper = this, { alignValue, element, renderer, styles, textStr } = wrapper, { cache, cacheKeys } = renderer, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick$7(rot, wrapper.rotation, 0), fontSize = renderer.styledMode ? (element &&
                SVGElement.prototype.getStyle.call(element, 'font-size')) : (styles.fontSize);
            let bBox, height, toggleTextShadowShim, cacheKey;
            // Avoid undefined and null (#7316)
            if (defined$6(textStr)) {
                cacheKey = textStr.toString();
                // Since numbers are monospaced, and numerical labels appear a lot
                // in a chart, we assume that a label of n characters has the same
                // bounding box as others of the same length. Unless there is inner
                // HTML in the label. In that case, leave the numbers as is (#5899).
                if (cacheKey.indexOf('<') === -1) {
                    cacheKey = cacheKey.replace(/\d/g, '0');
                }
                // Properties that affect bounding box
                cacheKey += [
                    '',
                    renderer.rootFontSize,
                    fontSize,
                    rotation,
                    wrapper.textWidth, // #7874, also useHTML
                    alignValue,
                    styles.textOverflow, // #5968
                    styles.fontWeight // #12163
                ].join(',');
            }
            if (cacheKey && !reload) {
                bBox = cache[cacheKey];
            }
            // No cache found
            if (!bBox || bBox.polygon) {
                // SVG elements
                if (isSVG || renderer.forExport) {
                    try { // Fails in Firefox if the container has display: none.
                        // When the text shadow shim is used, we need to hide the
                        // fake shadows to get the correct bounding box (#3872)
                        toggleTextShadowShim = this.fakeTS && function (display) {
                            const outline = element.querySelector('.highcharts-text-outline');
                            if (outline) {
                                css$2(outline, { display });
                            }
                        };
                        // Workaround for #3842, Firefox reporting wrong bounding
                        // box for shadows
                        if (isFunction(toggleTextShadowShim)) {
                            toggleTextShadowShim('none');
                        }
                        bBox = element.getBBox ?
                            // SVG: use extend because IE9 is not allowed to change
                            // width and height in case of rotation (below)
                            extend$6({}, element.getBBox()) : {
                            // HTML elements with `exporting.allowHTML` and
                            // legacy IE in export mode
                            width: element.offsetWidth,
                            height: element.offsetHeight,
                            x: 0,
                            y: 0
                        };
                        // #3842
                        if (isFunction(toggleTextShadowShim)) {
                            toggleTextShadowShim('');
                        }
                    }
                    catch (e) {
                    }
                    // If the bBox is not set, the try-catch block above failed. The
                    // other condition is for Opera that returns a width of
                    // -Infinity on hidden elements.
                    if (!bBox || bBox.width < 0) {
                        bBox = { x: 0, y: 0, width: 0, height: 0 };
                    }
                    // Use HTML within SVG
                }
                else {
                    bBox = wrapper.htmlGetBBox();
                }
                // True SVG elements as well as HTML elements in modern browsers
                // using the .useHTML option need to compensated for rotation
                height = bBox.height;
                // Workaround for wrong bounding box in IE, Edge and Chrome on
                // Windows. With Highcharts' default font, IE and Edge report
                // a box height of 16.899 and Chrome rounds it to 17. If this
                // stands uncorrected, it results in more padding added below
                // the text than above when adding a label border or background.
                // Also vertical positioning is affected.
                // https://jsfiddle.net/highcharts/em37nvuj/
                // (#1101, #1505, #1669, #2568, #6213).
                if (isSVG) {
                    bBox.height = height = ({
                        '11px,17': 14,
                        '13px,20': 16
                    }[`${fontSize || ''},${Math.round(height)}`] ||
                        height);
                }
                // Adjust for rotated text
                if (rotation) {
                    bBox = this.getRotatedBox(bBox, rotation);
                }
                // Create a reference to catch changes to bBox
                const e = { bBox };
                fireEvent$4(this, 'afterGetBBox', e);
                // Pick up any changes after the fired event
                bBox = e.bBox;
            }
            // Cache it. When loading a chart in a hidden iframe in Firefox and
            // IE/Edge, the bounding box height is 0, so don't cache it (#5620).
            if (cacheKey && (textStr === '' || bBox.height > 0)) {
                // Rotate (#4681)
                while (cacheKeys.length > 250) {
                    delete cache[cacheKeys.shift()];
                }
                if (!cache[cacheKey]) {
                    cacheKeys.push(cacheKey);
                }
                cache[cacheKey] = bBox;
            }
            return bBox;
        }
        /**
         * Get the rotated box.
         * @private
         */
        getRotatedBox(box, rotation) {
            const { x: boxX, y: boxY, width, height } = box, { alignValue, translateY, rotationOriginX = 0, rotationOriginY = 0 } = this, alignFactor = {
                'right': 1,
                'center': 0.5
            }[alignValue || 0] || 0, baseline = Number(this.element.getAttribute('y') || 0) -
                (translateY ? 0 : boxY), rad = rotation * deg2rad$1, rad90 = (rotation - 90) * deg2rad$1, cosRad = Math.cos(rad), sinRad = Math.sin(rad), wCosRad = width * cosRad, wSinRad = width * sinRad, cosRad90 = Math.cos(rad90), sinRad90 = Math.sin(rad90), [[xOriginCosRad, xOriginSinRad], [yOriginCosRad, yOriginSinRad]] = [
                rotationOriginX,
                rotationOriginY
            ].map((rotOrigin) => [
                rotOrigin - (rotOrigin * cosRad),
                rotOrigin * sinRad
            ]), 
            // Find the starting point on the left side baseline of
            // the text
            pX = ((boxX + alignFactor * (width - wCosRad)) +
                xOriginCosRad + yOriginSinRad), pY = ((boxY + baseline - alignFactor * wSinRad) -
                xOriginSinRad + yOriginCosRad), 
            // Find all corners
            aX = pX + baseline * cosRad90, bX = aX + wCosRad, cX = bX - height * cosRad90, dX = cX - wCosRad, aY = pY + baseline * sinRad90, bY = aY + wSinRad, cY = bY - height * sinRad90, dY = cY - wSinRad;
            // Deduct the bounding box from the corners
            const x = Math.min(aX, bX, cX, dX), y = Math.min(aY, bY, cY, dY), boxWidth = Math.max(aX, bX, cX, dX) - x, boxHeight = Math.max(aY, bY, cY, dY) - y;
            /* Uncomment to debug boxes
            this.renderer.path([
                ['M', aX, aY],
                ['L', bX, bY],
                ['L', cX, cY],
                ['L', dX, dY],
                ['Z']
            ])
                .attr({
                    stroke: 'red',
                    'stroke-width': 1
                })
                .add();
            // */
            return {
                x,
                y,
                width: boxWidth,
                height: boxHeight,
                polygon: [
                    [aX, aY],
                    [bX, bY],
                    [cX, cY],
                    [dX, dY]
                ]
            };
        }
        /**
         * Get the computed style. Only in styled mode.
         *
         * @example
         * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'
         *
         * @function Highcharts.SVGElement#getStyle
         *
         * @param {string} prop
         *        The property name to check for.
         *
         * @return {string}
         *         The current computed value.
         */
        getStyle(prop) {
            return win$4
                .getComputedStyle(this.element || this, '')
                .getPropertyValue(prop);
        }
        /**
         * Check if an element has the given class name.
         *
         * @function Highcharts.SVGElement#hasClass
         *
         * @param {string} className
         * The class name to check for.
         *
         * @return {boolean}
         * Whether the class name is found.
         */
        hasClass(className) {
            return ('' + this.attr('class'))
                .split(' ')
                .indexOf(className) !== -1;
        }
        /**
         * Hide the element, similar to setting the `visibility` attribute to
         * `hidden`.
         *
         * @function Highcharts.SVGElement#hide
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVGElement for chaining.
         */
        hide() {
            return this.attr({ visibility: 'hidden' });
        }
        /**
         * @private
         */
        htmlGetBBox() {
            return { height: 0, width: 0, x: 0, y: 0 };
        }
        /**
         * Initialize the SVG element. This function only exists to make the
         * initialization process overridable. It should not be called directly.
         *
         * @function Highcharts.SVGElement#init
         *
         * @param {Highcharts.SVGRenderer} renderer
         * The SVGRenderer instance to initialize to.
         *
         * @param {string} nodeName
         * The SVG node name.
         */
        constructor(renderer, nodeName) {
            this.onEvents = {};
            this.opacity = 1; // Default base for animation
            this.SVG_NS = SVG_NS$2;
            /**
             * The primary DOM node. Each `SVGElement` instance wraps a main DOM
             * node, but may also represent more nodes.
             *
             * @name Highcharts.SVGElement#element
             * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}
             */
            this.element = nodeName === 'span' || nodeName === 'body' ?
                createElement$2(nodeName) :
                doc$3.createElementNS(this.SVG_NS, nodeName);
            /**
             * The renderer that the SVGElement belongs to.
             *
             * @name Highcharts.SVGElement#renderer
             * @type {Highcharts.SVGRenderer}
             */
            this.renderer = renderer;
            this.styles = {};
            fireEvent$4(this, 'afterInit');
        }
        /**
         * Add an event listener. This is a simple setter that replaces the
         * previous event of the same type added by this function, as opposed to
         * the {@link Highcharts#addEvent} function.
         *
         * @sample highcharts/members/element-on/
         *         A clickable rectangle
         *
         * @function Highcharts.SVGElement#on
         *
         * @param {string} eventType
         * The event type.
         *
         * @param {Function} handler
         * The handler callback.
         *
         * @return {Highcharts.SVGElement}
         * The SVGElement for chaining.
         */
        on(eventType, handler) {
            const { onEvents } = this;
            if (onEvents[eventType]) {
                // Unbind existing event
                onEvents[eventType]();
            }
            onEvents[eventType] = addEvent$2(this.element, eventType, handler);
            return this;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#opacitySetter
         * @param {string} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        opacitySetter(value, key, element) {
            // Round off to avoid float errors, like tests where opacity lands on
            // 9.86957e-06 instead of 0
            const opacity = Number(Number(value).toFixed(3));
            this.opacity = opacity;
            element.setAttribute(key, opacity);
        }
        /**
         * Re-align an aligned text or label after setting the text.
         *
         * @private
         * @function Highcharts.SVGElement#reAlign
         *
         */
        reAlign() {
            if (this.alignOptions?.width && this.alignOptions.align !== 'left') {
                this.alignOptions.width = this.getBBox().width;
                this.placed = false; // Block animation
                this.align();
            }
        }
        /**
         * Remove a class name from the element.
         *
         * @function Highcharts.SVGElement#removeClass
         *
         * @param {string|RegExp} className
         *        The class name to remove.
         *
         * @return {Highcharts.SVGElement} Returns the SVG element for chainability.
         */
        removeClass(className) {
            return this.attr('class', ('' + this.attr('class'))
                .replace(isString$4(className) ?
                new RegExp(`(^| )${className}( |$)`) : // #12064, #13590
                className, ' ')
                .replace(/ +/g, ' ')
                .trim());
        }
        /**
         *
         * @private
         */
        removeTextOutline() {
            const outline = this.element
                .querySelector('tspan.highcharts-text-outline');
            if (outline) {
                this.safeRemoveChild(outline);
            }
        }
        /**
         * Removes an element from the DOM.
         *
         * @private
         * @function Highcharts.SVGElement#safeRemoveChild
         *
         * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element
         * The DOM node to remove.
         */
        safeRemoveChild(element) {
            const parentNode = element.parentNode;
            if (parentNode) {
                parentNode.removeChild(element);
            }
        }
        /**
         * Set the coordinates needed to draw a consistent radial gradient across
         * a shape regardless of positioning inside the chart. Used on pie slices
         * to make all the slices have the same radial reference point.
         *
         * @function Highcharts.SVGElement#setRadialReference
         *
         * @param {Array<number>} coordinates
         * The center reference. The format is `[centerX, centerY, diameter]` in
         * pixels.
         *
         * @return {Highcharts.SVGElement}
         * Returns the SVGElement for chaining.
         */
        setRadialReference(coordinates) {
            const existingGradient = (this.element.gradient &&
                this.renderer.gradients[this.element.gradient]);
            this.element.radialReference = coordinates;
            // On redrawing objects with an existing gradient, the gradient needs
            // to be repositioned (#3801)
            if (existingGradient && existingGradient.radAttr) {
                existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
            }
            return this;
        }
        /**
         * Add a shadow to the element. In styled mode, this method is not used,
         * instead use `defs` and filters.
         *
         * @example
         * renderer.rect(10, 100, 100, 100)
         *     .attr({ fill: 'red' })
         *     .shadow(true);
         *
         * @function Highcharts.SVGElement#shadow
         *
         * @param {boolean|Highcharts.ShadowOptionsObject} [shadowOptions] The
         *        shadow options. If `true`, the default options are applied. If
         *        `false`, the current shadow will be removed.
         *
         * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
         */
        shadow(shadowOptions) {
            const { renderer } = this, options = merge$5(this.parentGroup?.rotation === 90 ? {
                offsetX: -1,
                offsetY: -1
            } : {}, isObject$2(shadowOptions) ? shadowOptions : {}), id = renderer.shadowDefinition(options);
            return this.attr({
                filter: shadowOptions ?
                    `url(${renderer.url}#${id})` :
                    'none'
            });
        }
        /**
         * Show the element after it has been hidden.
         *
         * @function Highcharts.SVGElement#show
         *
         * @param {boolean} [inherit=true]
         *        Set the visibility attribute to `inherit` rather than `visible`.
         *        The difference is that an element with `visibility="visible"`
         *        will be visible even if the parent is hidden.
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVGElement for chaining.
         */
        show(inherit = true) {
            return this.attr({ visibility: inherit ? 'inherit' : 'visible' });
        }
        /**
         * Set the stroke-width and record it on the SVGElement
         *
         * @private
         * @function Highcharts.SVGElement#strokeSetter
         * @param {number|string|ColorType} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        'stroke-widthSetter'(value, key, element) {
            // Record it for quick access in getter
            this[key] = value;
            element.setAttribute(key, value);
        }
        /**
         * Get the computed stroke width in pixel values. This is used extensively
         * when drawing shapes to ensure the shapes are rendered crisp and
         * positioned correctly relative to each other. Using
         * `shape-rendering: crispEdges` leaves us less control over positioning,
         * for example when we want to stack columns next to each other, or position
         * things pixel-perfectly within the plot box.
         *
         * The common pattern when placing a shape is:
         * - Create the SVGElement and add it to the DOM. In styled mode, it will
         *   now receive a stroke width from the style sheet. In classic mode we
         *   will add the `stroke-width` attribute.
         * - Read the computed `elem.strokeWidth()`.
         * - Place it based on the stroke width.
         *
         * @function Highcharts.SVGElement#strokeWidth
         *
         * @return {number}
         * The stroke width in pixels. Even if the given stroke width (in CSS or by
         * attributes) is based on `em` or other units, the pixel size is returned.
         */
        strokeWidth() {
            // In non-styled mode, read the stroke width as set by .attr
            if (!this.renderer.styledMode) {
                return this['stroke-width'] || 0;
            }
            // In styled mode, read computed stroke width
            const val = this.getStyle('stroke-width');
            let ret = 0, tempElement;
            // Read pixel values directly
            if (/px$/.test(val)) {
                ret = pInt$2(val);
                // Other values like em, pt etc need to be measured
            }
            else if (val !== '') {
                tempElement = doc$3.createElementNS(SVG_NS$2, 'rect');
                attr$3(tempElement, {
                    width: val,
                    'stroke-width': 0
                });
                this.element.parentNode.appendChild(tempElement);
                ret = tempElement.getBBox().width;
                tempElement.parentNode.removeChild(tempElement);
            }
            return ret;
        }
        /**
         * If one of the symbol size affecting parameters are changed,
         * check all the others only once for each call to an element's
         * .attr() method
         *
         * @private
         * @function Highcharts.SVGElement#symbolAttr
         *
         * @param {Highcharts.SVGAttributes} hash
         * The attributes to set.
         */
        symbolAttr(hash) {
            const wrapper = this;
            SVGElement.symbolCustomAttribs.forEach(function (key) {
                wrapper[key] = pick$7(hash[key], wrapper[key]);
            });
            wrapper.attr({
                d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
            });
        }
        /**
         * @private
         * @function Highcharts.SVGElement#textSetter
         * @param {string} value
         */
        textSetter(value) {
            if (value !== this.textStr) {
                // Delete size caches when the text changes
                // delete this.bBox; // old code in series-label
                delete this.textPxLength;
                this.textStr = value;
                if (this.added) {
                    this.renderer.buildText(this);
                }
                this.reAlign();
            }
        }
        /**
         * @private
         * @function Highcharts.SVGElement#titleSetter
         * @param {string} value
         */
        titleSetter(value) {
            const el = this.element;
            const titleNode = el.getElementsByTagName('title')[0] ||
                doc$3.createElementNS(this.SVG_NS, 'title');
            // Move to first child
            if (el.insertBefore) {
                el.insertBefore(titleNode, el.firstChild);
            }
            else {
                el.appendChild(titleNode);
            }
            // Replace text content and escape markup
            titleNode.textContent = replaceNested$1(// Scan #[73]
            pick$7(value, ''), // #3276, #3895
            [/<[^>]*>/g, '']).replace(/&lt;/g, '<').replace(/&gt;/g, '>');
        }
        /**
         * Bring the element to the front. Alternatively, a new zIndex can be set.
         *
         * @sample highcharts/members/element-tofront/
         *         Click an element to bring it to front
         *
         * @function Highcharts.SVGElement#toFront
         *
         * @return {Highcharts.SVGElement}
         * Returns the SVGElement for chaining.
         */
        toFront() {
            const element = this.element;
            element.parentNode.appendChild(element);
            return this;
        }
        /**
         * Move an object and its children by x and y values.
         *
         * @function Highcharts.SVGElement#translate
         *
         * @param {number} x
         * The x value.
         *
         * @param {number} y
         * The y value.
         *
         * @return {Highcharts.SVGElement}
         * Translated element.
         */
        translate(x, y) {
            return this.attr({
                translateX: x,
                translateY: y
            });
        }
        /**
         * Update the transform attribute based on internal properties. Deals with
         * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`
         * attributes and updates the SVG `transform` attribute.
         *
         * @private
         * @function Highcharts.SVGElement#updateTransform
         */
        updateTransform(attrib = 'transform') {
            const { element, matrix, rotation = 0, rotationOriginX, rotationOriginY, scaleX, scaleY, translateX = 0, translateY = 0 } = this;
            // Apply translate. Nearly all transformed elements have translation,
            // so instead of checking for translate = 0, do it always (#1767,
            // #1846).
            const transform = ['translate(' + translateX + ',' + translateY + ')'];
            // Apply matrix
            if (defined$6(matrix)) {
                transform.push('matrix(' + matrix.join(',') + ')');
            }
            // Apply rotation
            if (rotation) {
                transform.push('rotate(' + rotation + ' ' +
                    pick$7(rotationOriginX, element.getAttribute('x'), 0) +
                    ' ' +
                    pick$7(rotationOriginY, element.getAttribute('y') || 0) + ')');
                // HTML labels rotation (#20685)
                if (this.text?.element.tagName === 'SPAN') {
                    this.text.attr({
                        rotation,
                        rotationOriginX: (rotationOriginX || 0) - this.padding,
                        rotationOriginY: (rotationOriginY || 0) - this.padding
                    });
                }
            }
            // Apply scale
            if (defined$6(scaleX) || defined$6(scaleY)) {
                transform.push('scale(' + pick$7(scaleX, 1) + ' ' + pick$7(scaleY, 1) + ')');
            }
            if (transform.length && !(this.text || this).textPath) {
                element.setAttribute(attrib, transform.join(' '));
            }
        }
        /**
         * @private
         * @function Highcharts.SVGElement#visibilitySetter
         *
         * @param {string} value
         *
         * @param {string} key
         *
         * @param {Highcharts.SVGDOMElement} element
         *
         */
        visibilitySetter(value, key, element) {
            // IE9-11 doesn't handle visibility:inherit well, so we remove the
            // attribute instead (#2881, #3909)
            if (value === 'inherit') {
                element.removeAttribute(key);
            }
            else if (this[key] !== value) { // #6747
                element.setAttribute(key, value);
            }
            this[key] = value;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#xGetter
         */
        xGetter(key) {
            if (this.element.nodeName === 'circle') {
                if (key === 'x') {
                    key = 'cx';
                }
                else if (key === 'y') {
                    key = 'cy';
                }
            }
            return this._defaultGetter(key);
        }
        /**
         * @private
         * @function Highcharts.SVGElement#zIndexSetter
         */
        zIndexSetter(value, key) {
            const renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;
            let childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;
            if (defined$6(value)) {
                // So we can read it for other elements in the group
                element.setAttribute('data-z-index', value);
                value = +value;
                if (this[key] === value) {
                    // Only update when needed (#3865)
                    run = false;
                }
            }
            else if (defined$6(this[key])) {
                element.removeAttribute('data-z-index');
            }
            this[key] = value;
            // Insert according to this and other elements' zIndex. Before .add() is
            // called, nothing is done. Then on add, or by later calls to
            // zIndexSetter, the node is placed on the right place in the DOM.
            if (run) {
                value = this.zIndex;
                if (value && parentGroup) {
                    parentGroup.handleZ = true;
                }
                childNodes = parentNode.childNodes;
                for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
                    otherElement = childNodes[i];
                    otherZIndex = otherElement.getAttribute('data-z-index');
                    undefinedOtherZIndex = !defined$6(otherZIndex);
                    if (otherElement !== element) {
                        if (
                        // Negative zIndex versus no zIndex:
                        // On all levels except the highest. If the parent is
                        // <svg>, then we don't want to put items before <desc>
                        // or <defs>
                        value < 0 &&
                            undefinedOtherZIndex &&
                            !svgParent &&
                            !i) {
                            parentNode.insertBefore(element, childNodes[i]);
                            inserted = true;
                        }
                        else if (
                        // Insert after the first element with a lower zIndex
                        pInt$2(otherZIndex) <= value ||
                            // If negative zIndex, add this before first undefined
                            // zIndex element
                            (undefinedOtherZIndex &&
                                (!defined$6(value) || value >= 0))) {
                            parentNode.insertBefore(element, childNodes[i + 1]);
                            inserted = true;
                        }
                    }
                }
                if (!inserted) {
                    parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0]);
                    inserted = true;
                }
            }
            return inserted;
        }
    }
    /* *
     *
     *  Properties
     *
     * */
    // Custom attributes used for symbols, these should be filtered out when
    // setting SVGElement attributes (#9375).
    SVGElement.symbolCustomAttribs = [
        'anchorX',
        'anchorY',
        'clockwise',
        'end',
        'height',
        'innerR',
        'r',
        'start',
        'width',
        'x',
        'y'
    ];
    // Some shared setters and getters
    SVGElement.prototype.strokeSetter = SVGElement.prototype.fillSetter;
    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
    SVGElement.prototype.matrixSetter =
        SVGElement.prototype.rotationOriginXSetter =
            SVGElement.prototype.rotationOriginYSetter =
                SVGElement.prototype.rotationSetter =
                    SVGElement.prototype.scaleXSetter =
                        SVGElement.prototype.scaleYSetter =
                            SVGElement.prototype.translateXSetter =
                                SVGElement.prototype.translateYSetter =
                                    SVGElement.prototype.verticalAlignSetter = function (value, key) {
                                        this[key] = value;
                                        this.doTransform = true;
                                    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animObject: animObject$2, setAnimation: setAnimation$1 } = animationExports;
    const { defaultOptions: defaultOptions$2 } = DefaultOptions;
    const { registerEventOptions: registerEventOptions$1 } = Foundation$1;
    const { svg: svg$1, win: win$3 } = H;
    const { seriesTypes: seriesTypes$1 } = SeriesRegistry$1;
    const { arrayMax, arrayMin, clamp: clamp$1, correctFloat, crisp: crisp$2, defined: defined$5, destroyObjectProperties: destroyObjectProperties$1, diffObjects: diffObjects$1, erase: erase$1, error: error$1, extend: extend$5, find: find$1, fireEvent: fireEvent$3, getClosestDistance, getNestedProperty, insertItem, isArray: isArray$3, isNumber: isNumber$5, isString: isString$3, merge: merge$4, objectEach: objectEach$3, pick: pick$6, removeEvent: removeEvent$2, splat: splat$1, syncTimeout: syncTimeout$1 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /**
     * This is the base series prototype that all other series types inherit from.
     * A new series is initialized either through the
     * [series](https://api.highcharts.com/highcharts/series)
     * option structure, or after the chart is initialized, through
     * {@link Highcharts.Chart#addSeries}.
     *
     * The object can be accessed in a number of ways. All series and point event
     * handlers give a reference to the `series` object. The chart object has a
     * {@link Highcharts.Chart#series|series} property that is a collection of all
     * the chart's series. The point objects and axis objects also have the same
     * reference.
     *
     * Another way to reference the series programmatically is by `id`. Add an id
     * in the series configuration options, and get the series object by
     * {@link Highcharts.Chart#get}.
     *
     * Configuration options for the series are given in three levels. Options for
     * all series in a chart are given in the
     * [plotOptions.series](https://api.highcharts.com/highcharts/plotOptions.series)
     * object. Then options for all series of a specific type
     * are given in the plotOptions of that type, for example `plotOptions.line`.
     * Next, options for one single series are given in the series array, or as
     * arguments to `chart.addSeries`.
     *
     * The data in the series is stored in various arrays.
     *
     * - First, `series.options.data` contains all the original config options for
     *   each point whether added by options or methods like `series.addPoint`.
     *
     * - Next, `series.data` contains those values converted to points, but in case
     *   the series data length exceeds the `cropThreshold`, or if the data is
     *   grouped, `series.data` doesn't contain all the points. It only contains the
     *   points that have been created on demand.
     *
     * - Then there's `series.points` that contains all currently visible point
     *   objects. In case of cropping, the cropped-away points are not part of this
     *   array. The `series.points` array starts at `series.cropStart` compared to
     *   `series.data` and `series.options.data`. If however the series data is
     *   grouped, these can't be correlated one to one.
     *
     * - `series.xData` and `series.processedXData` contain clean x values,
     *   equivalent to `series.data` and `series.points`.
     *
     * - `series.yData` and `series.processedYData` contain clean y values,
     *   equivalent to `series.data` and `series.points`.
     *
     * @class
     * @name Highcharts.Series
     *
     * @param {Highcharts.Chart} chart
     * The chart instance.
     *
     * @param {Highcharts.SeriesOptionsType|object} options
     * The series options.
     */
    class Series {
        constructor() {
            /* *
             *
             *  Static Properties
             *
             * */
            this.zoneAxis = 'y';
            // eslint-enable valid-jsdoc
        }
        /* *
         *
         *  Functions
         *
         * */
        /* eslint-disable valid-jsdoc */
        init(chart, userOptions) {
            fireEvent$3(this, 'init', { options: userOptions });
            const series = this, chartSeries = chart.series;
            // The 'eventsToUnbind' property moved from prototype into the
            // Series init to avoid reference to the same array between
            // the different series and charts. #12959, #13937
            this.eventsToUnbind = [];
            /**
             * Read only. The chart that the series belongs to.
             *
             * @name Highcharts.Series#chart
             * @type {Highcharts.Chart}
             */
            series.chart = chart;
            /**
             * Read only. The series' type, like "line", "area", "column" etc.
             * The type in the series options anc can be altered using
             * {@link Series#update}.
             *
             * @name Highcharts.Series#type
             * @type {string}
             */
            /**
             * Read only. The series' current options. To update, use
             * {@link Series#update}.
             *
             * @name Highcharts.Series#options
             * @type {Highcharts.SeriesOptionsType}
             */
            series.options = series.setOptions(userOptions);
            const options = series.options, visible = options.visible !== false;
            /**
             * All child series that are linked to the current series through the
             * [linkedTo](https://api.highcharts.com/highcharts/series.line.linkedTo)
             * option.
             *
             * @name Highcharts.Series#linkedSeries
             * @type {Array<Highcharts.Series>}
             * @readonly
             */
            series.linkedSeries = [];
            // Bind the axes
            series.bindAxes();
            extend$5(series, {
                /**
                 * The series name as given in the options. Defaults to
                 * "Series {n}".
                 *
                 * @name Highcharts.Series#name
                 * @type {string}
                 */
                name: options.name,
                state: '',
                /**
                 * Read only. The series' visibility state as set by {@link
                 * Series#show}, {@link Series#hide}, or in the initial
                 * configuration.
                 *
                 * @name Highcharts.Series#visible
                 * @type {boolean}
                 */
                visible, // True by default
                /**
                 * Read only. The series' selected state as set by {@link
                 * Highcharts.Series#select}.
                 *
                 * @name Highcharts.Series#selected
                 * @type {boolean}
                 */
                selected: options.selected === true // False by default
            });
            registerEventOptions$1(this, options);
            const events = options.events;
            if ((events && events.click) ||
                (options.point &&
                    options.point.events &&
                    options.point.events.click) ||
                options.allowPointSelect) {
                chart.runTrackerClick = true;
            }
            series.getColor();
            series.getSymbol();
            // Initialize the parallel data arrays
            series.parallelArrays.forEach(function (key) {
                if (!series[key + 'Data']) {
                    series[key + 'Data'] = [];
                }
            });
            // Mark cartesian
            if (series.isCartesian) {
                chart.hasCartesianSeries = true;
            }
            // Get the index and register the series in the chart. The index is
            // one more than the current latest series index (#5960).
            let lastSeries;
            if (chartSeries.length) {
                lastSeries = chartSeries[chartSeries.length - 1];
            }
            series._i = pick$6(lastSeries && lastSeries._i, -1) + 1;
            series.opacity = series.options.opacity;
            // Insert the series and re-order all series above the insertion
            // point.
            chart.orderItems('series', insertItem(this, chartSeries));
            // Set options for series with sorting and set data later.
            if (options.dataSorting && options.dataSorting.enabled) {
                series.setDataSortingOptions();
            }
            else if (!series.points && !series.data) {
                series.setData(options.data, false);
            }
            fireEvent$3(this, 'afterInit');
        }
        /**
         * Check whether the series item is itself or inherits from a certain
         * series type.
         *
         * @function Highcharts.Series#is
         * @param {string} type The type of series to check for, can be either
         *        featured or custom series types. For example `column`, `pie`,
         *        `ohlc` etc.
         *
         * @return {boolean}
         *        True if this item is or inherits from the given type.
         */
        is(type) {
            return seriesTypes$1[type] && this instanceof seriesTypes$1[type];
        }
        /**
         * Set the xAxis and yAxis properties of cartesian series, and register
         * the series in the `axis.series` array.
         *
         * @private
         * @function Highcharts.Series#bindAxes
         */
        bindAxes() {
            const series = this, seriesOptions = series.options, chart = series.chart;
            let axisOptions;
            fireEvent$3(this, 'bindAxes', null, function () {
                // Repeat for xAxis and yAxis
                (series.axisTypes || []).forEach(function (coll) {
                    // Loop through the chart's axis objects
                    (chart[coll] || []).forEach(function (axis) {
                        axisOptions = axis.options;
                        // Apply if the series xAxis or yAxis option matches
                        // the number of the axis, or if undefined, use the
                        // first axis
                        if (pick$6(seriesOptions[coll], 0) === axis.index ||
                            (typeof seriesOptions[coll] !==
                                'undefined' &&
                                seriesOptions[coll] === axisOptions.id)) {
                            // Register this series in the axis.series lookup
                            insertItem(series, axis.series);
                            // Set this series.xAxis or series.yAxis reference
                            /**
                             * Read only. The unique xAxis object associated
                             * with the series.
                             *
                             * @name Highcharts.Series#xAxis
                             * @type {Highcharts.Axis}
                             */
                            /**
                             * Read only. The unique yAxis object associated
                             * with the series.
                             *
                             * @name Highcharts.Series#yAxis
                             * @type {Highcharts.Axis}
                             */
                            series[coll] = axis;
                            // Mark dirty for redraw
                            axis.isDirty = true;
                        }
                    });
                    // The series needs an X and an Y axis
                    if (!series[coll] &&
                        series.optionalAxis !== coll) {
                        error$1(18, true, chart);
                    }
                });
            });
            fireEvent$3(this, 'afterBindAxes');
        }
        /**
         * For simple series types like line and column, the data values are
         * held in arrays like xData and yData for quick lookup to find extremes
         * and more. For multidimensional series like bubble and map, this can
         * be extended with arrays like zData and valueData by adding to the
         * `series.parallelArrays` array.
         *
         * @private
         * @function Highcharts.Series#updateParallelArrays
         */
        updateParallelArrays(point, i, iArgs) {
            const series = point.series, fn = isNumber$5(i) ?
                // Insert the value in the given position
                function (key) {
                    const val = key === 'y' && series.toYData ?
                        series.toYData(point) :
                        point[key];
                    series[key + 'Data'][i] = val;
                } :
                // Apply the method specified in i with the following
                // arguments as arguments
                function (key) {
                    Array.prototype[i].apply(series[key + 'Data'], iArgs);
                };
            series.parallelArrays.forEach(fn);
        }
        /**
         * Define hasData functions for series. These return true if there
         * are data points on this series within the plot area.
         *
         * @private
         * @function Highcharts.Series#hasData
         */
        hasData() {
            return ((this.visible &&
                typeof this.dataMax !== 'undefined' &&
                typeof this.dataMin !== 'undefined') || ( // #3703
            this.visible &&
                this.yData &&
                this.yData.length > 0) // #9758
            );
        }
        /**
         * Determine whether the marker in a series has changed.
         *
         * @private
         * @function Highcharts.Series#hasMarkerChanged
         */
        hasMarkerChanged(options, oldOptions) {
            const marker = options.marker, oldMarker = oldOptions.marker || {};
            return marker && ((oldMarker.enabled && !marker.enabled) ||
                oldMarker.symbol !== marker.symbol || // #10870, #15946
                oldMarker.height !== marker.height || // #16274
                oldMarker.width !== marker.width // #16274
            );
        }
        /**
         * Return an auto incremented x value based on the pointStart and
         * pointInterval options. This is only used if an x value is not given
         * for the point that calls autoIncrement.
         *
         * @private
         * @function Highcharts.Series#autoIncrement
         */
        autoIncrement(x) {
            const options = this.options, pointIntervalUnit = options.pointIntervalUnit, relativeXValue = options.relativeXValue, time = this.chart.time;
            let xIncrement = this.xIncrement, date, pointInterval;
            xIncrement = pick$6(xIncrement, options.pointStart, 0);
            this.pointInterval = pointInterval = pick$6(this.pointInterval, options.pointInterval, 1);
            if (relativeXValue && isNumber$5(x)) {
                pointInterval *= x;
            }
            // Added code for pointInterval strings
            if (pointIntervalUnit) {
                date = new time.Date(xIncrement);
                if (pointIntervalUnit === 'day') {
                    time.set('Date', date, time.get('Date', date) + pointInterval);
                }
                else if (pointIntervalUnit === 'month') {
                    time.set('Month', date, time.get('Month', date) + pointInterval);
                }
                else if (pointIntervalUnit === 'year') {
                    time.set('FullYear', date, time.get('FullYear', date) + pointInterval);
                }
                pointInterval = date.getTime() - xIncrement;
            }
            if (relativeXValue && isNumber$5(x)) {
                return xIncrement + pointInterval;
            }
            this.xIncrement = xIncrement + pointInterval;
            return xIncrement;
        }
        /**
         * Internal function to set properties for series if data sorting is
         * enabled.
         *
         * @private
         * @function Highcharts.Series#setDataSortingOptions
         */
        setDataSortingOptions() {
            const options = this.options;
            extend$5(this, {
                requireSorting: false,
                sorted: false,
                enabledDataSorting: true,
                allowDG: false
            });
            // To allow unsorted data for column series.
            if (!defined$5(options.pointRange)) {
                options.pointRange = 1;
            }
        }
        /**
         * Set the series options by merging from the options tree. Called
         * internally on initializing and updating series. This function will
         * not redraw the series. For API usage, use {@link Series#update}.
         * @private
         * @function Highcharts.Series#setOptions
         * @param {Highcharts.SeriesOptionsType} itemOptions
         * The series options.
         * @emits Highcharts.Series#event:afterSetOptions
         */
        setOptions(itemOptions) {
            const chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge$4(itemOptions), styledMode = chart.styledMode, e = {
                plotOptions: plotOptions,
                userOptions: seriesUserOptions
            };
            let zone;
            fireEvent$3(this, 'setOptions', e);
            // These may be modified by the event
            const typeOptions = e.plotOptions[this.type], userPlotOptions = (userOptions.plotOptions || {}), userPlotOptionsSeries = userPlotOptions.series || {}, defaultPlotOptionsType = (defaultOptions$2.plotOptions[this.type] || {}), userPlotOptionsType = userPlotOptions[this.type] || {};
            // Use copy to prevent undetected changes (#9762)
            /**
             * Contains series options by the user without defaults.
             * @name Highcharts.Series#userOptions
             * @type {Highcharts.SeriesOptionsType}
             */
            this.userOptions = e.userOptions;
            const options = merge$4(typeOptions, plotOptions.series, 
            // #3881, chart instance plotOptions[type] should trump
            // plotOptions.series
            userPlotOptionsType, seriesUserOptions);
            // The tooltip options are merged between global and series specific
            // options. Importance order asscendingly:
            // globals: (1)tooltip, (2)plotOptions.series,
            // (3)plotOptions[this.type]
            // init userOptions with possible later updates: 4-6 like 1-3 and
            // (7)this series options
            this.tooltipOptions = merge$4(defaultOptions$2.tooltip, // 1
            defaultOptions$2.plotOptions.series?.tooltip, // 2
            defaultPlotOptionsType?.tooltip, // 3
            chart.userOptions.tooltip, // 4
            userPlotOptions.series?.tooltip, // 5
            userPlotOptionsType.tooltip, // 6
            seriesUserOptions.tooltip // 7
            );
            // When shared tooltip, stickyTracking is true by default,
            // unless user says otherwise.
            this.stickyTracking = pick$6(seriesUserOptions.stickyTracking, userPlotOptionsType.stickyTracking, userPlotOptionsSeries.stickyTracking, (this.tooltipOptions.shared && !this.noSharedTooltip ?
                true :
                options.stickyTracking));
            // Delete marker object if not allowed (#1125)
            if (typeOptions.marker === null) {
                delete options.marker;
            }
            // Handle color zones
            this.zoneAxis = options.zoneAxis || 'y';
            const zones = this.zones = // #20440, create deep copy of zones options
                (options.zones || []).map((z) => ({ ...z }));
            if ((options.negativeColor || options.negativeFillColor) &&
                !options.zones) {
                zone = {
                    value: options[this.zoneAxis + 'Threshold'] ||
                        options.threshold ||
                        0,
                    className: 'highcharts-negative'
                };
                if (!styledMode) {
                    zone.color = options.negativeColor;
                    zone.fillColor = options.negativeFillColor;
                }
                zones.push(zone);
            }
            // Push one extra zone for the rest
            if (zones.length && defined$5(zones[zones.length - 1].value)) {
                zones.push(styledMode ? {} : {
                    color: this.color,
                    fillColor: this.fillColor
                });
            }
            fireEvent$3(this, 'afterSetOptions', { options: options });
            return options;
        }
        /**
         * Return series name in "Series {Number}" format or the one defined by
         * a user. This method can be simply overridden as series name format
         * can vary (e.g. technical indicators).
         *
         * @function Highcharts.Series#getName
         *
         * @return {string}
         * The series name.
         */
        getName() {
            // #4119
            return pick$6(this.options.name, 'Series ' + (this.index + 1));
        }
        /**
         * @private
         * @function Highcharts.Series#getCyclic
         */
        getCyclic(prop, value, defaults) {
            const chart = this.chart, indexName = `${prop}Index`, counterName = `${prop}Counter`, len = (
            // Symbol count
            defaults?.length ||
                // Color count
                chart.options.chart.colorCount);
            let i, setting;
            if (!value) {
                // Pick up either the colorIndex option, or the series.colorIndex
                // after Series.update()
                setting = pick$6(prop === 'color' ? this.options.colorIndex : void 0, this[indexName]);
                if (defined$5(setting)) { // After Series.update()
                    i = setting;
                }
                else {
                    // #6138
                    if (!chart.series.length) {
                        chart[counterName] = 0;
                    }
                    i = chart[counterName] % len;
                    chart[counterName] += 1;
                }
                if (defaults) {
                    value = defaults[i];
                }
            }
            // Set the colorIndex
            if (typeof i !== 'undefined') {
                this[indexName] = i;
            }
            this[prop] = value;
        }
        /**
         * Get the series' color based on either the options or pulled from
         * global options.
         *
         * @private
         * @function Highcharts.Series#getColor
         */
        getColor() {
            if (this.chart.styledMode) {
                this.getCyclic('color');
            }
            else if (this.options.colorByPoint) {
                this.color = "#cccccc" /* Palette.neutralColor20 */;
            }
            else {
                this.getCyclic('color', this.options.color ||
                    defaultOptions$2.plotOptions[this.type].color, this.chart.options.colors);
            }
        }
        /**
         * Get all points' instances created for this series.
         *
         * @private
         * @function Highcharts.Series#getPointsCollection
         */
        getPointsCollection() {
            return (this.hasGroupedData ? this.points : this.data) || [];
        }
        /**
         * Get the series' symbol based on either the options or pulled from
         * global options.
         *
         * @private
         * @function Highcharts.Series#getSymbol
         */
        getSymbol() {
            const seriesMarkerOption = this.options.marker;
            this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);
        }
        /**
         * Finds the index of an existing point that matches the given point
         * options.
         *
         * @private
         * @function Highcharts.Series#findPointIndex
         * @param {Highcharts.PointOptionsObject} optionsObject
         * The options of the point.
         * @param {number} fromIndex
         * The index to start searching from, used for optimizing series with
         * required sorting.
         * @return {number|undefined}
         * Returns the index of a matching point, or undefined if no match is found.
         */
        findPointIndex(optionsObject, fromIndex) {
            const id = optionsObject.id, x = optionsObject.x, oldData = this.points, dataSorting = this.options.dataSorting;
            let matchingPoint, matchedById, pointIndex;
            if (id) {
                const item = this.chart.get(id);
                if (item instanceof Point) {
                    matchingPoint = item;
                }
            }
            else if (this.linkedParent ||
                this.enabledDataSorting ||
                this.options.relativeXValue) {
                let matcher = (oldPoint) => !oldPoint.touched &&
                    oldPoint.index === optionsObject.index;
                if (dataSorting && dataSorting.matchByName) {
                    matcher = (oldPoint) => !oldPoint.touched &&
                        oldPoint.name === optionsObject.name;
                }
                else if (this.options.relativeXValue) {
                    matcher = (oldPoint) => !oldPoint.touched &&
                        oldPoint.options.x === optionsObject.x;
                }
                matchingPoint = find$1(oldData, matcher);
                // Add unmatched point as a new point
                if (!matchingPoint) {
                    return void 0;
                }
            }
            if (matchingPoint) {
                pointIndex = matchingPoint && matchingPoint.index;
                if (typeof pointIndex !== 'undefined') {
                    matchedById = true;
                }
            }
            // Search for the same X in the existing data set
            if (typeof pointIndex === 'undefined' && isNumber$5(x)) {
                pointIndex = this.xData.indexOf(x, fromIndex);
            }
            // Reduce pointIndex if data is cropped
            if (pointIndex !== -1 &&
                typeof pointIndex !== 'undefined' &&
                this.cropped) {
                pointIndex = (pointIndex >= this.cropStart) ?
                    pointIndex - this.cropStart : pointIndex;
            }
            if (!matchedById &&
                isNumber$5(pointIndex) &&
                oldData[pointIndex] && oldData[pointIndex].touched) {
                pointIndex = void 0;
            }
            return pointIndex;
        }
        /**
         * Internal function called from setData. If the point count is the same
         * as it was, or if there are overlapping X values, just run
         * Point.update which is cheaper, allows animation, and keeps references
         * to points. This also allows adding or removing points if the X-es
         * don't match.
         *
         * @private
         * @function Highcharts.Series#updateData
         */
        updateData(data, animation) {
            const options = this.options, dataSorting = options.dataSorting, oldData = this.points, pointsToAdd = [], requireSorting = this.requireSorting, equalLength = data.length === oldData.length;
            let hasUpdatedByKey, i, point, lastIndex, succeeded = true;
            this.xIncrement = null;
            // Iterate the new data
            data.forEach(function (pointOptions, i) {
                const optionsObject = (defined$5(pointOptions) &&
                    this.pointClass.prototype.optionsToObject.call({ series: this }, pointOptions)) || {};
                let pointIndex;
                // Get the x of the new data point
                const x = optionsObject.x, id = optionsObject.id;
                if (id || isNumber$5(x)) {
                    pointIndex = this.findPointIndex(optionsObject, lastIndex);
                    // Matching X not found
                    // or used already due to ununique x values (#8995),
                    // add point (but later)
                    if (pointIndex === -1 ||
                        typeof pointIndex === 'undefined') {
                        pointsToAdd.push(pointOptions);
                        // Matching X found, update
                    }
                    else if (oldData[pointIndex] &&
                        pointOptions !== options.data[pointIndex]) {
                        oldData[pointIndex].update(pointOptions, false, null, false);
                        // Mark it touched, below we will remove all points that
                        // are not touched.
                        oldData[pointIndex].touched = true;
                        // Speed optimize by only searching after last known
                        // index. Performs ~20% bettor on large data sets.
                        if (requireSorting) {
                            lastIndex = pointIndex + 1;
                        }
                        // Point exists, no changes, don't remove it
                    }
                    else if (oldData[pointIndex]) {
                        oldData[pointIndex].touched = true;
                    }
                    // If the length is equal and some of the nodes had a
                    // match in the same position, we don't want to remove
                    // non-matches.
                    if (!equalLength ||
                        i !== pointIndex ||
                        (dataSorting && dataSorting.enabled) ||
                        this.hasDerivedData) {
                        hasUpdatedByKey = true;
                    }
                }
                else {
                    // Gather all points that are not matched
                    pointsToAdd.push(pointOptions);
                }
            }, this);
            // Remove points that don't exist in the updated data set
            if (hasUpdatedByKey) {
                i = oldData.length;
                while (i--) {
                    point = oldData[i];
                    if (point && !point.touched && point.remove) {
                        point.remove(false, animation);
                    }
                }
                // If we did not find keys (ids or x-values), and the length is the
                // same, update one-to-one
            }
            else if (equalLength && (!dataSorting || !dataSorting.enabled)) {
                data.forEach(function (point, i) {
                    // .update doesn't exist on a linked, hidden series (#3709)
                    // (#10187)
                    if (point !== oldData[i].y && !oldData[i].destroyed) {
                        oldData[i].update(point, false, null, false);
                    }
                });
                // Don't add new points since those configs are used above
                pointsToAdd.length = 0;
                // Did not succeed in updating data
            }
            else {
                succeeded = false;
            }
            oldData.forEach(function (point) {
                if (point) {
                    point.touched = false;
                }
            });
            if (!succeeded) {
                return false;
            }
            // Add new points
            pointsToAdd.forEach(function (point) {
                this.addPoint(point, false, null, null, false);
            }, this);
            if (this.xIncrement === null &&
                this.xData &&
                this.xData.length) {
                this.xIncrement = arrayMax(this.xData);
                this.autoIncrement();
            }
            return true;
        }
        /**
         * Apply a new set of data to the series and optionally redraw it. The
         * new data array is passed by reference (except in case of
         * `updatePoints`), and may later be mutated when updating the chart
         * data.
         *
         * Note the difference in behaviour when setting the same amount of
         * points, or a different amount of points, as handled by the
         * `updatePoints` parameter.
         *
         * @sample highcharts/members/series-setdata/
         *         Set new data from a button
         * @sample highcharts/members/series-setdata-pie/
         *         Set data in a pie
         * @sample stock/members/series-setdata/
         *         Set new data in Highcharts Stock
         * @sample maps/members/series-setdata/
         *         Set new data in Highmaps
         *
         * @function Highcharts.Series#setData
         *
         * @param {Array<Highcharts.PointOptionsType>} data
         *        Takes an array of data in the same format as described under
         *        `series.{type}.data` for the given series type, for example a
         *        line series would take data in the form described under
         *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the series is altered. If
         *        doing more operations on the chart, it is a good idea to set
         *        redraw to false and call {@link Chart#redraw} after.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        When the updated data is the same length as the existing data,
         *        points will be updated by default, and animation visualizes
         *        how the points are changed. Set false to disable animation, or
         *        a configuration object to set duration or easing.
         *
         * @param {boolean} [updatePoints=true]
         *        When this is true, points will be updated instead of replaced
         *        whenever possible. This occurs a) when the updated data is the
         *        same length as the existing data, b) when points are matched
         *        by their id's, or c) when points can be matched by X values.
         *        This allows updating with animation and performs better. In
         *        this case, the original array is not passed by reference. Set
         *        `false` to prevent.
         */
        setData(data, redraw = true, animation, updatePoints) {
            const series = this, oldData = series.points, oldDataLength = (oldData && oldData.length) || 0, options = series.options, chart = series.chart, dataSorting = options.dataSorting, xAxis = series.xAxis, turboThreshold = options.turboThreshold, xData = this.xData, yData = this.yData, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, keys = options.keys;
            let i, pt, updatedData, indexOfX = 0, indexOfY = 1, copiedData;
            if (!chart.options.chart.allowMutatingData) { // #4259
                // Remove old reference
                if (options.data) {
                    delete series.options.data;
                }
                if (series.userOptions.data) {
                    delete series.userOptions.data;
                }
                copiedData = merge$4(true, data);
            }
            data = copiedData || data || [];
            const dataLength = data.length;
            if (dataSorting && dataSorting.enabled) {
                data = this.sortData(data);
            }
            // First try to run Point.update which is cheaper, allows animation,
            // and keeps references to points.
            if (chart.options.chart.allowMutatingData &&
                updatePoints !== false &&
                dataLength &&
                oldDataLength &&
                !series.cropped &&
                !series.hasGroupedData &&
                series.visible &&
                // Soft updating has no benefit in boost, and causes JS error
                // (#8355)
                !series.boosted) {
                updatedData = this.updateData(data, animation);
            }
            if (!updatedData) {
                // Reset properties
                series.xIncrement = null;
                series.colorCounter = 0; // For series with colorByPoint (#1547)
                // Update parallel arrays
                this.parallelArrays.forEach(function (key) {
                    series[key + 'Data'].length = 0;
                });
                // In turbo mode, look for one- or twodimensional arrays of numbers.
                // The first and the last valid value are tested, and we assume that
                // all the rest are defined the same way. Although the 'for' loops
                // are similar, they are repeated inside each if-else conditional
                // for max performance.
                let runTurbo = turboThreshold && dataLength > turboThreshold;
                if (runTurbo) {
                    const firstPoint = series.getFirstValidPoint(data), lastPoint = series.getFirstValidPoint(data, dataLength - 1, -1), isShortArray = (a) => Boolean(isArray$3(a) && (keys || isNumber$5(a[0])));
                    // Assume all points are numbers
                    if (isNumber$5(firstPoint) && isNumber$5(lastPoint)) {
                        for (i = 0; i < dataLength; i++) {
                            xData[i] = this.autoIncrement();
                            yData[i] = data[i];
                        }
                        // Assume all points are arrays when first point is
                    }
                    else if (isShortArray(firstPoint) &&
                        isShortArray(lastPoint)) {
                        if (valueCount) { // [x, low, high] or [x, o, h, l, c]
                            if (firstPoint.length === valueCount) {
                                for (i = 0; i < dataLength; i++) {
                                    xData[i] = this.autoIncrement();
                                    yData[i] = data[i];
                                }
                            }
                            else {
                                for (i = 0; i < dataLength; i++) {
                                    pt = data[i];
                                    xData[i] = pt[0];
                                    yData[i] =
                                        pt.slice(1, valueCount + 1);
                                }
                            }
                        }
                        else { // [x, y]
                            if (keys) {
                                indexOfX = keys.indexOf('x');
                                indexOfY = keys.indexOf('y');
                                indexOfX = indexOfX >= 0 ? indexOfX : 0;
                                indexOfY = indexOfY >= 0 ? indexOfY : 1;
                            }
                            if (firstPoint.length === 1) {
                                indexOfY = 0;
                            }
                            if (indexOfX === indexOfY) {
                                for (i = 0; i < dataLength; i++) {
                                    xData[i] = this.autoIncrement();
                                    yData[i] = data[i][indexOfY];
                                }
                            }
                            else {
                                for (i = 0; i < dataLength; i++) {
                                    pt = data[i];
                                    xData[i] = pt[indexOfX];
                                    yData[i] = pt[indexOfY];
                                }
                            }
                        }
                    }
                    else {
                        // Highcharts expects configs to be numbers or arrays in
                        // turbo mode
                        runTurbo = false;
                    }
                }
                if (!runTurbo) {
                    for (i = 0; i < dataLength; i++) {
                        pt = { series: series };
                        series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                        series.updateParallelArrays(pt, i);
                    }
                }
                // Forgetting to cast strings to numbers is a common caveat when
                // handling CSV or JSON
                if (yData && isString$3(yData[0])) {
                    error$1(14, true, chart);
                }
                series.data = [];
                series.options.data = series.userOptions.data = data;
                // Destroy old points
                i = oldDataLength;
                while (i--) {
                    oldData[i]?.destroy();
                }
                // Reset minRange (#878)
                if (xAxis) {
                    xAxis.minRange = xAxis.userMinRange;
                }
                // Redraw
                series.isDirty = chart.isDirtyBox = true;
                series.isDirtyData = !!oldData;
                animation = false;
            }
            // Typically for pie series, points need to be processed and
            // generated prior to rendering the legend
            if (options.legendType === 'point') {
                this.processData();
                this.generatePoints();
            }
            if (redraw) {
                chart.redraw(animation);
            }
        }
        /**
         * Internal function to sort series data
         *
         * @private
         * @function Highcharts.Series#sortData
         * @param {Array<Highcharts.PointOptionsType>} data
         * Force data grouping.
         */
        sortData(data) {
            const series = this, options = series.options, dataSorting = options.dataSorting, sortKey = dataSorting.sortKey || 'y', getPointOptionsObject = function (series, pointOptions) {
                return (defined$5(pointOptions) &&
                    series.pointClass.prototype.optionsToObject.call({
                        series: series
                    }, pointOptions)) || {};
            };
            data.forEach(function (pointOptions, i) {
                data[i] = getPointOptionsObject(series, pointOptions);
                data[i].index = i;
            }, this);
            // Sorting
            const sortedData = data.concat().sort((a, b) => {
                const aValue = getNestedProperty(sortKey, a);
                const bValue = getNestedProperty(sortKey, b);
                return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
            });
            // Set x value depending on the position in the array
            sortedData.forEach(function (point, i) {
                point.x = i;
            }, this);
            // Set the same x for linked series points if they don't have their
            // own sorting
            if (series.linkedSeries) {
                series.linkedSeries.forEach(function (linkedSeries) {
                    const options = linkedSeries.options, seriesData = options.data;
                    if ((!options.dataSorting ||
                        !options.dataSorting.enabled) &&
                        seriesData) {
                        seriesData.forEach(function (pointOptions, i) {
                            seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
                            if (data[i]) {
                                seriesData[i].x = data[i].x;
                                seriesData[i].index = i;
                            }
                        });
                        linkedSeries.setData(seriesData, false);
                    }
                });
            }
            return data;
        }
        /**
         * Internal function to process the data by cropping away unused data
         * points if the series is longer than the crop threshold. This saves
         * computing time for large series.
         *
         * @private
         * @function Highcharts.Series#getProcessedData
         * @param {boolean} [forceExtremesFromAll]
         * Force getting extremes of a total series data range.
         */
        getProcessedData(forceExtremesFromAll) {
            const series = this, xAxis = series.xAxis, options = series.options, cropThreshold = options.cropThreshold, logarithmic = xAxis?.logarithmic, isCartesian = series.isCartesian;
            let croppedData, cropped, cropStart = 0, xExtremes, min, max, 
            // Copied during slice operation:
            processedXData = series.xData, processedYData = series.yData, updatingNames = false;
            const dataLength = processedXData.length;
            if (xAxis) {
                // Corrected for log axis (#3053)
                xExtremes = xAxis.getExtremes();
                min = xExtremes.min;
                max = xExtremes.max;
                updatingNames = !!(xAxis.categories && !xAxis.names.length);
            }
            // Optionally filter out points outside the plot area
            if (isCartesian &&
                series.sorted &&
                !forceExtremesFromAll &&
                (!cropThreshold ||
                    dataLength > cropThreshold ||
                    series.forceCrop)) {
                // It's outside current extremes
                if (processedXData[dataLength - 1] < min ||
                    processedXData[0] > max) {
                    processedXData = [];
                    processedYData = [];
                    // Only crop if it's actually spilling out
                }
                else if (series.yData && (processedXData[0] < min ||
                    processedXData[dataLength - 1] > max)) {
                    croppedData = this.cropData(series.xData, series.yData, min, max);
                    processedXData = croppedData.xData;
                    processedYData = croppedData.yData;
                    cropStart = croppedData.start;
                    cropped = true;
                }
            }
            // Find the closest distance between processed points
            const closestPointRange = getClosestDistance([
                logarithmic ?
                    processedXData.map(logarithmic.log2lin) :
                    processedXData
            ], 
            // Unsorted data is not supported by the line tooltip, as well as
            // data grouping and navigation in Stock charts (#725) and width
            // calculation of columns (#1900). Avoid warning during the
            // premature processing pass in updateNames (#16104).
            () => (series.requireSorting &&
                !updatingNames &&
                error$1(15, false, series.chart)));
            return {
                xData: processedXData,
                yData: processedYData,
                cropped: cropped,
                cropStart: cropStart,
                closestPointRange: closestPointRange
            };
        }
        /**
         * Internal function to apply processed data.
         * In Highcharts Stock, this function is extended to provide data grouping.
         *
         * @private
         * @function Highcharts.Series#processData
         * @param {boolean} [force]
         * Force data grouping.
         */
        processData(force) {
            const series = this, xAxis = series.xAxis;
            // If the series data or axes haven't changed, don't go through
            // this. Return false to pass the message on to override methods
            // like in data grouping.
            if (series.isCartesian &&
                !series.isDirty &&
                !xAxis.isDirty &&
                !series.yAxis.isDirty &&
                !force) {
                return false;
            }
            const processedData = series.getProcessedData();
            // Record the properties
            series.cropped = processedData.cropped; // Undefined or true
            series.cropStart = processedData.cropStart;
            series.processedXData = processedData.xData;
            series.processedYData = processedData.yData;
            series.closestPointRange = (series.basePointRange = processedData.closestPointRange);
            fireEvent$3(series, 'afterProcessData');
        }
        /**
         * Iterate over xData and crop values between min and max. Returns
         * object containing crop start/end cropped xData with corresponding
         * part of yData, dataMin and dataMax within the cropped range.
         *
         * @private
         * @function Highcharts.Series#cropData
         */
        cropData(xData, yData, min, max) {
            const dataLength = xData.length;
            let i, j, start = 0, end = dataLength;
            // Iterate up to find slice start
            for (i = 0; i < dataLength; i++) {
                if (xData[i] >= min) {
                    start = Math.max(0, i - 1);
                    break;
                }
            }
            // Proceed to find slice end
            for (j = i; j < dataLength; j++) {
                if (xData[j] > max) {
                    end = j + 1;
                    break;
                }
            }
            return {
                xData: xData.slice(start, end),
                yData: yData.slice(start, end),
                start,
                end
            };
        }
        /**
         * Generate the data point after the data has been processed by cropping
         * away unused points and optionally grouped in Highcharts Stock.
         *
         * @private
         * @function Highcharts.Series#generatePoints
         */
        generatePoints() {
            const series = this, options = series.options, dataOptions = series.processedData || options.data, processedXData = series.processedXData, processedYData = series.processedYData, PointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys = options.keys, points = [], groupCropStartIndex = (options.dataGrouping &&
                options.dataGrouping.groupAll ?
                cropStart :
                0);
            let dataLength, cursor, point, i, data = series.data;
            if (!data && !hasGroupedData) {
                const arr = [];
                arr.length = dataOptions.length;
                data = series.data = arr;
            }
            if (keys && hasGroupedData) {
                // Grouped data has already applied keys (#6590)
                series.options.keys = false;
            }
            for (i = 0; i < processedDataLength; i++) {
                cursor = cropStart + i;
                if (!hasGroupedData) {
                    point = data[cursor];
                    // #970:
                    if (!point &&
                        typeof dataOptions[cursor] !== 'undefined') {
                        data[cursor] = point = new PointClass(series, dataOptions[cursor], processedXData[i]);
                    }
                }
                else {
                    // Splat the y data in case of ohlc data array
                    point = new PointClass(series, [processedXData[i]].concat(splat$1(processedYData[i])));
                    point.dataGroup = series.groupMap[groupCropStartIndex + i];
                    if (point.dataGroup.options) {
                        point.options = point.dataGroup.options;
                        extend$5(point, point.dataGroup.options);
                        // Collision of props and options (#9770)
                        delete point.dataLabels;
                    }
                }
                if (point) { // #6279
                    /**
                     * Contains the point's index in the `Series.points` array.
                     *
                     * @name Highcharts.Point#index
                     * @type {number}
                     * @readonly
                     */
                    // For faster access in Point.update
                    point.index = hasGroupedData ?
                        (groupCropStartIndex + i) : cursor;
                    points[i] = point;
                }
            }
            // Restore keys options (#6590)
            series.options.keys = keys;
            // Hide cropped-away points - this only runs when the number of
            // points is above cropThreshold, or when switching view from
            // non-grouped data to grouped data (#637)
            if (data &&
                (processedDataLength !== (dataLength = data.length) ||
                    hasGroupedData)) {
                for (i = 0; i < dataLength; i++) {
                    // When has grouped data, clear all points
                    if (i === cropStart && !hasGroupedData) {
                        i += processedDataLength;
                    }
                    if (data[i]) {
                        data[i].destroyElements();
                        data[i].plotX = void 0; // #1003
                    }
                }
            }
            /**
             * Read only. An array containing those values converted to points.
             * In case the series data length exceeds the `cropThreshold`, or if
             * the data is grouped, `series.data` doesn't contain all the
             * points. Also, in case a series is hidden, the `data` array may be
             * empty. In case of cropping, the `data` array may contain `undefined`
             * values, instead of points. To access raw values,
             * `series.options.data` will always be up to date. `Series.data` only
             * contains the points that have been created on demand. To modify the
             * data, use
             * {@link Highcharts.Series#setData} or
             * {@link Highcharts.Point#update}.
             *
             * @see Series.points
             *
             * @name Highcharts.Series#data
             * @type {Array<Highcharts.Point>}
             */
            series.data = data;
            /**
             * An array containing all currently visible point objects. In case
             * of cropping, the cropped-away points are not part of this array.
             * The `series.points` array starts at `series.cropStart` compared
             * to `series.data` and `series.options.data`. If however the series
             * data is grouped, these can't be correlated one to one. To modify
             * the data, use {@link Highcharts.Series#setData} or
             * {@link Highcharts.Point#update}.
             *
             * @name Highcharts.Series#points
             * @type {Array<Highcharts.Point>}
             */
            series.points = points;
            fireEvent$3(this, 'afterGeneratePoints');
        }
        /**
         * Get current X extremes for the visible data.
         *
         * @private
         * @function Highcharts.Series#getXExtremes
         * @param {Array<number>} xData
         * The data to inspect. Defaults to the current data within the visible
         * range.
         */
        getXExtremes(xData) {
            return {
                min: arrayMin(xData),
                max: arrayMax(xData)
            };
        }
        /**
         * Calculate Y extremes for the visible data. The result is returned
         * as an object with `dataMin` and `dataMax` properties.
         *
         * @private
         * @function Highcharts.Series#getExtremes
         * @param {Array<number>} [yData]
         * The data to inspect. Defaults to the current data within the visible
         * range.
         * @param {boolean} [forceExtremesFromAll]
         * Force getting extremes of a total series data range.
         */
        getExtremes(yData, forceExtremesFromAll) {
            const xAxis = this.xAxis, yAxis = this.yAxis, activeYData = [], 
            // Handle X outside the viewed area. This does not work with
            // non-sorted data like scatter (#7639).
            shoulder = this.requireSorting && !this.is('column') ?
                1 : 0, 
            // #2117, need to compensate for log X axis
            positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : false, getExtremesFromAll = forceExtremesFromAll ||
                this.getExtremesFromAll ||
                this.options.getExtremesFromAll; // #4599
            let { processedXData, processedYData } = this, xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;
            // Get the processed data from the full range (#21003)
            if (this.cropped && getExtremesFromAll) {
                const processedData = this.getProcessedData(true);
                processedXData = processedData.xData;
                processedYData = processedData.yData;
            }
            yData = yData || this.stackedYData || processedYData || [];
            const yDataLength = yData.length, xData = processedXData || this.xData;
            if (xAxis) {
                xExtremes = xAxis.getExtremes();
                xMin = xExtremes.min;
                xMax = xExtremes.max;
            }
            for (i = 0; i < yDataLength; i++) {
                x = xData[i];
                y = yData[i];
                // For points within the visible range, including the first
                // point outside the visible range (#7061), consider y extremes.
                validValue = ((isNumber$5(y) ||
                    isArray$3(y)) && ((isNumber$5(y) ? y > 0 : y.length) ||
                    !positiveValuesOnly));
                withinRange = (forceExtremesFromAll ||
                    this.getExtremesFromAll ||
                    this.options.getExtremesFromAll ||
                    this.cropped ||
                    !xAxis || // For colorAxis support
                    ((xData[i + shoulder] || x) >= xMin &&
                        (xData[i - shoulder] || x) <= xMax));
                if (validValue && withinRange) {
                    j = y.length;
                    if (j) { // Array, like ohlc or range data
                        while (j--) {
                            if (isNumber$5(y[j])) { // #7380, #11513
                                activeYData[activeCounter++] = y[j];
                            }
                        }
                    }
                    else {
                        activeYData[activeCounter++] = y;
                    }
                }
            }
            const dataExtremes = {
                activeYData, // Needed for Stock Cumulative Sum
                dataMin: arrayMin(activeYData),
                dataMax: arrayMax(activeYData)
            };
            fireEvent$3(this, 'afterGetExtremes', { dataExtremes });
            return dataExtremes;
        }
        /**
         * Set the current data extremes as `dataMin` and `dataMax` on the
         * Series item. Use this only when the series properties should be
         * updated.
         *
         * @private
         * @function Highcharts.Series#applyExtremes
         */
        applyExtremes() {
            const dataExtremes = this.getExtremes();
            /**
             * Contains the minimum value of the series' data point. Some series
             * types like `networkgraph` do not support this property as they
             * lack a `y`-value.
             * @name Highcharts.Series#dataMin
             * @type {number|undefined}
             * @readonly
             */
            this.dataMin = dataExtremes.dataMin;
            /**
             * Contains the maximum value of the series' data point. Some series
             * types like `networkgraph` do not support this property as they
             * lack a `y`-value.
             * @name Highcharts.Series#dataMax
             * @type {number|undefined}
             * @readonly
             */
            this.dataMax = dataExtremes.dataMax;
            return dataExtremes;
        }
        /**
         * Find and return the first non nullish point in the data
         *
         * @private
         * @function Highcharts.Series.getFirstValidPoint
         * @param {Array<Highcharts.PointOptionsType>} data
         *        Array of options for points
         * @param {number} [start=0]
         *        Index to start searching from
         * @param {number} [increment=1]
         *        Index increment, set -1 to search backwards
         */
        getFirstValidPoint(data, start = 0, increment = 1) {
            const dataLength = data.length;
            let i = start;
            while (i >= 0 && i < dataLength) {
                if (defined$5(data[i])) {
                    return data[i];
                }
                i += increment;
            }
        }
        /**
         * Translate data points from raw data values to chart specific
         * positioning data needed later in the `drawPoints` and `drawGraph`
         * functions. This function can be overridden in plugins and custom
         * series type implementations.
         *
         * @function Highcharts.Series#translate
         *
         * @emits Highcharts.Series#events:translate
         */
        translate() {
            if (!this.processedXData) { // Hidden series
                this.processData();
            }
            this.generatePoints();
            const series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, enabledDataSorting = series.enabledDataSorting, yAxis = series.yAxis, points = series.points, dataLength = points.length, pointPlacement = series.pointPlacementToXValue(), // #7860
            dynamicallyPlaced = Boolean(pointPlacement), threshold = options.threshold, stackThreshold = options.startFromThreshold ? threshold : 0;
            let i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
            /**
             * Plotted coordinates need to be within a limited range. Drawing
             * too far outside the viewport causes various rendering issues
             * (#3201, #3923, #7555).
             * @private
             */
            function limitedRange(val) {
                return clamp$1(val, -1e9, 1e9);
            }
            // Translate each point
            for (i = 0; i < dataLength; i++) {
                const point = points[i], xValue = point.x;
                let stackItem, stackValues, yValue = point.y, lowValue = point.low;
                const stacks = stacking && yAxis.stacking?.stacks[(series.negStacks &&
                    yValue <
                        (stackThreshold ? 0 : threshold) ?
                    '-' :
                    '') + series.stackKey];
                plotX = xAxis.translate(// #3923
                xValue, false, false, false, true, pointPlacement);
                /**
                 * The translated X value for the point in terms of pixels. Relative
                 * to the X axis position if the series has one, otherwise relative
                 * to the plot area. Depending on the series type this value might
                 * not be defined.
                 *
                 * In an inverted chart the x-axis is going from the bottom to the
                 * top so the `plotX` value is the number of pixels from the bottom
                 * of the axis.
                 *
                 * @see Highcharts.Point#pos
                 * @name Highcharts.Point#plotX
                 * @type {number|undefined}
                 */
                point.plotX = isNumber$5(plotX) ? correctFloat(// #5236
                limitedRange(plotX) // #3923
                ) : void 0;
                // Calculate the bottom y value for stacked series
                if (stacking &&
                    series.visible &&
                    stacks &&
                    stacks[xValue]) {
                    stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
                    if (!point.isNull && stackIndicator.key) {
                        stackItem = stacks[xValue];
                        stackValues = stackItem.points[stackIndicator.key];
                    }
                    if (stackItem && isArray$3(stackValues)) {
                        lowValue = stackValues[0];
                        yValue = stackValues[1];
                        if (lowValue === stackThreshold &&
                            stackIndicator.key === stacks[xValue].base) {
                            lowValue = pick$6(isNumber$5(threshold) ? threshold : yAxis.min);
                        }
                        // #1200, #1232
                        if (yAxis.positiveValuesOnly &&
                            defined$5(lowValue) &&
                            lowValue <= 0) {
                            lowValue = void 0;
                        }
                        point.total = point.stackTotal = pick$6(stackItem.total);
                        point.percentage = defined$5(point.y) && stackItem.total ?
                            (point.y / stackItem.total * 100) : void 0;
                        point.stackY = yValue;
                        // In case of variwide series (where widths of points are
                        // different in most cases), stack labels are positioned
                        // wrongly, so the call of the setOffset is omitted here and
                        // labels are correctly positioned later, at the end of the
                        // variwide's translate function (#10962)
                        if (!series.irregularWidths) {
                            stackItem.setOffset(series.pointXOffset || 0, series.barW || 0, void 0, void 0, void 0, series.xAxis);
                        }
                    }
                }
                // Set translated yBottom or remove it
                point.yBottom = defined$5(lowValue) ?
                    limitedRange(yAxis.translate(lowValue, false, true, false, true)) :
                    void 0;
                // General hook, used for Highcharts Stock compare and cumulative
                if (series.dataModify) {
                    yValue = series.dataModify.modifyValue(yValue, i);
                }
                // Set the plotY value, reset it for redraws #3201, #18422
                let plotY;
                if (isNumber$5(yValue) && point.plotX !== void 0) {
                    plotY = yAxis.translate(yValue, false, true, false, true);
                    plotY = isNumber$5(plotY) ? limitedRange(plotY) : void 0;
                }
                /**
                 * The translated Y value for the point in terms of pixels. Relative
                 * to the Y axis position if the series has one, otherwise relative
                 * to the plot area. Depending on the series type this value might
                 * not be defined.
                 *
                 * In an inverted chart the y-axis is going from right to left
                 * so the `plotY` value is the number of pixels from the right
                 * of the `yAxis`.
                 *
                 * @see Highcharts.Point#pos
                 * @name Highcharts.Point#plotY
                 * @type {number|undefined}
                 */
                point.plotY = plotY;
                point.isInside = this.isPointInside(point);
                // Set client related positions for mouse tracking
                point.clientX = dynamicallyPlaced ?
                    correctFloat(xAxis.translate(xValue, false, false, false, true, pointPlacement)) :
                    plotX; // #1514, #5383, #5518
                // Negative points #19028
                point.negative = (point.y || 0) < (threshold || 0);
                // Some API data
                point.category = pick$6(categories && categories[point.x], point.x);
                // Determine auto enabling of markers (#3635, #5099)
                if (!point.isNull && point.visible !== false) {
                    if (typeof lastPlotX !== 'undefined') {
                        closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
                    }
                    lastPlotX = plotX;
                }
                // Find point zone
                point.zone = this.zones.length ? point.getZone() : void 0;
                // Animate new points with data sorting
                if (!point.graphic && series.group && enabledDataSorting) {
                    point.isNew = true;
                }
            }
            series.closestPointRangePx = closestPointRangePx;
            fireEvent$3(this, 'afterTranslate');
        }
        /**
         * Return the series points with null points filtered out.
         *
         * @function Highcharts.Series#getValidPoints
         *
         * @param {Array<Highcharts.Point>} [points]
         * The points to inspect, defaults to {@link Series.points}.
         *
         * @param {boolean} [insideOnly=false]
         * Whether to inspect only the points that are inside the visible view.
         *
         * @param {boolean} [allowNull=false]
         * Whether to allow null points to pass as valid points.
         *
         * @return {Array<Highcharts.Point>}
         * The valid points.
         */
        getValidPoints(points, insideOnly, allowNull) {
            const chart = this.chart;
            // #3916, #5029, #5085
            return (points || this.points || []).filter(function (point) {
                const { plotX, plotY } = point, 
                // Undefined plotY is treated as null when negative values
                // in log axis (#18422)
                asNull = !allowNull && (point.isNull || !isNumber$5(plotY));
                if (asNull || (insideOnly && !chart.isInsidePlot(plotX, plotY, { inverted: chart.inverted }))) {
                    return false;
                }
                return point.visible !== false;
            });
        }
        /**
         * Get the clipping for the series. Could be called for a series to
         * initiate animating the clip or to set the final clip (only width
         * and x).
         *
         * @private
         * @function Highcharts.Series#getClip
         */
        getClipBox() {
            const { chart, xAxis, yAxis } = this;
            // If no axes on the series, use global clipBox
            let { x, y, width, height } = merge$4(chart.clipBox);
            // Otherwise, use clipBox.width which is corrected for plotBorderWidth
            // and clipOffset
            if (xAxis && xAxis.len !== chart.plotSizeX) {
                width = xAxis.len;
            }
            if (yAxis && yAxis.len !== chart.plotSizeY) {
                height = yAxis.len;
            }
            // If the chart is inverted and the series is not invertible, the chart
            // clip box should be inverted, but not the series clip box (#20264)
            if (chart.inverted && !this.invertible) {
                [width, height] = [height, width];
            }
            return { x, y, width, height };
        }
        /**
         * Get the shared clip key, creating it if it doesn't exist.
         *
         * @private
         * @function Highcharts.Series#getSharedClipKey
         */
        getSharedClipKey() {
            this.sharedClipKey = (this.options.xAxis || 0) + ',' +
                (this.options.yAxis || 0);
            return this.sharedClipKey;
        }
        /**
         * Set the clipping for the series. For animated series the clip is later
         * modified.
         *
         * @private
         * @function Highcharts.Series#setClip
         */
        setClip() {
            const { chart, group, markerGroup } = this, sharedClips = chart.sharedClips, renderer = chart.renderer, clipBox = this.getClipBox(), sharedClipKey = this.getSharedClipKey(); // #4526
            let clipRect = sharedClips[sharedClipKey];
            // If a clipping rectangle for the same set of axes does not exist,
            // create it
            if (!clipRect) {
                sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
                // When setting chart size, or when the series is rendered again before
                // starting animating, in compliance to a responsive rule
            }
            else {
                clipRect.animate(clipBox);
            }
            if (group) {
                // When clip is false, reset to no clip after animation
                group.clip(this.options.clip === false ? void 0 : clipRect);
            }
            // Unclip temporary animation clip
            if (markerGroup) {
                markerGroup.clip();
            }
        }
        /**
         * Animate in the series. Called internally twice. First with the `init`
         * parameter set to true, which sets up the initial state of the
         * animation. Then when ready, it is called with the `init` parameter
         * undefined, in order to perform the actual animation.
         *
         * @function Highcharts.Series#animate
         *
         * @param {boolean} [init]
         * Initialize the animation.
         */
        animate(init) {
            const { chart, group, markerGroup } = this, inverted = chart.inverted, animation = animObject$2(this.options.animation), 
            // The key for temporary animation clips
            animationClipKey = [
                this.getSharedClipKey(),
                animation.duration,
                animation.easing,
                animation.defer
            ].join(',');
            let animationClipRect = chart.sharedClips[animationClipKey], markerAnimationClipRect = chart.sharedClips[animationClipKey + 'm'];
            // Initialize the animation. Set up the clipping rectangle.
            if (init && group) {
                const clipBox = this.getClipBox();
                // Create temporary animation clips
                if (!animationClipRect) {
                    clipBox.width = 0;
                    if (inverted) {
                        clipBox.x = chart.plotHeight;
                    }
                    animationClipRect = chart.renderer.clipRect(clipBox);
                    chart.sharedClips[animationClipKey] = animationClipRect;
                    // The marker clip box. The number 99 is a safe margin to avoid
                    // markers being clipped during animation.
                    const markerClipBox = {
                        x: inverted ? -99 : -99,
                        y: inverted ? -99 : -99,
                        width: inverted ? chart.plotWidth + 199 : 99,
                        height: inverted ? 99 : chart.plotHeight + 199
                    };
                    markerAnimationClipRect = chart.renderer.clipRect(markerClipBox);
                    chart.sharedClips[animationClipKey + 'm'] = markerAnimationClipRect;
                }
                else {
                    // When height changes during animation, typically due to
                    // responsive settings
                    animationClipRect.attr('height', clipBox.height);
                }
                group.clip(animationClipRect);
                markerGroup?.clip(markerAnimationClipRect);
                // Run the animation
            }
            else if (animationClipRect &&
                // Only first series in this pane
                !animationClipRect.hasClass('highcharts-animating')) {
                const finalBox = this.getClipBox(), step = animation.step;
                // Only do this when there are actually markers, or we have multiple
                // series (#20473)
                if (markerGroup?.element.childNodes.length ||
                    chart.series.length > 1) {
                    // To provide as smooth animation as possible, update the marker
                    // group clipping in steps of the main group animation
                    animation.step = function (val, fx) {
                        if (step) {
                            step.apply(fx, arguments);
                        }
                        if (fx.prop === 'width' &&
                            markerAnimationClipRect?.element) {
                            markerAnimationClipRect.attr(inverted ? 'height' : 'width', val + 99);
                        }
                    };
                }
                animationClipRect
                    .addClass('highcharts-animating')
                    .animate(finalBox, animation);
            }
        }
        /**
         * This runs after animation to land on the final plot clipping.
         *
         * @private
         * @function Highcharts.Series#afterAnimate
         *
         * @emits Highcharts.Series#event:afterAnimate
         */
        afterAnimate() {
            this.setClip();
            // Destroy temporary clip rectangles that are no longer in use
            objectEach$3(this.chart.sharedClips, (clip, key, sharedClips) => {
                if (clip && !this.chart.container.querySelector(`[clip-path="url(#${clip.id})"]`)) {
                    clip.destroy();
                    delete sharedClips[key];
                }
            });
            this.finishedAnimating = true;
            fireEvent$3(this, 'afterAnimate');
        }
        /**
         * Draw the markers for line-like series types, and columns or other
         * graphical representation for {@link Point} objects for other series
         * types. The resulting element is typically stored as
         * {@link Point.graphic}, and is created on the first call and updated
         * and moved on subsequent calls.
         *
         * @function Highcharts.Series#drawPoints
         */
        drawPoints(points = this.points) {
            const series = this, chart = series.chart, styledMode = chart.styledMode, { colorAxis, options } = series, seriesMarkerOptions = options.marker, markerGroup = series[series.specialGroup || 'markerGroup'], xAxis = series.xAxis, globallyEnabled = pick$6(seriesMarkerOptions.enabled, !xAxis || xAxis.isRadial ? true : null, 
            // Use larger or equal as radius is null in bubbles (#6321)
            series.closestPointRangePx >= (seriesMarkerOptions.enabledThreshold *
                seriesMarkerOptions.radius));
            let i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
            if (seriesMarkerOptions.enabled !== false ||
                series._hasPointMarkers) {
                for (i = 0; i < points.length; i++) {
                    point = points[i];
                    graphic = point.graphic;
                    verb = graphic ? 'animate' : 'attr';
                    pointMarkerOptions = point.marker || {};
                    hasPointMarker = !!point.marker;
                    const shouldDrawMarker = ((globallyEnabled &&
                        typeof pointMarkerOptions.enabled === 'undefined') || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;
                    // Only draw the point if y is defined
                    if (shouldDrawMarker) {
                        // Shortcuts
                        const symbol = pick$6(pointMarkerOptions.symbol, series.symbol, 'rect');
                        markerAttribs = series.markerAttribs(point, (point.selected && 'select'));
                        // Set starting position for point sliding animation.
                        if (series.enabledDataSorting) {
                            point.startXPos = xAxis.reversed ?
                                -(markerAttribs.width || 0) :
                                xAxis.width;
                        }
                        const isInside = point.isInside !== false;
                        if (!graphic &&
                            isInside &&
                            ((markerAttribs.width || 0) > 0 || point.hasImage)) {
                            /**
                             * SVG graphic representing the point in the chart. In
                             * some cases it may be a hidden graphic to improve
                             * accessibility.
                             *
                             * Typically this is a simple shape, like a `rect`
                             * for column charts or `path` for line markers, but
                             * for some complex series types like boxplot or 3D
                             * charts, the graphic may be a `g` element
                             * containing other shapes. The graphic is generated
                             * the first time {@link Series#drawPoints} runs,
                             * and updated and moved on subsequent runs.
                             *
                             * @see Highcharts.Point#graphics
                             *
                             * @name Highcharts.Point#graphic
                             * @type {Highcharts.SVGElement|undefined}
                             */
                            point.graphic = graphic = chart.renderer
                                .symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ?
                                pointMarkerOptions :
                                seriesMarkerOptions)
                                .add(markerGroup);
                            // Sliding animation for new points
                            if (series.enabledDataSorting &&
                                chart.hasRendered) {
                                graphic.attr({
                                    x: point.startXPos
                                });
                                verb = 'animate';
                            }
                        }
                        if (graphic && verb === 'animate') { // Update
                            // Since the marker group isn't clipped, each
                            // individual marker must be toggled
                            graphic[isInside ? 'show' : 'hide'](isInside)
                                .animate(markerAttribs);
                        }
                        // Presentational attributes
                        if (graphic) {
                            const pointAttr = series.pointAttribs(point, ((styledMode || !point.selected) ?
                                void 0 :
                                'select'));
                            if (!styledMode) {
                                graphic[verb](pointAttr);
                            }
                            else if (colorAxis) { // #14114
                                graphic['css']({
                                    fill: pointAttr.fill
                                });
                            }
                        }
                        if (graphic) {
                            graphic.addClass(point.getClassName(), true);
                        }
                    }
                    else if (graphic) {
                        point.graphic = graphic.destroy(); // #1269
                    }
                }
            }
        }
        /**
         * Get non-presentational attributes for a point. Used internally for
         * both styled mode and classic. Can be overridden for different series
         * types.
         *
         * @see Series#pointAttribs
         *
         * @function Highcharts.Series#markerAttribs
         *
         * @param {Highcharts.Point} point
         * The Point to inspect.
         *
         * @param {string} [state]
         * The state, can be either `hover`, `select` or undefined.
         *
         * @return {Highcharts.SVGAttributes}
         * A hash containing those attributes that are not settable from CSS.
         */
        markerAttribs(point, state) {
            const seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = (pointMarkerOptions.symbol ||
                seriesMarkerOptions.symbol), attribs = {};
            let seriesStateOptions, pointStateOptions, radius = pick$6(pointMarkerOptions.radius, seriesMarkerOptions && seriesMarkerOptions.radius);
            // Handle hover and select states
            if (state) {
                seriesStateOptions = seriesMarkerOptions.states[state];
                pointStateOptions = pointMarkerOptions.states &&
                    pointMarkerOptions.states[state];
                radius = pick$6(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius && radius + (seriesStateOptions && seriesStateOptions.radiusPlus ||
                    0));
            }
            point.hasImage = symbol && symbol.indexOf('url') === 0;
            if (point.hasImage) {
                radius = 0; // And subsequently width and height is not set
            }
            const pos = point.pos();
            if (isNumber$5(radius) && pos) {
                if (seriesOptions.crisp) {
                    pos[0] = crisp$2(pos[0], point.hasImage ?
                        0 :
                        symbol === 'rect' ?
                            // Rectangle symbols need crisp edges, others don't
                            seriesMarkerOptions?.lineWidth || 0 :
                            1);
                }
                attribs.x = pos[0] - radius;
                attribs.y = pos[1] - radius;
            }
            if (radius) {
                attribs.width = attribs.height = 2 * radius;
            }
            return attribs;
        }
        /**
         * Internal function to get presentational attributes for each point.
         * Unlike {@link Series#markerAttribs}, this function should return
         * those attributes that can also be set in CSS. In styled mode,
         * `pointAttribs` won't be called.
         *
         * @private
         * @function Highcharts.Series#pointAttribs
         *
         * @param {Highcharts.Point} [point]
         * The point instance to inspect.
         *
         * @param {string} [state]
         * The point state, can be either `hover`, `select` or 'normal'. If
         * undefined, normal state is assumed.
         *
         * @return {Highcharts.SVGAttributes}
         * The presentational attributes to be set on the point.
         */
        pointAttribs(point, state) {
            const seriesMarkerOptions = this.options.marker, pointOptions = point && point.options, pointMarkerOptions = ((pointOptions && pointOptions.marker) || {}), pointColorOption = pointOptions && pointOptions.color, pointColor = point && point.color, zoneColor = point && point.zone && point.zone.color;
            let seriesStateOptions, pointStateOptions, color = this.color, fill, stroke, strokeWidth = pick$6(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = 1;
            color = (pointColorOption ||
                zoneColor ||
                pointColor ||
                color);
            fill = (pointMarkerOptions.fillColor ||
                seriesMarkerOptions.fillColor ||
                color);
            stroke = (pointMarkerOptions.lineColor ||
                seriesMarkerOptions.lineColor ||
                color);
            // Handle hover and select states
            state = state || 'normal';
            if (state) {
                seriesStateOptions = (seriesMarkerOptions.states[state] || {});
                pointStateOptions = (pointMarkerOptions.states &&
                    pointMarkerOptions.states[state]) || {};
                strokeWidth = pick$6(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick$6(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
                fill = (pointStateOptions.fillColor ||
                    seriesStateOptions.fillColor ||
                    fill);
                stroke = (pointStateOptions.lineColor ||
                    seriesStateOptions.lineColor ||
                    stroke);
                opacity = pick$6(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);
            }
            return {
                'stroke': stroke,
                'stroke-width': strokeWidth,
                'fill': fill,
                'opacity': opacity
            };
        }
        /**
         * Clear DOM objects and free up memory.
         *
         * @private
         * @function Highcharts.Series#destroy
         *
         * @emits Highcharts.Series#event:destroy
         */
        destroy(keepEventsForUpdate) {
            const series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(win$3.navigator.userAgent), data = series.data || [];
            let destroy, i, point, axis;
            // Add event hook
            fireEvent$3(series, 'destroy', { keepEventsForUpdate });
            // Remove events
            this.removeEvents(keepEventsForUpdate);
            // Erase from axes
            (series.axisTypes || []).forEach(function (AXIS) {
                axis = series[AXIS];
                if (axis && axis.series) {
                    erase$1(axis.series, series);
                    axis.isDirty = axis.forceRedraw = true;
                }
            });
            // Remove legend items
            if (series.legendItem) {
                series.chart.legend.destroyItem(series);
            }
            // Destroy all points with their elements
            i = data.length;
            while (i--) {
                point = data[i];
                if (point && point.destroy) {
                    point.destroy();
                }
            }
            for (const zone of series.zones) {
                // Destroy SVGElement's but preserve primitive props (#20426)
                destroyObjectProperties$1(zone, void 0, true);
            }
            // Clear the animation timeout if we are destroying the series
            // during initial animation
            Utilities.clearTimeout(series.animationTimeout);
            // Destroy all SVGElements associated to the series
            objectEach$3(series, function (val, prop) {
                // Survive provides a hook for not destroying
                if (val instanceof SVGElement && !val.survive) {
                    // Issue 134 workaround
                    destroy = issue134 && prop === 'group' ?
                        'hide' :
                        'destroy';
                    val[destroy]();
                }
            });
            // Remove from hoverSeries
            if (chart.hoverSeries === series) {
                chart.hoverSeries = void 0;
            }
            erase$1(chart.series, series);
            chart.orderItems('series');
            // Clear all members
            objectEach$3(series, function (val, prop) {
                if (!keepEventsForUpdate || prop !== 'hcEvents') {
                    delete series[prop];
                }
            });
        }
        /**
         * Clip the graphs into zones for colors and styling.
         *
         * @private
         * @function Highcharts.Series#applyZones
         */
        applyZones() {
            const series = this, { area, chart, graph, zones, points, xAxis, yAxis, zoneAxis } = series, { inverted, renderer } = chart, axis = this[`${zoneAxis}Axis`], { isXAxis, len = 0 } = axis || {}, halfWidth = (graph?.strokeWidth() || 0) / 2 + 1, 
            // Avoid points that are so close to the threshold that the graph
            // line would be split
            avoidClose = (zone, plotX = 0, plotY = 0) => {
                if (inverted) {
                    plotY = len - plotY;
                }
                const { translated = 0, lineClip } = zone, distance = plotY - translated;
                lineClip?.push([
                    'L',
                    plotX,
                    Math.abs(distance) < halfWidth ?
                        plotY - halfWidth * (distance <= 0 ? -1 : 1) :
                        translated
                ]);
            };
            if (zones.length &&
                (graph || area) &&
                axis &&
                isNumber$5(axis.min)) {
                const axisMax = axis.getExtremes().max, 
                // Invert the x and y coordinates of inverted charts
                invertPath = (path) => {
                    path.forEach((segment, i) => {
                        if (segment[0] === 'M' || segment[0] === 'L') {
                            path[i] = [
                                segment[0],
                                isXAxis ? len - segment[1] : segment[1],
                                isXAxis ? segment[2] : len - segment[2]
                            ];
                        }
                    });
                };
                // Reset
                zones.forEach((zone) => {
                    zone.lineClip = [];
                    zone.translated = clamp$1(axis.toPixels(pick$6(zone.value, axisMax), true) || 0, 0, len);
                });
                // The use of the Color Threshold assumes there are no gaps so it is
                // safe to hide the original graph and area unless it is not
                // waterfall series, then use showLine property to set lines between
                // columns to be visible (#7862)
                if (graph && !this.showLine) {
                    graph.hide();
                }
                if (area) {
                    area.hide();
                }
                // Prepare for adaptive clips, avoiding segments close to the
                // threshold (#19709)
                if (zoneAxis === 'y' &&
                    // Overheat protection
                    points.length < xAxis.len) {
                    for (const point of points) {
                        const { plotX, plotY, zone } = point, zoneBelow = zone && zones[zones.indexOf(zone) - 1];
                        // Close to upper boundary
                        if (zone) {
                            avoidClose(zone, plotX, plotY);
                        }
                        // Close to lower boundary
                        if (zoneBelow) {
                            avoidClose(zoneBelow, plotX, plotY);
                        }
                    }
                }
                // Compute and apply the clips
                let lastLineClip = [], lastTranslated = axis.toPixels(axis.getExtremes().min, true);
                zones.forEach((zone) => {
                    const lineClip = zone.lineClip || [], translated = Math.round(zone.translated || 0);
                    if (xAxis.reversed) {
                        lineClip.reverse();
                    }
                    let { clip, simpleClip } = zone, x1 = 0, y1 = 0, x2 = xAxis.len, y2 = yAxis.len;
                    if (isXAxis) {
                        x1 = translated;
                        x2 = lastTranslated;
                    }
                    else {
                        y1 = translated;
                        y2 = lastTranslated;
                    }
                    // Adaptive clips
                    const simplePath = [
                        ['M', x1, y1],
                        ['L', x2, y1],
                        ['L', x2, y2],
                        ['L', x1, y2],
                        ['Z']
                    ], adaptivePath = [
                        simplePath[0],
                        ...lineClip,
                        simplePath[1],
                        simplePath[2],
                        ...lastLineClip,
                        simplePath[3],
                        simplePath[4]
                    ];
                    lastLineClip = lineClip.reverse();
                    lastTranslated = translated;
                    if (inverted) {
                        invertPath(adaptivePath);
                        if (area) {
                            invertPath(simplePath);
                        }
                    }
                    /* Debug clip paths
                    chart.renderer.path(adaptivePath)
                        .attr({
                            stroke: zone.color || this.color || 'gray',
                            'stroke-width': 1,
                            'dashstyle': 'Dash'
                        })
                        .add(series.group);
                    // */
                    if (clip) {
                        clip.animate({ d: adaptivePath });
                        simpleClip?.animate({ d: simplePath });
                    }
                    else {
                        clip = zone.clip = renderer.path(adaptivePath);
                        if (area) {
                            simpleClip = zone.simpleClip = renderer.path(simplePath);
                        }
                    }
                    // When no data, graph zone is not applied and after setData
                    // clip was ignored. As a result, it should be applied each
                    // time.
                    if (graph) {
                        zone.graph?.clip(clip);
                    }
                    if (area) {
                        zone.area?.clip(simpleClip);
                    }
                });
            }
            else if (series.visible) {
                // If zones were removed, restore graph and area
                if (graph) {
                    graph.show();
                }
                if (area) {
                    area.show();
                }
            }
        }
        /**
         * General abstraction for creating plot groups like series.group,
         * series.dataLabelsGroup and series.markerGroup. On subsequent calls,
         * the group will only be adjusted to the updated plot size.
         *
         * @private
         * @function Highcharts.Series#plotGroup
         */
        plotGroup(prop, name, visibility, zIndex, parent) {
            let group = this[prop];
            const isNew = !group, attrs = {
                visibility,
                zIndex: zIndex || 0.1 // Pointer logic uses this
            };
            // Avoid setting undefined opacity, or in styled mode
            if (defined$5(this.opacity) &&
                !this.chart.styledMode && this.state !== 'inactive' // #13719
            ) {
                attrs.opacity = this.opacity;
            }
            // Generate it on first call
            if (!group) {
                this[prop] = group = this.chart.renderer
                    .g()
                    .add(parent);
            }
            // Add the class names, and replace existing ones as response to
            // Series.update (#6660)
            group.addClass(('highcharts-' + name +
                ' highcharts-series-' + this.index +
                ' highcharts-' + this.type + '-series ' +
                (defined$5(this.colorIndex) ?
                    'highcharts-color-' + this.colorIndex + ' ' :
                    '') +
                (this.options.className || '') +
                (group.hasClass('highcharts-tracker') ?
                    ' highcharts-tracker' :
                    '')), true);
            // Place it on first and subsequent (redraw) calls
            group.attr(attrs)[isNew ? 'attr' : 'animate'](this.getPlotBox(name));
            return group;
        }
        /**
         * Get the translation and scale for the plot area of this series.
         *
         * @function Highcharts.Series#getPlotBox
         */
        getPlotBox(name) {
            let horAxis = this.xAxis, vertAxis = this.yAxis;
            const chart = this.chart, inverted = (chart.inverted &&
                !chart.polar &&
                horAxis &&
                this.invertible &&
                name === 'series');
            // Swap axes for inverted (#2339)
            if (chart.inverted) {
                horAxis = vertAxis;
                vertAxis = this.xAxis;
            }
            return {
                translateX: horAxis ? horAxis.left : chart.plotLeft,
                translateY: vertAxis ? vertAxis.top : chart.plotTop,
                rotation: inverted ? 90 : 0,
                rotationOriginX: inverted ?
                    (horAxis.len - vertAxis.len) / 2 :
                    0,
                rotationOriginY: inverted ?
                    (horAxis.len + vertAxis.len) / 2 :
                    0,
                scaleX: inverted ? -1 : 1, // #1623
                scaleY: 1
            };
        }
        /**
         * Removes the event handlers attached previously with addEvents.
         * @private
         * @function Highcharts.Series#removeEvents
         */
        removeEvents(keepEventsForUpdate) {
            const { eventsToUnbind } = this;
            if (!keepEventsForUpdate) {
                // Remove all events
                removeEvent$2(this);
            }
            if (eventsToUnbind.length) {
                // Remove only internal events for proper update. #12355 solves
                // problem with multiple destroy events
                eventsToUnbind.forEach((unbind) => {
                    unbind();
                });
                eventsToUnbind.length = 0;
            }
        }
        /**
         * Render the graph and markers. Called internally when first rendering
         * and later when redrawing the chart. This function can be extended in
         * plugins, but normally shouldn't be called directly.
         *
         * @function Highcharts.Series#render
         *
         * @emits Highcharts.Series#event:afterRender
         */
        render() {
            const series = this, { chart, options, hasRendered } = series, animOptions = animObject$2(options.animation), visibility = series.visible ?
                'inherit' : 'hidden', // #2597
            zIndex = options.zIndex, chartSeriesGroup = chart.seriesGroup;
            let animDuration = series.finishedAnimating ?
                0 : animOptions.duration;
            fireEvent$3(this, 'render');
            // The group
            series.plotGroup('group', 'series', visibility, zIndex, chartSeriesGroup);
            series.markerGroup = series.plotGroup('markerGroup', 'markers', visibility, zIndex, chartSeriesGroup);
            // Initial clipping, applies to columns etc. (#3839).
            if (options.clip !== false) {
                series.setClip();
            }
            // Initialize the animation
            if (animDuration) {
                series.animate?.(true);
            }
            // Draw the graph if any
            if (series.drawGraph) {
                series.drawGraph();
                series.applyZones();
            }
            // Draw the points
            if (series.visible) {
                series.drawPoints();
            }
            // Draw the data labels
            series.drawDataLabels?.();
            // In pie charts, slices are added to the DOM, but actual rendering
            // is postponed until labels reserved their space
            series.redrawPoints?.();
            // Draw the mouse tracking area
            if (options.enableMouseTracking) {
                series.drawTracker?.();
            }
            // Run the animation
            if (animDuration) {
                series.animate?.();
            }
            // Call the afterAnimate function on animation complete (but don't
            // overwrite the animation.complete option which should be available
            // to the user).
            if (!hasRendered) {
                // Additional time if defer is defined before afterAnimate
                // will be triggered
                if (animDuration && animOptions.defer) {
                    animDuration += animOptions.defer;
                }
                series.animationTimeout = syncTimeout$1(() => {
                    series.afterAnimate();
                }, animDuration || 0);
            }
            // Means data is in accordance with what you see
            series.isDirty = false;
            // (See #322) series.isDirty = series.isDirtyData = false; // means
            // data is in accordance with what you see
            series.hasRendered = true;
            fireEvent$3(series, 'afterRender');
        }
        /**
         * Redraw the series. This function is called internally from
         * `chart.redraw` and normally shouldn't be called directly.
         * @private
         * @function Highcharts.Series#redraw
         */
        redraw() {
            // Cache it here as it is set to false in render, but used after
            const wasDirty = this.isDirty || this.isDirtyData;
            this.translate();
            this.render();
            if (wasDirty) { // #3868, #3945
                delete this.kdTree;
            }
        }
        /**
         * Whether to reserve space for the series, either because it is visible or
         * because the `chart.ignoreHiddenSeries` option is false.
         *
         * @private
         */
        reserveSpace() {
            return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
        }
        /**
         * Find the nearest point from a pointer event. This applies to series that
         * use k-d-trees to get the nearest point. Native pointer events must be
         * normalized using `Pointer.normalize`, that adds `chartX` and `chartY`
         * properties.
         *
         * @sample highcharts/demo/synchronized-charts
         *         Synchronized charts with tooltips
         *
         * @function Highcharts.Series#searchPoint
         *
         * @param {Highcharts.PointerEvent} e
         *        The normalized pointer event
         * @param {boolean} [compareX=false]
         *        Search only by the X value, not Y
         *
         * @return {Point|undefined}
         *        The closest point to the pointer event
         */
        searchPoint(e, compareX) {
            const { xAxis, yAxis } = this, inverted = this.chart.inverted;
            return this.searchKDTree({
                clientX: inverted ?
                    xAxis.len - e.chartY + xAxis.pos :
                    e.chartX - xAxis.pos,
                plotY: inverted ?
                    yAxis.len - e.chartX + yAxis.pos :
                    e.chartY - yAxis.pos
            }, compareX, e);
        }
        /**
         * Build the k-d-tree that is used by mouse and touch interaction to get
         * the closest point. Line-like series typically have a one-dimensional
         * tree where points are searched along the X axis, while scatter-like
         * series typically search in two dimensions, X and Y.
         *
         * @private
         * @function Highcharts.Series#buildKDTree
         */
        buildKDTree(e) {
            // Prevent multiple k-d-trees from being built simultaneously
            // (#6235)
            this.buildingKdTree = true;
            const series = this, dimensions = series.options.findNearestPointBy
                .indexOf('y') > -1 ? 2 : 1;
            /**
             * Internal function
             * @private
             */
            function kdtree(points, depth, dimensions) {
                const length = points?.length;
                let axis, median;
                if (length) {
                    // Alternate between the axis
                    axis = series.kdAxisArray[depth % dimensions];
                    // Sort point array
                    points.sort((a, b) => (a[axis] || 0) - (b[axis] || 0));
                    median = Math.floor(length / 2);
                    // Build and return node
                    return {
                        point: points[median],
                        left: kdtree(points.slice(0, median), depth + 1, dimensions),
                        right: kdtree(points.slice(median + 1), depth + 1, dimensions)
                    };
                }
            }
            /**
             * Start the recursive build process with a clone of the points
             * array and null points filtered out. (#3873)
             * @private
             */
            function startRecursive() {
                series.kdTree = kdtree(series.getValidPoints(void 0, 
                // For line-type series restrict to plot area, but
                // column-type series not (#3916, #4511)
                !series.directTouch), dimensions, dimensions);
                series.buildingKdTree = false;
            }
            delete series.kdTree;
            // For testing tooltips, don't build async. Also if touchstart, we may
            // be dealing with click events on mobile, so don't delay (#6817).
            syncTimeout$1(startRecursive, series.options.kdNow || e?.type === 'touchstart' ? 0 : 1);
        }
        /**
         * @private
         * @function Highcharts.Series#searchKDTree
         */
        searchKDTree(point, compareX, e) {
            const series = this, [kdX, kdY] = this.kdAxisArray, kdComparer = compareX ? 'distX' : 'dist', kdDimensions = (series.options.findNearestPointBy || '')
                .indexOf('y') > -1 ? 2 : 1, useRadius = !!series.isBubble;
            /**
             * Set the one and two dimensional distance on the point object.
             * @private
             */
            function setDistance(p1, p2) {
                const p1kdX = p1[kdX], p2kdX = p2[kdX], x = (defined$5(p1kdX) && defined$5(p2kdX)) ? p1kdX - p2kdX : null, p1kdY = p1[kdY], p2kdY = p2[kdY], y = (defined$5(p1kdY) && defined$5(p2kdY)) ? p1kdY - p2kdY : 0, radius = useRadius ? (p2.marker?.radius || 0) : 0;
                p2.dist = Math.sqrt(((x && x * x) || 0) + y * y) - radius;
                p2.distX = defined$5(x) ? (Math.abs(x) - radius) : Number.MAX_VALUE;
            }
            /**
             * @private
             */
            function doSearch(search, tree, depth, dimensions) {
                const point = tree.point, axis = series.kdAxisArray[depth % dimensions];
                let nPoint1, nPoint2, ret = point;
                setDistance(search, point);
                // Pick side based on distance to splitting point
                const tdist = (search[axis] || 0) - (point[axis] || 0) +
                    (useRadius ? (point.marker?.radius || 0) : 0), sideA = tdist < 0 ? 'left' : 'right', sideB = tdist < 0 ? 'right' : 'left';
                // End of tree
                if (tree[sideA]) {
                    nPoint1 = doSearch(search, tree[sideA], depth + 1, dimensions);
                    ret = (nPoint1[kdComparer] <
                        ret[kdComparer] ?
                        nPoint1 :
                        point);
                }
                if (tree[sideB]) {
                    // Compare distance to current best to splitting point to decide
                    // whether to check side B or not
                    if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
                        nPoint2 = doSearch(search, tree[sideB], depth + 1, dimensions);
                        ret = (nPoint2[kdComparer] <
                            ret[kdComparer] ?
                            nPoint2 :
                            ret);
                    }
                }
                return ret;
            }
            if (!this.kdTree && !this.buildingKdTree) {
                this.buildKDTree(e);
            }
            if (this.kdTree) {
                return doSearch(point, this.kdTree, kdDimensions, kdDimensions);
            }
        }
        /**
         * @private
         * @function Highcharts.Series#pointPlacementToXValue
         */
        pointPlacementToXValue() {
            const { options, xAxis } = this;
            let factor = options.pointPlacement;
            // Point placement is relative to each series pointRange (#5889)
            if (factor === 'between') {
                factor = xAxis.reversed ? -0.5 : 0.5; // #11955
            }
            return isNumber$5(factor) ?
                factor * (options.pointRange || xAxis.pointRange) :
                0;
        }
        /**
         * @private
         * @function Highcharts.Series#isPointInside
         */
        isPointInside(point) {
            const { chart, xAxis, yAxis } = this, { plotX = -1, plotY = -1 } = point, isInside = (plotY >= 0 &&
                plotY <= (yAxis ? yAxis.len : chart.plotHeight) &&
                plotX >= 0 &&
                plotX <= (xAxis ? xAxis.len : chart.plotWidth));
            return isInside;
        }
        /**
         * Draw the tracker object that sits above all data labels and markers to
         * track mouse events on the graph or points. For the line type charts
         * the tracker uses the same graphPath, but with a greater stroke width
         * for better control.
         * @private
         */
        drawTracker() {
            const series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat((trackByArea ? series.areaPath : series.graphPath) || []), chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip?.snap || 0, onMouseOver = () => {
                if (options.enableMouseTracking &&
                    chart.hoverSeries !== series) {
                    series.onMouseOver();
                }
            }, 
            /*
             * Empirical lowest possible opacities for TRACKER_FILL for an
             * element to stay invisible but clickable
             * IE9: 0.00000000001 (unlimited)
             * IE10: 0.0001 (exporting only)
             * FF: 0.00000000001 (unlimited)
             * Chrome: 0.000001
             * Safari: 0.000001
             * Opera: 0.00000000001 (unlimited)
             */
            TRACKER_FILL = 'rgba(192,192,192,' + (svg$1 ? 0.0001 : 0.002) + ')';
            let tracker = series.tracker;
            // Draw the tracker
            if (tracker) {
                tracker.attr({ d: trackerPath });
            }
            else if (series.graph) { // Create
                series.tracker = tracker = renderer.path(trackerPath)
                    .attr({
                    visibility: series.visible ? 'inherit' : 'hidden',
                    zIndex: 2
                })
                    .addClass(trackByArea ?
                    'highcharts-tracker-area' :
                    'highcharts-tracker-line')
                    .add(series.group);
                if (!chart.styledMode) {
                    tracker.attr({
                        'stroke-linecap': 'round',
                        'stroke-linejoin': 'round', // #1225
                        stroke: TRACKER_FILL,
                        fill: trackByArea ? TRACKER_FILL : 'none',
                        'stroke-width': series.graph.strokeWidth() +
                            (trackByArea ? 0 : 2 * snap)
                    });
                }
                // The tracker is added to the series group, which is clipped, but
                // is covered by the marker group. So the marker group also needs to
                // capture events.
                [
                    series.tracker,
                    series.markerGroup,
                    series.dataLabelsGroup
                ].forEach((tracker) => {
                    if (tracker) {
                        tracker.addClass('highcharts-tracker')
                            .on('mouseover', onMouseOver)
                            .on('mouseout', (e) => {
                            pointer?.onTrackerMouseOut(e);
                        });
                        if (options.cursor && !chart.styledMode) {
                            tracker.css({ cursor: options.cursor });
                        }
                        tracker.on('touchstart', onMouseOver);
                    }
                });
            }
            fireEvent$3(this, 'afterDrawTracker');
        }
        /**
         * Add a point to the series after render time. The point can be added at
         * the end, or by giving it an X value, to the start or in the middle of the
         * series.
         *
         * @sample highcharts/members/series-addpoint-append/
         *         Append point
         * @sample highcharts/members/series-addpoint-append-and-shift/
         *         Append and shift
         * @sample highcharts/members/series-addpoint-x-and-y/
         *         Both X and Y values given
         * @sample highcharts/members/series-addpoint-pie/
         *         Append pie slice
         * @sample stock/members/series-addpoint/
         *         Append 100 points in Highcharts Stock
         * @sample stock/members/series-addpoint-shift/
         *         Append and shift in Highcharts Stock
         * @sample maps/members/series-addpoint/
         *         Add a point in Highmaps
         *
         * @function Highcharts.Series#addPoint
         *
         * @param {Highcharts.PointOptionsType} options
         *        The point options. If options is a single number, a point with
         *        that y value is appended to the series. If it is an array, it will
         *        be interpreted as x and y values respectively. If it is an
         *        object, advanced options as outlined under `series.data` are
         *        applied.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the point is added. When adding
         *        more than one point, it is highly recommended that the redraw
         *        option be set to false, and instead {@link Chart#redraw} is
         *        explicitly called after the adding of points is finished.
         *        Otherwise, the chart will redraw after adding each point.
         *
         * @param {boolean} [shift=false]
         *        If true, a point is shifted off the start of the series as one is
         *        appended to the end.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether to apply animation, and optionally animation
         *        configuration.
         *
         * @param {boolean} [withEvent=true]
         *        Used internally, whether to fire the series `addPoint` event.
         *
         * @emits Highcharts.Series#event:addPoint
         */
        addPoint(options, redraw, shift, animation, withEvent) {
            const series = this, seriesOptions = series.options, data = series.data, chart = series.chart, xAxis = series.xAxis, names = xAxis && xAxis.hasNames && xAxis.names, dataOptions = seriesOptions.data, xData = series.xData;
            let isInTheMiddle, i;
            // Optional redraw, defaults to true
            redraw = pick$6(redraw, true);
            // Get options and push the point to xData, yData and series.options. In
            // series.generatePoints the Point instance will be created on demand
            // and pushed to the series.data array.
            const point = { series: series };
            series.pointClass.prototype.applyOptions.apply(point, [options]);
            const x = point.x;
            // Get the insertion point
            i = xData.length;
            if (series.requireSorting && x < xData[i - 1]) {
                isInTheMiddle = true;
                while (i && xData[i - 1] > x) {
                    i--;
                }
            }
            // Insert undefined item
            series.updateParallelArrays(point, 'splice', [i, 0, 0]);
            // Update it
            series.updateParallelArrays(point, i);
            if (names && point.name) {
                names[x] = point.name;
            }
            dataOptions.splice(i, 0, options);
            if (isInTheMiddle ||
                // When processedData is present we need to splice an empty slot
                // into series.data, otherwise generatePoints won't pick it up.
                series.processedData) {
                series.data.splice(i, 0, null);
                series.processData();
            }
            // Generate points to be added to the legend (#1329)
            if (seriesOptions.legendType === 'point') {
                series.generatePoints();
            }
            // Shift the first point off the parallel arrays
            if (shift) {
                if (data[0] && !!data[0].remove) {
                    data[0].remove(false);
                }
                else {
                    data.shift();
                    series.updateParallelArrays(point, 'shift');
                    dataOptions.shift();
                }
            }
            // Fire event
            if (withEvent !== false) {
                fireEvent$3(series, 'addPoint', { point: point });
            }
            // Redraw
            series.isDirty = true;
            series.isDirtyData = true;
            if (redraw) {
                chart.redraw(animation); // Animation is set anyway on redraw, #5665
            }
        }
        /**
         * Remove a point from the series. Unlike the
         * {@link Highcharts.Point#remove} method, this can also be done on a point
         * that is not instantiated because it is outside the view or subject to
         * Highcharts Stock data grouping.
         *
         * @sample highcharts/members/series-removepoint/
         *         Remove cropped point
         *
         * @function Highcharts.Series#removePoint
         *
         * @param {number} i
         *        The index of the point in the {@link Highcharts.Series.data|data}
         *        array.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the point is added. When
         *        removing more than one point, it is highly recommended that the
         *        `redraw` option be set to `false`, and instead {@link
         *        Highcharts.Chart#redraw} is explicitly called after the adding of
         *        points is finished.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether and optionally how the series should be animated.
         *
         * @emits Highcharts.Point#event:remove
         */
        removePoint(i, redraw, animation) {
            const series = this, data = series.data, point = data[i], points = series.points, chart = series.chart, remove = function () {
                if (points && points.length === data.length) { // #4935
                    points.splice(i, 1);
                }
                data.splice(i, 1);
                series.options.data.splice(i, 1);
                series.updateParallelArrays(point || { series: series }, 'splice', [i, 1]);
                if (point) {
                    point.destroy();
                }
                // Redraw
                series.isDirty = true;
                series.isDirtyData = true;
                if (redraw) {
                    chart.redraw();
                }
            };
            setAnimation$1(animation, chart);
            redraw = pick$6(redraw, true);
            // Fire the event with a default handler of removing the point
            if (point) {
                point.firePointEvent('remove', null, remove);
            }
            else {
                remove();
            }
        }
        /**
         * Remove a series and optionally redraw the chart.
         *
         * @sample highcharts/members/series-remove/
         *         Remove first series from a button
         *
         * @function Highcharts.Series#remove
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart or wait for an explicit call to
         *        {@link Highcharts.Chart#redraw}.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether to apply animation, and optionally animation
         *        configuration.
         *
         * @param {boolean} [withEvent=true]
         *        Used internally, whether to fire the series `remove` event.
         *
         * @emits Highcharts.Series#event:remove
         */
        remove(redraw, animation, withEvent, keepEvents) {
            const series = this, chart = series.chart;
            /**
             * @private
             */
            function remove() {
                // Destroy elements
                series.destroy(keepEvents);
                // Redraw
                chart.isDirtyLegend = chart.isDirtyBox = true;
                chart.linkSeries(keepEvents);
                if (pick$6(redraw, true)) {
                    chart.redraw(animation);
                }
            }
            // Fire the event with a default handler of removing the point
            if (withEvent !== false) {
                fireEvent$3(series, 'remove', null, remove);
            }
            else {
                remove();
            }
        }
        /**
         * Update the series with a new set of options. For a clean and precise
         * handling of new options, all methods and elements from the series are
         * removed, and it is initialized from scratch. Therefore, this method is
         * more performance expensive than some other utility methods like {@link
         * Series#setData} or {@link Series#setVisible}.
         *
         * Note that `Series.update` may mutate the passed `data` options.
         *
         * @sample highcharts/members/series-update/
         *         Updating series options
         * @sample maps/members/series-update/
         *         Update series options in Highmaps
         *
         * @function Highcharts.Series#update
         *
         * @param {Highcharts.SeriesOptionsType} options
         *        New options that will be merged with the series' existing options.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the series is altered. If doing
         *        more operations on the chart, it is a good idea to set redraw to
         *        false and call {@link Chart#redraw} after.
         *
         * @emits Highcharts.Series#event:update
         * @emits Highcharts.Series#event:afterUpdate
         */
        update(options, redraw) {
            options = diffObjects$1(options, this.userOptions);
            fireEvent$3(this, 'update', { options: options });
            const series = this, chart = series.chart, 
            // Must use user options when changing type because series.options
            // is merged in with type specific plotOptions
            oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes$1[initialType].prototype, groups = [
                'group',
                'markerGroup',
                'dataLabelsGroup',
                'transformGroup'
            ], optionsToCheck = [
                'dataGrouping',
                'pointStart',
                'pointInterval',
                'pointIntervalUnit',
                'keys'
            ], 
            // Animation must be enabled when calling update before the initial
            // animation has first run. This happens when calling update
            // directly after chart initialization, or when applying responsive
            // rules (#6912).
            animation = series.finishedAnimating && { animation: false }, kinds = {};
            let seriesOptions, n, preserve = [
                'colorIndex',
                'eventOptions',
                'navigatorSeries',
                'symbolIndex',
                'baseSeries'
            ], newType = (options.type ||
                oldOptions.type ||
                chart.options.chart.type);
            const keepPoints = !(
            // Indicators, histograms etc recalculate the data. It should be
            // possible to omit this.
            this.hasDerivedData ||
                // New type requires new point classes
                (newType && newType !== this.type) ||
                // New options affecting how the data points are built
                typeof options.pointStart !== 'undefined' ||
                typeof options.pointInterval !== 'undefined' ||
                typeof options.relativeXValue !== 'undefined' ||
                options.joinBy ||
                options.mapData || // #11636
                // Changes to data grouping requires new points in new group
                optionsToCheck.some((option) => series.hasOptionChanged(option)));
            newType = newType || initialType;
            if (keepPoints) {
                preserve.push('data', 'isDirtyData', 
                // GeoHeatMap interpolation
                'isDirtyCanvas', 'points', 'processedData', // #17057
                'processedXData', 'processedYData', 'xIncrement', 'cropped', '_hasPointMarkers', 'hasDataLabels', 
                // Networkgraph (#14397)
                'nodes', 'layout', 
                // Treemap
                'level', 
                // Map specific, consider moving it to series-specific preserve-
                // properties (#10617)
                'mapMap', 'mapData', 'minY', 'maxY', 'minX', 'maxX', 'transformGroups' // #18857
                );
                if (options.visible !== false) {
                    preserve.push('area', 'graph');
                }
                series.parallelArrays.forEach(function (key) {
                    preserve.push(key + 'Data');
                });
                if (options.data) {
                    // `setData` uses `dataSorting` options so we need to update
                    // them earlier
                    if (options.dataSorting) {
                        extend$5(series.options.dataSorting, options.dataSorting);
                    }
                    this.setData(options.data, false);
                }
            }
            // Do the merge, with some forced options
            options = merge$4(oldOptions, {
                // When oldOptions.index is null it should't be cleared.
                // Otherwise navigator series will have wrong indexes (#10193).
                index: oldOptions.index === void 0 ?
                    series.index : oldOptions.index,
                pointStart: 
                // When updating from blank (#7933)
                plotOptions?.series?.pointStart ??
                    oldOptions.pointStart ??
                    // When updating after addPoint
                    series.xData?.[0]
            }, !keepPoints && { data: series.options.data }, options, animation);
            // Merge does not merge arrays, but replaces them. Since points were
            // updated, `series.options.data` has correct merged options, use it:
            if (keepPoints && options.data) {
                options.data = series.options.data;
            }
            // Make sure preserved properties are not destroyed (#3094)
            preserve = groups.concat(preserve);
            preserve.forEach(function (prop) {
                preserve[prop] = series[prop];
                delete series[prop];
            });
            let casting = false;
            if (seriesTypes$1[newType]) {
                casting = newType !== series.type;
                // Destroy the series and delete all properties, it will be
                // reinserted within the `init` call below
                series.remove(false, false, false, true);
                if (casting) {
                    // #20264: Re-detect a certain chart properties from new series
                    chart.propFromSeries();
                    // Modern browsers including IE11
                    if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(series, seriesTypes$1[newType].prototype);
                        // Legacy (IE < 11)
                    }
                    else {
                        const ownEvents = Object.hasOwnProperty.call(series, 'hcEvents') && series.hcEvents;
                        for (n in initialSeriesProto) { // eslint-disable-line guard-for-in
                            series[n] = void 0;
                        }
                        // Reinsert all methods and properties from the new type
                        // prototype (#2270, #3719).
                        extend$5(series, seriesTypes$1[newType].prototype);
                        // The events are tied to the prototype chain, don't copy if
                        // they're not the series' own
                        if (ownEvents) {
                            series.hcEvents = ownEvents;
                        }
                        else {
                            delete series.hcEvents;
                        }
                    }
                }
            }
            else {
                error$1(17, true, chart, { missingModuleFor: newType });
            }
            // Re-register groups (#3094) and other preserved properties
            preserve.forEach(function (prop) {
                series[prop] = preserve[prop];
            });
            series.init(chart, options);
            // Remove particular elements of the points. Check `series.options`
            // because we need to consider the options being set on plotOptions as
            // well.
            if (keepPoints && this.points) {
                seriesOptions = series.options;
                // What kind of elements to destroy
                if (seriesOptions.visible === false) {
                    kinds.graphic = 1;
                    kinds.dataLabel = 1;
                }
                else {
                    // If the marker got disabled or changed its symbol, width or
                    // height - destroy
                    if (this.hasMarkerChanged(seriesOptions, oldOptions)) {
                        kinds.graphic = 1;
                    }
                    if (!series.hasDataLabels?.()) {
                        kinds.dataLabel = 1;
                    }
                }
                for (const point of this.points) {
                    if (point && point.series) {
                        point.resolveColor();
                        // Destroy elements in order to recreate based on updated
                        // series options.
                        if (Object.keys(kinds).length) {
                            point.destroyElements(kinds);
                        }
                        if (seriesOptions.showInLegend === false &&
                            point.legendItem) {
                            chart.legend.destroyItem(point);
                        }
                    }
                }
            }
            series.initialType = initialType;
            chart.linkSeries(); // Links are lost in series.remove (#3028)
            // Set data for series with sorting enabled if it isn't set yet (#19715)
            chart.setSortedData();
            // #15383: Fire updatedData if the type has changed to keep linked
            // series such as indicators updated
            if (casting && series.linkedSeries.length) {
                series.isDirtyData = true;
            }
            fireEvent$3(this, 'afterUpdate');
            if (pick$6(redraw, true)) {
                chart.redraw(keepPoints ? void 0 : false);
            }
        }
        /**
         * Used from within series.update
         * @private
         */
        setName(name) {
            this.name = this.options.name = this.userOptions.name = name;
            this.chart.isDirtyLegend = true;
        }
        /**
         * Check if the option has changed.
         * @private
         */
        hasOptionChanged(optionName) {
            const chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName], plotOptionsOption = pick$6(plotOptions?.[this.type]?.[optionName], plotOptions?.series?.[optionName]);
            // Check if `plotOptions` are defined already, #19203
            if (oldOption && !defined$5(plotOptionsOption)) {
                return option !== oldOption;
            }
            return option !== pick$6(plotOptionsOption, option);
        }
        /**
         * Runs on mouse over the series graphical items.
         *
         * @function Highcharts.Series#onMouseOver
         * @emits Highcharts.Series#event:mouseOver
         */
        onMouseOver() {
            const series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;
            pointer?.setHoverChartIndex();
            // Set normal state to previous series
            if (hoverSeries && hoverSeries !== series) {
                hoverSeries.onMouseOut();
            }
            // Trigger the event, but to save processing time,
            // only if defined
            if (series.options.events.mouseOver) {
                fireEvent$3(series, 'mouseOver');
            }
            // Hover this
            series.setState('hover');
            /**
             * Contains the original hovered series.
             *
             * @name Highcharts.Chart#hoverSeries
             * @type {Highcharts.Series|null}
             */
            chart.hoverSeries = series;
        }
        /**
         * Runs on mouse out of the series graphical items.
         *
         * @function Highcharts.Series#onMouseOut
         *
         * @emits Highcharts.Series#event:mouseOut
         */
        onMouseOut() {
            // Trigger the event only if listeners exist
            const series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
            // #182, set to null before the mouseOut event fires
            chart.hoverSeries = null;
            // Trigger mouse out on the point, which must be in this series
            if (hoverPoint) {
                hoverPoint.onMouseOut();
            }
            // Fire the mouse out event
            if (series && options.events.mouseOut) {
                fireEvent$3(series, 'mouseOut');
            }
            // Hide the tooltip
            if (tooltip &&
                !series.stickyTracking &&
                (!tooltip.shared || series.noSharedTooltip)) {
                tooltip.hide();
            }
            // Reset all inactive states
            chart.series.forEach(function (s) {
                s.setState('', true);
            });
        }
        /**
         * Set the state of the series. Called internally on mouse interaction
         * operations, but it can also be called directly to visually
         * highlight a series.
         *
         * @function Highcharts.Series#setState
         *
         * @param {Highcharts.SeriesStateValue|""} [state]
         *        The new state, can be either `'hover'`, `'inactive'`, `'select'`,
         *        or `''` (an empty string), `'normal'` or `undefined` to set to
         *        normal state.
         * @param {boolean} [inherit]
         *        Determines if state should be inherited by points too.
         */
        setState(state, inherit) {
            const series = this, options = series.options, graph = series.graph, inactiveOtherPoints = options.inactiveOtherPoints, stateOptions = options.states, 
            // By default a quick animation to hover/inactive,
            // slower to un-hover
            stateAnimation = pick$6((stateOptions[state || 'normal'] &&
                stateOptions[state || 'normal'].animation), series.chart.options.chart.animation);
            let lineWidth = options.lineWidth, opacity = options.opacity;
            state = state || '';
            if (series.state !== state) {
                // Toggle class names
                [
                    series.group,
                    series.markerGroup,
                    series.dataLabelsGroup
                ].forEach(function (group) {
                    if (group) {
                        // Old state
                        if (series.state) {
                            group.removeClass('highcharts-series-' + series.state);
                        }
                        // New state
                        if (state) {
                            group.addClass('highcharts-series-' + state);
                        }
                    }
                });
                series.state = state;
                if (!series.chart.styledMode) {
                    if (stateOptions[state] &&
                        stateOptions[state].enabled === false) {
                        return;
                    }
                    if (state) {
                        lineWidth = (stateOptions[state].lineWidth ||
                            lineWidth + (stateOptions[state].lineWidthPlus || 0)); // #4035
                        opacity = pick$6(stateOptions[state].opacity, opacity);
                    }
                    if (graph && !graph.dashstyle && isNumber$5(lineWidth)) {
                        // Animate the graph stroke-width
                        for (const graphElement of [
                            graph,
                            ...this.zones.map((zone) => zone.graph)
                        ]) {
                            graphElement?.animate({
                                'stroke-width': lineWidth
                            }, stateAnimation);
                        }
                    }
                    // For some types (pie, networkgraph, sankey) opacity is
                    // resolved on a point level
                    if (!inactiveOtherPoints) {
                        [
                            series.group,
                            series.markerGroup,
                            series.dataLabelsGroup,
                            series.labelBySeries
                        ].forEach(function (group) {
                            if (group) {
                                group.animate({
                                    opacity: opacity
                                }, stateAnimation);
                            }
                        });
                    }
                }
            }
            // Don't loop over points on a series that doesn't apply inactive state
            // to siblings markers (e.g. line, column)
            if (inherit && inactiveOtherPoints && series.points) {
                series.setAllPointsToState(state || void 0);
            }
        }
        /**
         * Set the state for all points in the series.
         *
         * @function Highcharts.Series#setAllPointsToState
         *
         * @private
         *
         * @param {string} [state]
         *        Can be either `hover` or undefined to set to normal state.
         */
        setAllPointsToState(state) {
            this.points.forEach(function (point) {
                if (point.setState) {
                    point.setState(state);
                }
            });
        }
        /**
         * Show or hide the series.
         *
         * @function Highcharts.Series#setVisible
         *
         * @param {boolean} [visible]
         * True to show the series, false to hide. If undefined, the visibility is
         * toggled.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart after the series is altered. If doing more
         * operations on the chart, it is a good idea to set redraw to false and
         * call {@link Chart#redraw|chart.redraw()} after.
         *
         * @emits Highcharts.Series#event:hide
         * @emits Highcharts.Series#event:show
         */
        setVisible(vis, redraw) {
            const series = this, chart = series.chart, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
            // If called without an argument, toggle visibility
            series.visible =
                vis =
                    series.options.visible =
                        series.userOptions.visible =
                            typeof vis === 'undefined' ? !oldVisibility : vis; // #5618
            const showOrHide = vis ? 'show' : 'hide';
            // Show or hide elements
            [
                'group',
                'dataLabelsGroup',
                'markerGroup',
                'tracker',
                'tt'
            ].forEach((key) => {
                series[key]?.[showOrHide]();
            });
            // Hide tooltip (#1361)
            if (chart.hoverSeries === series ||
                chart.hoverPoint?.series === series) {
                series.onMouseOut();
            }
            if (series.legendItem) {
                chart.legend.colorizeItem(series, vis);
            }
            // Rescale or adapt to resized chart
            series.isDirty = true;
            // In a stack, all other series are affected
            if (series.options.stacking) {
                chart.series.forEach((otherSeries) => {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                        otherSeries.isDirty = true;
                    }
                });
            }
            // Show or hide linked series
            series.linkedSeries.forEach((otherSeries) => {
                otherSeries.setVisible(vis, false);
            });
            if (ignoreHiddenSeries) {
                chart.isDirtyBox = true;
            }
            fireEvent$3(series, showOrHide);
            if (redraw !== false) {
                chart.redraw();
            }
        }
        /**
         * Show the series if hidden.
         *
         * @sample highcharts/members/series-hide/
         *         Toggle visibility from a button
         *
         * @function Highcharts.Series#show
         * @emits Highcharts.Series#event:show
         */
        show() {
            this.setVisible(true);
        }
        /**
         * Hide the series if visible. If the
         * [chart.ignoreHiddenSeries](https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries)
         * option is true, the chart is redrawn without this series.
         *
         * @sample highcharts/members/series-hide/
         *         Toggle visibility from a button
         *
         * @function Highcharts.Series#hide
         * @emits Highcharts.Series#event:hide
         */
        hide() {
            this.setVisible(false);
        }
        /**
         * Select or unselect the series. This means its
         * {@link Highcharts.Series.selected|selected}
         * property is set, the checkbox in the legend is toggled and when selected,
         * the series is returned by the {@link Highcharts.Chart#getSelectedSeries}
         * function.
         *
         * @sample highcharts/members/series-select/
         *         Select a series from a button
         *
         * @function Highcharts.Series#select
         *
         * @param {boolean} [selected]
         * True to select the series, false to unselect. If undefined, the selection
         * state is toggled.
         *
         * @emits Highcharts.Series#event:select
         * @emits Highcharts.Series#event:unselect
         */
        select(selected) {
            const series = this;
            series.selected =
                selected =
                    this.options.selected = (typeof selected === 'undefined' ?
                        !series.selected :
                        selected);
            if (series.checkbox) {
                series.checkbox.checked = selected;
            }
            fireEvent$3(series, selected ? 'select' : 'unselect');
        }
        /**
         * Checks if a tooltip should be shown for a given point.
         *
         * @private
         */
        shouldShowTooltip(plotX, plotY, options = {}) {
            options.series = this;
            options.visiblePlotOnly = true;
            return this.chart.isInsidePlot(plotX, plotY, options);
        }
        /**
         * Draws the legend symbol based on the legendSymbol user option.
         *
         * @private
         */
        drawLegendSymbol(legend, item) {
            LegendSymbol$1[this.options.legendSymbol || 'rectangle']
                ?.call(this, legend, item);
        }
    }
    Series.defaultOptions = seriesDefaults;
    /**
     * Registry of all available series types.
     *
     * @name Highcharts.Series.types
     * @type {Highcharts.Dictionary<typeof_Highcharts.Series>}
     */
    Series.types = SeriesRegistry$1.seriesTypes;
    /* *
     *
     *  Static Functions
     *
     * */
    /**
     * Registers a series class to be accessible via `Series.types`.
     *
     * @function Highcharts.Series.registerType
     *
     * @param {string} seriesType
     * The series type as an identifier string in lower case.
     *
     * @param {Function} SeriesClass
     * The series class as a class pattern or a constructor function with
     * prototype.
     */
    Series.registerType = SeriesRegistry$1.registerSeriesType;
    extend$5(Series.prototype, {
        axisTypes: ['xAxis', 'yAxis'],
        coll: 'series',
        colorCounter: 0,
        directTouch: false,
        invertible: true,
        isCartesian: true,
        kdAxisArray: ['clientX', 'plotY'],
        // Each point's x and y values are stored in this.xData and this.yData:
        parallelArrays: ['x', 'y'],
        pointClass: Point,
        requireSorting: true,
        // Requires the data to be sorted:
        sorted: true
    });
    /* *
     *
     *  Registry
     *
     * */
    SeriesRegistry$1.series = Series;

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defined: defined$4, extend: extend$4, isNumber: isNumber$4, merge: merge$3, pick: pick$5, removeEvent: removeEvent$1 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /**
     * SVG label to render text.
     * @private
     * @class
     * @name Highcharts.SVGLabel
     * @augments Highcharts.SVGElement
     */
    class SVGLabel extends SVGElement {
        /* *
         *
         *  Constructor
         *
         * */
        constructor(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
            super(renderer, 'g');
            this.paddingLeftSetter = this.paddingSetter;
            this.paddingRightSetter = this.paddingSetter;
            this.doUpdate = false;
            this.textStr = str;
            this.x = x;
            this.y = y;
            this.anchorX = anchorX;
            this.anchorY = anchorY;
            this.baseline = baseline;
            this.className = className;
            this.addClass(className === 'button' ?
                'highcharts-no-tooltip' :
                'highcharts-label');
            if (className) {
                this.addClass('highcharts-' + className);
            }
            // Create the text element. An undefined text content prevents redundant
            // box calculation (#16121)
            this.text = renderer.text(void 0, 0, 0, useHTML).attr({ zIndex: 1 });
            // Validate the shape argument
            let hasBGImage;
            if (typeof shape === 'string') {
                hasBGImage = /^url\((.*?)\)$/.test(shape);
                if (hasBGImage || this.renderer.symbols[shape]) {
                    this.symbolKey = shape;
                }
            }
            this.bBox = SVGLabel.emptyBBox;
            this.padding = 3;
            this.baselineOffset = 0;
            this.needsBox = renderer.styledMode || hasBGImage;
            this.deferredAttr = {};
            this.alignFactor = 0;
        }
        /* *
         *
         *  Functions
         *
         * */
        alignSetter(value) {
            const alignFactor = ({
                left: 0,
                center: 0.5,
                right: 1
            })[value];
            if (alignFactor !== this.alignFactor) {
                this.alignFactor = alignFactor;
                // Bounding box exists, means we're dynamically changing
                if (this.bBox && isNumber$4(this.xSetting)) {
                    this.attr({ x: this.xSetting }); // #5134
                }
            }
        }
        anchorXSetter(value, key) {
            this.anchorX = value;
            this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);
        }
        anchorYSetter(value, key) {
            this.anchorY = value;
            this.boxAttr(key, value - this.ySetting);
        }
        /*
         * Set a box attribute, or defer it if the box is not yet created
         */
        boxAttr(key, value) {
            if (this.box) {
                this.box.attr(key, value);
            }
            else {
                this.deferredAttr[key] = value;
            }
        }
        /*
         * Pick up some properties and apply them to the text instead of the
         * wrapper.
         */
        css(styles) {
            if (styles) {
                const textStyles = {};
                // Create a copy to avoid altering the original object
                // (#537)
                styles = merge$3(styles);
                SVGLabel.textProps.forEach((prop) => {
                    if (typeof styles[prop] !== 'undefined') {
                        textStyles[prop] = styles[prop];
                        delete styles[prop];
                    }
                });
                this.text.css(textStyles);
                // Update existing text, box (#9400, #12163, #18212)
                if ('fontSize' in textStyles || 'fontWeight' in textStyles) {
                    this.updateTextPadding();
                }
                else if ('width' in textStyles || 'textOverflow' in textStyles) {
                    this.updateBoxSize();
                }
            }
            return SVGElement.prototype.css.call(this, styles);
        }
        /*
         * Destroy and release memory.
         */
        destroy() {
            // Added by button implementation
            removeEvent$1(this.element, 'mouseenter');
            removeEvent$1(this.element, 'mouseleave');
            if (this.text) {
                this.text.destroy();
            }
            if (this.box) {
                this.box = this.box.destroy();
            }
            // Call base implementation to destroy the rest
            SVGElement.prototype.destroy.call(this);
            return void 0;
        }
        fillSetter(value, key) {
            if (value) {
                this.needsBox = true;
            }
            // For animation getter (#6776)
            this.fill = value;
            this.boxAttr(key, value);
        }
        /*
         * Return the bounding box of the box, not the group.
         */
        getBBox(reload, rot) {
            // If we have a text string and the DOM bBox was 0, it typically means
            // that the label was first rendered hidden, so we need to update the
            // bBox (#15246)
            if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
                this.updateBoxSize();
            }
            const { padding, height = 0, translateX = 0, translateY = 0, width = 0 } = this, paddingLeft = pick$5(this.paddingLeft, padding), rotation = rot ?? (this.rotation || 0);
            let bBox = {
                width,
                height,
                x: translateX + this.bBox.x - paddingLeft,
                y: translateY + this.bBox.y - padding + this.baselineOffset
            };
            if (rotation) {
                bBox = this.getRotatedBox(bBox, rotation);
            }
            return bBox;
        }
        getCrispAdjust() {
            return (this.renderer.styledMode && this.box ?
                this.box.strokeWidth() :
                (this['stroke-width'] ?
                    parseInt(this['stroke-width'], 10) :
                    0)) % 2 / 2;
        }
        heightSetter(value) {
            this.heightSetting = value;
            this.doUpdate = true;
        }
        /**
         * This method is executed in the end of `attr()`, after setting all
         * attributes in the hash. In can be used to efficiently consolidate
         * multiple attributes in one SVG property -- e.g., translate, rotate and
         * scale are merged in one "transform" attribute in the SVG node.
         * Also updating height or width should trigger update of the box size.
         *
         * @private
         * @function Highcharts.SVGLabel#afterSetters
         */
        afterSetters() {
            super.afterSetters();
            if (this.doUpdate) {
                this.updateBoxSize();
                this.doUpdate = false;
            }
        }
        /*
         * After the text element is added, get the desired size of the border
         * box and add it before the text in the DOM.
         */
        onAdd() {
            this.text.add(this);
            this.attr({
                // Alignment is available now  (#3295, 0 not rendered if given
                // as a value)
                text: pick$5(this.textStr, ''),
                x: this.x || 0,
                y: this.y || 0
            });
            if (this.box && defined$4(this.anchorX)) {
                this.attr({
                    anchorX: this.anchorX,
                    anchorY: this.anchorY
                });
            }
        }
        paddingSetter(value, key) {
            if (!isNumber$4(value)) {
                this[key] = void 0;
            }
            else if (value !== this[key]) {
                this[key] = value;
                this.updateTextPadding();
            }
        }
        rSetter(value, key) {
            this.boxAttr(key, value);
        }
        strokeSetter(value, key) {
            // For animation getter (#6776)
            this.stroke = value;
            this.boxAttr(key, value);
        }
        'stroke-widthSetter'(value, key) {
            if (value) {
                this.needsBox = true;
            }
            this['stroke-width'] = value;
            this.boxAttr(key, value);
        }
        'text-alignSetter'(value) {
            this.textAlign = value;
        }
        textSetter(text) {
            if (typeof text !== 'undefined') {
                // Must use .attr to ensure transforms are done (#10009)
                this.text.attr({ text });
            }
            this.updateTextPadding();
            this.reAlign();
        }
        /*
         * This function runs after the label is added to the DOM (when the bounding
         * box is available), and after the text of the label is updated to detect
         * the new bounding box and reflect it in the border box.
         */
        updateBoxSize() {
            const text = this.text, attribs = {}, padding = this.padding, 
            // #12165 error when width is null (auto)
            // #12163 when fontweight: bold, recalculate bBox without cache
            // #3295 && 3514 box failure when string equals 0
            bBox = this.bBox = (((!isNumber$4(this.widthSetting) ||
                !isNumber$4(this.heightSetting) ||
                this.textAlign) && defined$4(text.textStr)) ?
                text.getBBox(void 0, 0) :
                SVGLabel.emptyBBox);
            let crispAdjust;
            this.width = this.getPaddedWidth();
            this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
            const metrics = this.renderer.fontMetrics(text);
            // Update the label-scoped y offset. Math.min because of inline
            // style (#9400)
            this.baselineOffset = padding + Math.min(
            // When applicable, use the font size of the first line (#15707)
            (this.text.firstLineMetrics || metrics).b, 
            // When the height is 0, there is no bBox, so go with the font
            // metrics. Highmaps CSS demos.
            bBox.height || Infinity);
            // #15491: Vertical centering
            if (this.heightSetting) {
                this.baselineOffset += (this.heightSetting - metrics.h) / 2;
            }
            if (this.needsBox && !text.textPath) {
                // Create the border box if it is not already present
                if (!this.box) {
                    // Symbol definition exists (#5324)
                    const box = this.box = this.symbolKey ?
                        this.renderer.symbol(this.symbolKey) :
                        this.renderer.rect();
                    box.addClass(// Don't use label className for buttons
                    (this.className === 'button' ?
                        '' : 'highcharts-label-box') +
                        (this.className ?
                            ' highcharts-' + this.className + '-box' : ''));
                    box.add(this);
                }
                crispAdjust = this.getCrispAdjust();
                attribs.x = crispAdjust;
                attribs.y = ((this.baseline ? -this.baselineOffset : 0) + crispAdjust);
                // Apply the box attributes
                attribs.width = Math.round(this.width);
                attribs.height = Math.round(this.height);
                this.box.attr(extend$4(attribs, this.deferredAttr));
                this.deferredAttr = {};
            }
        }
        /*
         * This function runs after setting text or padding, but only if padding
         * is changed.
         */
        updateTextPadding() {
            const text = this.text;
            if (!text.textPath) {
                this.updateBoxSize();
                // Determine y based on the baseline
                const textY = this.baseline ? 0 : this.baselineOffset;
                let textX = pick$5(this.paddingLeft, this.padding);
                // Compensate for alignment
                if (defined$4(this.widthSetting) &&
                    this.bBox &&
                    (this.textAlign === 'center' || this.textAlign === 'right')) {
                    textX += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width);
                }
                // Update if anything changed
                if (textX !== text.x || textY !== text.y) {
                    text.attr('x', textX);
                    // #8159 - prevent misplaced data labels in treemap
                    // (useHTML: true)
                    if (text.hasBoxWidthChanged) {
                        this.bBox = text.getBBox(true);
                    }
                    if (typeof textY !== 'undefined') {
                        text.attr('y', textY);
                    }
                }
                // Record current values
                text.x = textX;
                text.y = textY;
            }
        }
        widthSetter(value) {
            // `width:auto` => null
            this.widthSetting = isNumber$4(value) ? value : void 0;
            this.doUpdate = true;
        }
        getPaddedWidth() {
            const padding = this.padding;
            const paddingLeft = pick$5(this.paddingLeft, padding);
            const paddingRight = pick$5(this.paddingRight, padding);
            return ((this.widthSetting || this.bBox.width || 0) +
                paddingLeft +
                paddingRight);
        }
        xSetter(value) {
            this.x = value; // For animation getter
            if (this.alignFactor) {
                value -= this.alignFactor * this.getPaddedWidth();
                // Force animation even when setting to the same value (#7898)
                this['forceAnimate:x'] = true;
            }
            this.xSetting = Math.round(value);
            this.attr('translateX', this.xSetting);
        }
        ySetter(value) {
            this.ySetting = this.y = Math.round(value);
            this.attr('translateY', this.ySetting);
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    SVGLabel.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
    };
    /**
     * For labels, these CSS properties are applied to the `text` node directly.
     *
     * @private
     * @name Highcharts.SVGLabel#textProps
     * @type {Array<string>}
     */
    SVGLabel.textProps = [
        'color', 'direction', 'fontFamily', 'fontSize', 'fontStyle',
        'fontWeight', 'lineHeight', 'textAlign', 'textDecoration',
        'textOutline', 'textOverflow', 'whiteSpace', 'width'
    ];

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defined: defined$3, isNumber: isNumber$3, pick: pick$4 } = Utilities;
    /* *
     *
     *  Functions
     *
     * */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    /**
     *
     */
    function arc(cx, cy, w, h, options) {
        const arc = [];
        if (options) {
            const start = options.start || 0, rx = pick$4(options.r, w), ry = pick$4(options.r, h || w), 
            // Subtract a small number to prevent cos and sin of start and end
            // from becoming equal on 360 arcs (#1561). The size of the circle
            // affects the constant, therefore the division by `rx`. If the
            // proximity is too small, the arc disappears. If it is too great, a
            // gap appears. This can be seen in the animation of the official
            // bubble demo (#20586).
            proximity = 0.0002 / (options.borderRadius ? 1 : Math.max(rx, 1)), fullCircle = (Math.abs((options.end || 0) - start - 2 * Math.PI) <
                proximity), end = (options.end || 0) - (fullCircle ? proximity : 0), innerRadius = options.innerR, open = pick$4(options.open, fullCircle), cosStart = Math.cos(start), sinStart = Math.sin(start), cosEnd = Math.cos(end), sinEnd = Math.sin(end), 
            // Proximity takes care of rounding errors around PI (#6971)
            longArc = pick$4(options.longArc, end - start - Math.PI < proximity ? 0 : 1);
            let arcSegment = [
                'A', // ArcTo
                rx, // X radius
                ry, // Y radius
                0, // Slanting
                longArc, // Long or short arc
                pick$4(options.clockwise, 1), // Clockwise
                cx + rx * cosEnd,
                cy + ry * sinEnd
            ];
            arcSegment.params = { start, end, cx, cy }; // Memo for border radius
            arc.push([
                'M',
                cx + rx * cosStart,
                cy + ry * sinStart
            ], arcSegment);
            if (defined$3(innerRadius)) {
                arcSegment = [
                    'A', // ArcTo
                    innerRadius, // X radius
                    innerRadius, // Y radius
                    0, // Slanting
                    longArc, // Long or short arc
                    // Clockwise - opposite to the outer arc clockwise
                    defined$3(options.clockwise) ? 1 - options.clockwise : 0,
                    cx + innerRadius * cosStart,
                    cy + innerRadius * sinStart
                ];
                // Memo for border radius
                arcSegment.params = {
                    start: end,
                    end: start,
                    cx,
                    cy
                };
                arc.push(open ?
                    [
                        'M',
                        cx + innerRadius * cosEnd,
                        cy + innerRadius * sinEnd
                    ] : [
                    'L',
                    cx + innerRadius * cosEnd,
                    cy + innerRadius * sinEnd
                ], arcSegment);
            }
            if (!open) {
                arc.push(['Z']);
            }
        }
        return arc;
    }
    /**
     * Callout shape used for default tooltips.
     */
    function callout(x, y, w, h, options) {
        const arrowLength = 6, halfDistance = 6, r = Math.min((options && options.r) || 0, w, h), safeDistance = r + halfDistance, anchorX = options && options.anchorX, anchorY = options && options.anchorY || 0;
        const path = roundedRect(x, y, w, h, { r });
        if (!isNumber$3(anchorX)) {
            return path;
        }
        // Do not render a connector, if anchor starts inside the label
        if (anchorX < w && anchorX > 0 && anchorY < h && anchorY > 0) {
            return path;
        }
        // Anchor on right side
        if (x + anchorX > w - safeDistance) {
            // Chevron
            if (anchorY > y + safeDistance &&
                anchorY < y + h - safeDistance) {
                path.splice(3, 1, ['L', x + w, anchorY - halfDistance], ['L', x + w + arrowLength, anchorY], ['L', x + w, anchorY + halfDistance], ['L', x + w, y + h - r]);
                // Simple connector
            }
            else {
                if (anchorX < w) { // Corner connector
                    const isTopCorner = anchorY < y + safeDistance, cornerY = isTopCorner ? y : y + h, sliceStart = isTopCorner ? 2 : 5;
                    path.splice(sliceStart, 0, ['L', anchorX, anchorY], ['L', x + w - r, cornerY]);
                }
                else { // Side connector
                    path.splice(3, 1, ['L', x + w, h / 2], ['L', anchorX, anchorY], ['L', x + w, h / 2], ['L', x + w, y + h - r]);
                }
            }
            // Anchor on left side
        }
        else if (x + anchorX < safeDistance) {
            // Chevron
            if (anchorY > y + safeDistance &&
                anchorY < y + h - safeDistance) {
                path.splice(7, 1, ['L', x, anchorY + halfDistance], ['L', x - arrowLength, anchorY], ['L', x, anchorY - halfDistance], ['L', x, y + r]);
                // Simple connector
            }
            else {
                if (anchorX > 0) { // Corner connector
                    const isTopCorner = anchorY < y + safeDistance, cornerY = isTopCorner ? y : y + h, sliceStart = isTopCorner ? 1 : 6;
                    path.splice(sliceStart, 0, ['L', anchorX, anchorY], ['L', x + r, cornerY]);
                }
                else { // Side connector
                    path.splice(7, 1, ['L', x, h / 2], ['L', anchorX, anchorY], ['L', x, h / 2], ['L', x, y + r]);
                }
            }
        }
        else if ( // Replace bottom
        anchorY > h &&
            anchorX < w - safeDistance) {
            path.splice(5, 1, ['L', anchorX + halfDistance, y + h], ['L', anchorX, y + h + arrowLength], ['L', anchorX - halfDistance, y + h], ['L', x + r, y + h]);
        }
        else if ( // Replace top
        anchorY < 0 &&
            anchorX > safeDistance) {
            path.splice(1, 1, ['L', anchorX - halfDistance, y], ['L', anchorX, y - arrowLength], ['L', anchorX + halfDistance, y], ['L', w - r, y]);
        }
        return path;
    }
    /**
     *
     */
    function circle(x, y, w, h) {
        // Return a full arc
        return arc(x + w / 2, y + h / 2, w / 2, h / 2, {
            start: Math.PI * 0.5,
            end: Math.PI * 2.5,
            open: false
        });
    }
    /**
     *
     */
    function diamond(x, y, w, h) {
        return [
            ['M', x + w / 2, y],
            ['L', x + w, y + h / 2],
            ['L', x + w / 2, y + h],
            ['L', x, y + h / 2],
            ['Z']
        ];
    }
    // #15291
    /**
     *
     */
    function rect(x, y, w, h, options) {
        if (options && options.r) {
            return roundedRect(x, y, w, h, options);
        }
        return [
            ['M', x, y],
            ['L', x + w, y],
            ['L', x + w, y + h],
            ['L', x, y + h],
            ['Z']
        ];
    }
    /**
     *
     */
    function roundedRect(x, y, w, h, options) {
        const r = options?.r || 0;
        return [
            ['M', x + r, y],
            ['L', x + w - r, y], // Top side
            ['A', r, r, 0, 0, 1, x + w, y + r], // Top-right corner
            ['L', x + w, y + h - r], // Right side
            ['A', r, r, 0, 0, 1, x + w - r, y + h], // Bottom-right corner
            ['L', x + r, y + h], // Bottom side
            ['A', r, r, 0, 0, 1, x, y + h - r], // Bottom-left corner
            ['L', x, y + r], // Left side
            ['A', r, r, 0, 0, 1, x + r, y],
            ['Z'] // Top-left corner
        ];
    }
    /**
     *
     */
    function triangle(x, y, w, h) {
        return [
            ['M', x + w / 2, y],
            ['L', x + w, y + h],
            ['L', x, y + h],
            ['Z']
        ];
    }
    /**
     *
     */
    function triangleDown(x, y, w, h) {
        return [
            ['M', x, y],
            ['L', x + w, y],
            ['L', x + w / 2, y + h],
            ['Z']
        ];
    }
    const Symbols = {
        arc,
        callout,
        circle,
        diamond,
        rect,
        roundedRect,
        square: rect,
        triangle,
        'triangle-down': triangleDown
    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { doc: doc$2, SVG_NS: SVG_NS$1, win: win$2 } = H;
    const { attr: attr$2, extend: extend$3, fireEvent: fireEvent$2, isString: isString$2, objectEach: objectEach$2, pick: pick$3 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /**
     * SVG Text Builder
     * @private
     * @class
     * @name Highcharts.TextBuilder
     */
    class TextBuilder {
        constructor(svgElement) {
            const textStyles = svgElement.styles;
            this.renderer = svgElement.renderer;
            this.svgElement = svgElement;
            this.width = svgElement.textWidth;
            this.textLineHeight = textStyles && textStyles.lineHeight;
            this.textOutline = textStyles && textStyles.textOutline;
            this.ellipsis = Boolean(textStyles && textStyles.textOverflow === 'ellipsis');
            this.noWrap = Boolean(textStyles && textStyles.whiteSpace === 'nowrap');
        }
        /**
         * Build an SVG representation of the pseudo HTML given in the object's
         * svgElement.
         *
         * @private
         *
         * @return {void}.
         */
        buildSVG() {
            const wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick$3(wrapper.textStr, '').toString(), hasMarkup = textStr.indexOf('<') !== -1, childNodes = textNode.childNodes, tempParent = !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, 
            // The buildText code is quite heavy, so if we're not changing
            // something that affects the text, skip it (#6113).
            textCache = [
                textStr,
                this.ellipsis,
                this.noWrap,
                this.textLineHeight,
                this.textOutline,
                wrapper.getStyle('font-size'),
                this.width
            ].join(',');
            if (textCache === wrapper.textCache) {
                return;
            }
            wrapper.textCache = textCache;
            delete wrapper.actualWidth;
            // Remove old text
            for (let i = childNodes.length; i--;) {
                textNode.removeChild(childNodes[i]);
            }
            // Simple strings, add text directly and return
            if (!hasMarkup &&
                !this.ellipsis &&
                !this.width &&
                !wrapper.textPath &&
                (textStr.indexOf(' ') === -1 ||
                    (this.noWrap && !regexMatchBreaks.test(textStr)))) {
                textNode.appendChild(doc$2.createTextNode(this.unescapeEntities(textStr)));
                // Complex strings, add more logic
            }
            else if (textStr !== '') {
                if (tempParent) {
                    // Attach it to the DOM to read offset width and font size
                    tempParent.appendChild(textNode);
                }
                // Step 1. Parse the markup safely and directly into a tree
                // structure.
                const ast = new AST(textStr);
                // Step 2. Do as many as we can of the modifications to the tree
                // structure before it is added to the DOM
                this.modifyTree(ast.nodes);
                ast.addToDOM(textNode);
                // Step 3. Some modifications can't be done until the structure is
                // in the DOM, because we need to read computed metrics.
                this.modifyDOM();
                // Add title if an ellipsis was added
                if (this.ellipsis &&
                    (textNode.textContent || '').indexOf('\u2026') !== -1) {
                    wrapper.attr('title', this.unescapeEntities(wrapper.textStr || '', ['&lt;', '&gt;']) // #7179
                    );
                }
                if (tempParent) {
                    tempParent.removeChild(textNode);
                }
            }
            // Apply the text outline
            if (isString$2(this.textOutline) && wrapper.applyTextOutline) {
                wrapper.applyTextOutline(this.textOutline);
            }
        }
        /**
         * Modify the DOM of the generated SVG structure. This function only does
         * operations that cannot be done until the elements are attached to the
         * DOM, like doing layout based on rendered metrics of the added elements.
         *
         * @private
         *
         */
        modifyDOM() {
            const wrapper = this.svgElement;
            const x = attr$2(wrapper.element, 'x');
            wrapper.firstLineMetrics = void 0;
            // Remove empty tspans (including breaks) from the beginning because
            // SVG's getBBox doesn't count empty lines. The use case is tooltip
            // where the header is empty. By doing this in the DOM rather than in
            // the AST, we can inspect the textContent directly and don't have to
            // recurse down to look for valid content.
            let firstChild;
            while ((firstChild = wrapper.element.firstChild)) {
                if (/^[\s\u200B]*$/.test(firstChild.textContent || ' ')) {
                    wrapper.element.removeChild(firstChild);
                }
                else {
                    break;
                }
            }
            // Modify hard line breaks by applying the rendered line height
            [].forEach.call(wrapper.element.querySelectorAll('tspan.highcharts-br'), (br, i) => {
                if (br.nextSibling && br.previousSibling) { // #5261
                    if (i === 0 && br.previousSibling.nodeType === 1) {
                        wrapper.firstLineMetrics = wrapper.renderer
                            .fontMetrics(br.previousSibling);
                    }
                    attr$2(br, {
                        // Since the break is inserted in front of the next
                        // line, we need to use the next sibling for the line
                        // height
                        dy: this.getLineHeight(br.nextSibling),
                        x
                    });
                }
            });
            // Constrain the line width, either by ellipsis or wrapping
            const width = this.width || 0;
            if (!width) {
                return;
            }
            // Insert soft line breaks into each text node
            const modifyTextNode = (textNode, parentElement) => {
                const text = textNode.textContent || '';
                const words = text
                    .replace(/([^\^])-/g, '$1- ') // Split on hyphens
                    // .trim()
                    .split(' '); // #1273
                const hasWhiteSpace = !this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
                const dy = this.getLineHeight(parentElement);
                let lineNo = 0;
                let startAt = wrapper.actualWidth;
                if (this.ellipsis) {
                    if (text) {
                        this.truncate(textNode, text, void 0, 0, 
                        // Target width
                        Math.max(0, 
                        // Subtract the font face to make room for the
                        // ellipsis itself
                        width - 0.8 * dy), 
                        // Build the text to test for
                        (text, currentIndex) => text.substring(0, currentIndex) + '\u2026');
                    }
                }
                else if (hasWhiteSpace) {
                    const lines = [];
                    // Remove preceding siblings in order to make the text length
                    // calculation correct in the truncate function
                    const precedingSiblings = [];
                    while (parentElement.firstChild &&
                        parentElement.firstChild !== textNode) {
                        precedingSiblings.push(parentElement.firstChild);
                        parentElement.removeChild(parentElement.firstChild);
                    }
                    while (words.length) {
                        // Apply the previous line
                        if (words.length && !this.noWrap && lineNo > 0) {
                            lines.push(textNode.textContent || '');
                            textNode.textContent = words.join(' ')
                                .replace(/- /g, '-');
                        }
                        // For each line, truncate the remaining
                        // words into the line length.
                        this.truncate(textNode, void 0, words, lineNo === 0 ? (startAt || 0) : 0, width, 
                        // Build the text to test for
                        (t, currentIndex) => words
                            .slice(0, currentIndex)
                            .join(' ')
                            .replace(/- /g, '-'));
                        startAt = wrapper.actualWidth;
                        lineNo++;
                    }
                    // Reinsert the preceding child nodes
                    precedingSiblings.forEach((childNode) => {
                        parentElement.insertBefore(childNode, textNode);
                    });
                    // Insert the previous lines before the original text node
                    lines.forEach((line) => {
                        // Insert the line
                        parentElement.insertBefore(doc$2.createTextNode(line), textNode);
                        // Insert a break
                        const br = doc$2.createElementNS(SVG_NS$1, 'tspan');
                        br.textContent = '\u200B'; // Zero-width space
                        attr$2(br, { dy, x });
                        parentElement.insertBefore(br, textNode);
                    });
                }
            };
            // Recurse down the DOM tree and handle line breaks for each text node
            const modifyChildren = ((node) => {
                const childNodes = [].slice.call(node.childNodes);
                childNodes.forEach((childNode) => {
                    if (childNode.nodeType === win$2.Node.TEXT_NODE) {
                        modifyTextNode(childNode, node);
                    }
                    else {
                        // Reset word-wrap width readings after hard breaks
                        if (childNode.className.baseVal
                            .indexOf('highcharts-br') !== -1) {
                            wrapper.actualWidth = 0;
                        }
                        // Recurse down to child node
                        modifyChildren(childNode);
                    }
                });
            });
            modifyChildren(wrapper.element);
        }
        /**
         * Get the rendered line height of a <text>, <tspan> or pure text node.
         *
         * @param {DOMElementType|Text} node The node to check for
         *
         * @return {number} The rendered line height
         */
        getLineHeight(node) {
            // If the node is a text node, use its parent
            const element = (node.nodeType === win$2.Node.TEXT_NODE) ?
                node.parentElement :
                node;
            return this.textLineHeight ?
                parseInt(this.textLineHeight.toString(), 10) :
                this.renderer.fontMetrics(element || this.svgElement.element).h;
        }
        /**
         * Transform a pseudo HTML AST node tree into an SVG structure. We do as
         * much heavy lifting as we can here, before doing the final processing in
         * the modifyDOM function. The original data is mutated.
         *
         * @private
         *
         * @param {ASTNode[]} nodes The AST nodes
         *
         */
        modifyTree(nodes) {
            const modifyChild = (node, i) => {
                const { attributes = {}, children, style = {}, tagName } = node, styledMode = this.renderer.styledMode;
                // Apply styling to text tags
                if (tagName === 'b' || tagName === 'strong') {
                    if (styledMode) {
                        // eslint-disable-next-line dot-notation
                        attributes['class'] = 'highcharts-strong';
                    }
                    else {
                        style.fontWeight = 'bold';
                    }
                }
                else if (tagName === 'i' || tagName === 'em') {
                    if (styledMode) {
                        // eslint-disable-next-line dot-notation
                        attributes['class'] = 'highcharts-emphasized';
                    }
                    else {
                        style.fontStyle = 'italic';
                    }
                }
                // Modify styling
                if (style && style.color) {
                    style.fill = style.color;
                }
                // Handle breaks
                if (tagName === 'br') {
                    attributes['class'] = 'highcharts-br'; // eslint-disable-line dot-notation
                    node.textContent = '\u200B'; // Zero-width space
                    // Trim whitespace off the beginning of new lines
                    const nextNode = nodes[i + 1];
                    if (nextNode && nextNode.textContent) {
                        nextNode.textContent =
                            nextNode.textContent.replace(/^ +/gm, '');
                    }
                    // If an anchor has direct text node children, the text is unable to
                    // wrap because there is no `getSubStringLength` function on the
                    // element. Therefore we need to wrap the child text node or nodes
                    // in a tspan. #16173.
                }
                else if (tagName === 'a' &&
                    children &&
                    children.some((child) => child.tagName === '#text')) {
                    node.children = [{ children, tagName: 'tspan' }];
                }
                if (tagName !== '#text' && tagName !== 'a') {
                    node.tagName = 'tspan';
                }
                extend$3(node, { attributes, style });
                // Recurse
                if (children) {
                    children
                        .filter((c) => c.tagName !== '#text')
                        .forEach(modifyChild);
                }
            };
            nodes.forEach(modifyChild);
            fireEvent$2(this.svgElement, 'afterModifyTree', { nodes });
        }
        /*
         * Truncate the text node contents to a given length. Used when the css
         * width is set. If the `textOverflow` is `ellipsis`, the text is truncated
         * character by character to the given length. If not, the text is
         * word-wrapped line by line.
         */
        truncate(textNode, text, words, startAt, width, getString) {
            const svgElement = this.svgElement;
            const { rotation } = svgElement;
            // Cache the lengths to avoid checking the same twice
            const lengths = [];
            // Word wrap cannot be truncated to shorter than one word, ellipsis
            // text can be completely blank.
            let minIndex = words ? 1 : 0;
            let maxIndex = (text || words || '').length;
            let currentIndex = maxIndex;
            let str;
            let actualWidth;
            const getSubStringLength = function (charEnd, concatenatedEnd) {
                // `charEnd` is used when finding the character-by-character
                // break for ellipsis, concatenatedEnd is used for word-by-word
                // break for word wrapping.
                const end = concatenatedEnd || charEnd;
                const parentNode = textNode.parentNode;
                if (parentNode && typeof lengths[end] === 'undefined') {
                    // Modern browsers
                    if (parentNode.getSubStringLength) {
                        // Fails with DOM exception on unit-tests/legend/members
                        // of unknown reason. Desired width is 0, text content
                        // is "5" and end is 1.
                        try {
                            lengths[end] = startAt +
                                parentNode.getSubStringLength(0, words ? end + 1 : end);
                        }
                        catch (e) {
                        }
                    }
                }
                return lengths[end];
            };
            svgElement.rotation = 0; // Discard rotation when computing box
            actualWidth = getSubStringLength(textNode.textContent.length);
            if (startAt + actualWidth > width) {
                // Do a binary search for the index where to truncate the text
                while (minIndex <= maxIndex) {
                    currentIndex = Math.ceil((minIndex + maxIndex) / 2);
                    // When checking words for word-wrap, we need to build the
                    // string and measure the subStringLength at the concatenated
                    // word length.
                    if (words) {
                        str = getString(words, currentIndex);
                    }
                    actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
                    if (minIndex === maxIndex) {
                        // Complete
                        minIndex = maxIndex + 1;
                    }
                    else if (actualWidth > width) {
                        // Too large. Set max index to current.
                        maxIndex = currentIndex - 1;
                    }
                    else {
                        // Within width. Set min index to current.
                        minIndex = currentIndex;
                    }
                }
                // If max index was 0 it means the shortest possible text was also
                // too large. For ellipsis that means only the ellipsis, while for
                // word wrap it means the whole first word.
                if (maxIndex === 0) {
                    // Remove ellipsis
                    textNode.textContent = '';
                    // If the new text length is one less than the original, we don't
                    // need the ellipsis
                }
                else if (!(text && maxIndex === text.length - 1)) {
                    textNode.textContent = str || getString(text || words, currentIndex);
                }
            }
            // When doing line wrapping, prepare for the next line by removing the
            // items from this line.
            if (words) {
                words.splice(0, currentIndex);
            }
            svgElement.actualWidth = actualWidth;
            svgElement.rotation = rotation; // Apply rotation again.
        }
        /*
         * Un-escape HTML entities based on the public `renderer.escapes` list
         *
         * @private
         *
         * @param {string} inputStr The string to unescape
         * @param {Array<string>} [except] Exceptions
         *
         * @return {string} The processed string
         */
        unescapeEntities(inputStr, except) {
            objectEach$2(this.renderer.escapes, function (value, key) {
                if (!except || except.indexOf(value) === -1) {
                    inputStr = inputStr.toString().replace(new RegExp(value, 'g'), key);
                }
            });
            return inputStr;
        }
    }

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defaultOptions: defaultOptions$1 } = DefaultOptions;
    const { charts: charts$1, deg2rad, doc: doc$1, isFirefox, isMS, isWebKit, noop: noop$1, SVG_NS, symbolSizes, win: win$1 } = H;
    const { addEvent: addEvent$1, attr: attr$1, createElement: createElement$1, crisp: crisp$1, css: css$1, defined: defined$2, destroyObjectProperties, extend: extend$2, isArray: isArray$2, isNumber: isNumber$2, isObject: isObject$1, isString: isString$1, merge: merge$2, pick: pick$2, pInt: pInt$1, replaceNested, uniqueKey: uniqueKey$1 } = Utilities;
    /* *
     *
     *  Variables
     *
     * */
    let hasInternalReferenceBug;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * Allows direct access to the Highcharts rendering layer in order to draw
     * primitive shapes like circles, rectangles, paths or text directly on a chart,
     * or independent from any chart. The SVGRenderer represents a wrapper object
     * for SVG in modern browsers.
     *
     * An existing chart's renderer can be accessed through {@link Chart.renderer}.
     * The renderer can also be used completely decoupled from a chart.
     *
     * See [How to use the SVG Renderer](
     * https://www.highcharts.com/docs/advanced-chart-features/renderer) for a
     * comprehensive tutorial.
     *
     * @sample highcharts/members/renderer-on-chart
     *         Annotating a chart programmatically.
     * @sample highcharts/members/renderer-basic
     *         Independent SVG drawing.
     *
     * @example
     * // Use directly without a chart object.
     * let renderer = new Highcharts.Renderer(parentNode, 600, 400);
     *
     * @class
     * @name Highcharts.SVGRenderer
     *
     * @param {Highcharts.HTMLDOMElement} container
     *        Where to put the SVG in the web page.
     *
     * @param {number} width
     *        The width of the SVG.
     *
     * @param {number} height
     *        The height of the SVG.
     *
     * @param {Highcharts.CSSObject} [style]
     *        The box style, if not in styleMode
     *
     * @param {boolean} [forExport=false]
     *        Whether the rendered content is intended for export.
     *
     * @param {boolean} [allowHTML=true]
     *        Whether the renderer is allowed to include HTML text, which will be
     *        projected on top of the SVG.
     *
     * @param {boolean} [styledMode=false]
     *        Whether the renderer belongs to a chart that is in styled mode.
     *        If it does, it will avoid setting presentational attributes in
     *        some cases, but not when set explicitly through `.attr` and `.css`
     *        etc.
     */
    class SVGRenderer {
        /**
         * The root `svg` node of the renderer.
         *
         * @name Highcharts.SVGRenderer#box
         * @type {Highcharts.SVGDOMElement}
         */
        /**
         * The wrapper for the root `svg` node of the renderer.
         *
         * @name Highcharts.SVGRenderer#boxWrapper
         * @type {Highcharts.SVGElement}
         */
        /**
         * A pointer to the `defs` node of the root SVG.
         *
         * @name Highcharts.SVGRenderer#defs
         * @type {Highcharts.SVGElement}
         */
        /**
         * Whether the rendered content is intended for export.
         *
         * @name Highcharts.SVGRenderer#forExport
         * @type {boolean | undefined}
         */
        /**
         * Page url used for internal references.
         *
         * @private
         * @name Highcharts.SVGRenderer#url
         * @type {string}
         */
        /**
         * Initialize the SVGRenderer. Overridable initializer function that takes
         * the same parameters as the constructor.
         *
         * @function Highcharts.SVGRenderer#init
         *
         * @param {Highcharts.HTMLDOMElement} container
         * Where to put the SVG in the web page.
         *
         * @param {number} width
         * The width of the SVG.
         *
         * @param {number} height
         * The height of the SVG.
         *
         * @param {Highcharts.CSSObject} [style]
         * The box style, if not in styleMode
         *
         * @param {boolean} [forExport=false]
         * Whether the rendered content is intended for export.
         *
         * @param {boolean} [allowHTML=true]
         * Whether the renderer is allowed to include HTML text, which will be
         * projected on top of the SVG.
         *
         * @param {boolean} [styledMode=false]
         * Whether the renderer belongs to a chart that is in styled mode. If it
         * does, it will avoid setting presentational attributes in some cases, but
         * not when set explicitly through `.attr` and `.css` etc.
         */
        constructor(container, width, height, style, forExport, allowHTML, styledMode) {
            const renderer = this, boxWrapper = renderer
                .createElement('svg')
                .attr({
                version: '1.1',
                'class': 'highcharts-root'
            }), element = boxWrapper.element;
            if (!styledMode) {
                boxWrapper.css(this.getStyle(style || {}));
            }
            container.appendChild(element);
            // Always use ltr on the container, otherwise text-anchor will be
            // flipped and text appear outside labels, buttons, tooltip etc (#3482)
            attr$1(container, 'dir', 'ltr');
            // For browsers other than IE, add the namespace attribute (#1978)
            if (container.innerHTML.indexOf('xmlns') === -1) {
                attr$1(element, 'xmlns', this.SVG_NS);
            }
            this.box = element;
            this.boxWrapper = boxWrapper;
            this.alignedObjects = [];
            this.url = this.getReferenceURL();
            // Add description
            const desc = this.createElement('desc').add();
            desc.element.appendChild(doc$1.createTextNode('Created with @product.name@ @product.version@'));
            this.defs = this.createElement('defs').add();
            this.allowHTML = allowHTML;
            this.forExport = forExport;
            this.styledMode = styledMode;
            this.gradients = {}; // Object where gradient SvgElements are stored
            this.cache = {}; // Cache for numerical bounding boxes
            this.cacheKeys = [];
            this.imgCount = 0;
            this.rootFontSize = boxWrapper.getStyle('font-size');
            renderer.setSize(width, height, false);
            // Issue 110 workaround:
            // In Firefox, if a div is positioned by percentage, its pixel position
            // may land between pixels. The container itself doesn't display this,
            // but an SVG element inside this container will be drawn at subpixel
            // precision. In order to draw sharp lines, this must be compensated
            // for. This doesn't seem to work inside iframes though (like in
            // jsFiddle).
            let subPixelFix, rect;
            if (isFirefox && container.getBoundingClientRect) {
                subPixelFix = function () {
                    css$1(container, { left: 0, top: 0 });
                    rect = container.getBoundingClientRect();
                    css$1(container, {
                        left: (Math.ceil(rect.left) - rect.left) + 'px',
                        top: (Math.ceil(rect.top) - rect.top) + 'px'
                    });
                };
                // Run the fix now
                subPixelFix();
                // Run it on resize
                renderer.unSubPixelFix = addEvent$1(win$1, 'resize', subPixelFix);
            }
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * General method for adding a definition to the SVG `defs` tag. Can be used
         * for gradients, fills, filters etc. Styled mode only. A hook for adding
         * general definitions to the SVG's defs tag. Definitions can be referenced
         * from the CSS by its `id`. Read more in
         * [gradients, shadows and patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns).
         * Styled mode only.
         *
         * @function Highcharts.SVGRenderer#definition
         *
         * @param {Highcharts.ASTNode} def
         * A serialized form of an SVG definition, including children.
         *
         * @return {Highcharts.SVGElement}
         * The inserted node.
         */
        definition(def) {
            const ast = new AST([def]);
            return ast.addToDOM(this.defs.element);
        }
        /**
         * Get the prefix needed for internal URL references to work in certain
         * cases. Some older browser versions had a bug where internal url
         * references in SVG attributes, on the form `url(#some-id)`, would fail if
         * a base tag was present in the page. There were also issues with
         * `history.pushState` related to this prefix.
         *
         * Related issues: #24, #672, #1070, #5244.
         *
         * The affected browsers are:
         * - Chrome <= 53 (May 2018)
         * - Firefox <= 51 (January 2017)
         * - Safari/Mac <= 12.1 (2018 or 2019)
         * - Safari/iOS <= 13
         *
         * @todo Remove this hack when time has passed. All the affected browsers
         * are evergreens, so it is increasingly unlikely that users are affected by
         * the bug.
         *
         * @return {string}
         * The prefix to use. An empty string for modern browsers.
         */
        getReferenceURL() {
            if ((isFirefox || isWebKit) &&
                doc$1.getElementsByTagName('base').length) {
                // Detect if a clip path is taking effect by performing a hit test
                // outside the clipped area. If the hit element is the rectangle
                // that was supposed to be clipped, the bug is present. This only
                // has to be performed once per page load, so we store the result
                // locally in the module.
                if (!defined$2(hasInternalReferenceBug)) {
                    const id = uniqueKey$1();
                    const ast = new AST([{
                            tagName: 'svg',
                            attributes: {
                                width: 8,
                                height: 8
                            },
                            children: [{
                                    tagName: 'defs',
                                    children: [{
                                            tagName: 'clipPath',
                                            attributes: {
                                                id
                                            },
                                            children: [{
                                                    tagName: 'rect',
                                                    attributes: {
                                                        width: 4,
                                                        height: 4
                                                    }
                                                }]
                                        }]
                                }, {
                                    tagName: 'rect',
                                    attributes: {
                                        id: 'hitme',
                                        width: 8,
                                        height: 8,
                                        'clip-path': `url(#${id})`,
                                        fill: 'rgba(0,0,0,0.001)'
                                    }
                                }]
                        }]);
                    const svg = ast.addToDOM(doc$1.body);
                    css$1(svg, {
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        zIndex: 9e5
                    });
                    const hitElement = doc$1.elementFromPoint(6, 6);
                    hasInternalReferenceBug = (hitElement && hitElement.id) === 'hitme';
                    doc$1.body.removeChild(svg);
                }
                if (hasInternalReferenceBug) {
                    // Scan alert #[72]: Loop for nested patterns
                    return replaceNested(win$1.location.href.split('#')[0], // Remove hash
                    [/<[^>]*>/g, ''], // Wing cut HTML
                    [/([\('\)])/g, '\\$1'], // Escape parantheses and quotes
                    [/ /g, '%20'] // Replace spaces (needed for Safari only)
                    );
                }
            }
            return '';
        }
        /**
         * Get the global style setting for the renderer.
         *
         * @private
         * @function Highcharts.SVGRenderer#getStyle
         *
         * @param {Highcharts.CSSObject} style
         * Style settings.
         *
         * @return {Highcharts.CSSObject}
         * The style settings mixed with defaults.
         */
        getStyle(style) {
            this.style = extend$2({
                fontFamily: 'Helvetica, Arial, sans-serif',
                fontSize: '1rem'
            }, style);
            return this.style;
        }
        /**
         * Apply the global style on the renderer, mixed with the default styles.
         *
         * @function Highcharts.SVGRenderer#setStyle
         *
         * @param {Highcharts.CSSObject} style
         * CSS to apply.
         */
        setStyle(style) {
            this.boxWrapper.css(this.getStyle(style));
        }
        /**
         * Detect whether the renderer is hidden. This happens when one of the
         * parent elements has `display: none`. Used internally to detect when we
         * need to render preliminarily in another div to get the text bounding
         * boxes right.
         *
         * @function Highcharts.SVGRenderer#isHidden
         *
         * @return {boolean}
         * True if it is hidden.
         */
        isHidden() {
            return !this.boxWrapper.getBBox().width;
        }
        /**
         * Destroys the renderer and its allocated members.
         *
         * @function Highcharts.SVGRenderer#destroy
         *
         * @return {null}
         * Pass through value.
         */
        destroy() {
            const renderer = this, rendererDefs = renderer.defs;
            renderer.box = null;
            renderer.boxWrapper = renderer.boxWrapper.destroy();
            // Call destroy on all gradient elements
            destroyObjectProperties(renderer.gradients || {});
            renderer.gradients = null;
            renderer.defs = rendererDefs.destroy();
            // Remove sub pixel fix handler (#982)
            if (renderer.unSubPixelFix) {
                renderer.unSubPixelFix();
            }
            renderer.alignedObjects = null;
            return null;
        }
        /**
         * Create a wrapper for an SVG element. Serves as a factory for
         * {@link SVGElement}, but this function is itself mostly called from
         * primitive factories like {@link SVGRenderer#path}, {@link
         * SVGRenderer#rect} or {@link SVGRenderer#text}.
         *
         * @function Highcharts.SVGRenderer#createElement
         *
         * @param {string} nodeName
         * The node name, for example `rect`, `g` etc.
         *
         * @return {Highcharts.SVGElement}
         * The generated SVGElement.
         */
        createElement(nodeName) {
            return new this.Element(this, nodeName);
        }
        /**
         * Get converted radial gradient attributes according to the radial
         * reference. Used internally from the {@link SVGElement#colorGradient}
         * function.
         *
         * @private
         * @function Highcharts.SVGRenderer#getRadialAttr
         */
        getRadialAttr(radialReference, gradAttr) {
            return {
                cx: (radialReference[0] - radialReference[2] / 2) +
                    (gradAttr.cx || 0) * radialReference[2],
                cy: (radialReference[1] - radialReference[2] / 2) +
                    (gradAttr.cy || 0) * radialReference[2],
                r: (gradAttr.r || 0) * radialReference[2]
            };
        }
        /**
         * Create a drop shadow definition and return its id
         *
         * @private
         * @function Highcharts.SVGRenderer#shadowDefinition
         *
         * @param {boolean|Highcharts.ShadowOptionsObject} [shadowOptions] The
         *        shadow options. If `true`, the default options are applied
         */
        shadowDefinition(shadowOptions) {
            const id = [
                `highcharts-drop-shadow-${this.chartIndex}`,
                ...Object.keys(shadowOptions)
                    .map((key) => `${key}-${shadowOptions[key]}`)
            ].join('-').toLowerCase().replace(/[^a-z\d\-]/g, ''), options = merge$2({
                color: '#000000',
                offsetX: 1,
                offsetY: 1,
                opacity: 0.15,
                width: 5
            }, shadowOptions);
            if (!this.defs.element.querySelector(`#${id}`)) {
                this.definition({
                    tagName: 'filter',
                    attributes: {
                        id,
                        filterUnits: options.filterUnits
                    },
                    children: this.getShadowFilterContent(options)
                });
            }
            return id;
        }
        /**
         * Get shadow filter content.
         * NOTE! Overridden in es5 module for IE11 compatibility.
         *
         * @private
         * @function Highcharts.SVGRenderer#getShadowFilterContent
         *
         * @param {ShadowOptionsObject} options
         * The shadow options.
         * @return {Array<AST.Node>}
         * The shadow filter content.
         */
        getShadowFilterContent(options) {
            return [{
                    tagName: 'feDropShadow',
                    attributes: {
                        dx: options.offsetX,
                        dy: options.offsetY,
                        'flood-color': options.color,
                        // Tuned and modified to keep a preserve compatibility
                        // with the old settings
                        'flood-opacity': Math.min(options.opacity * 5, 1),
                        stdDeviation: options.width / 2
                    }
                }];
        }
        /**
         * Parse a simple HTML string into SVG tspans. Called internally when text
         * is set on an SVGElement. The function supports a subset of HTML tags, CSS
         * text features like `width`, `text-overflow`, `white-space`, and also
         * attributes like `href` and `style`.
         *
         * @private
         * @function Highcharts.SVGRenderer#buildText
         *
         * @param {Highcharts.SVGElement} wrapper
         * The parent SVGElement.
         */
        buildText(wrapper) {
            new TextBuilder(wrapper).buildSVG();
        }
        /**
         * Returns white for dark colors and black for bright colors, based on W3C's
         * definition of [Relative luminance](
         * https://www.w3.org/WAI/GL/wiki/Relative_luminance).
         *
         * @function Highcharts.SVGRenderer#getContrast
         *
         * @param {Highcharts.ColorString} color
         * The color to get the contrast for.
         *
         * @return {Highcharts.ColorString}
         * The contrast color, either `#000000` or `#FFFFFF`.
         */
        getContrast(color) {
            // #6216, #17273
            const rgba = Color.parse(color).rgba
                .map((b8) => {
                const c = b8 / 255;
                return c <= 0.03928 ?
                    c / 12.92 :
                    Math.pow((c + 0.055) / 1.055, 2.4);
            });
            // Relative luminance
            const l = 0.2126 * rgba[0] + 0.7152 * rgba[1] + 0.0722 * rgba[2];
            // Use white or black based on which provides more contrast
            return 1.05 / (l + 0.05) > (l + 0.05) / 0.05 ? '#FFFFFF' : '#000000';
        }
        /**
         * Create a button with preset states. Styles for the button can either be
         * set as arguments, or a general theme for all buttons can be set by the
         * `global.buttonTheme` option.
         *
         * @function Highcharts.SVGRenderer#button
         *
         * @param {string} text
         * The text or HTML to draw.
         *
         * @param {number} x
         * The x position of the button's left side.
         *
         * @param {number} y
         * The y position of the button's top side.
         *
         * @param {Highcharts.EventCallbackFunction<Highcharts.SVGElement>} callback
         * The function to execute on button click or touch.
         *
         * @param {Highcharts.SVGAttributes} [theme]
         * SVG attributes for the normal state.
         *
         * @param {Highcharts.SVGAttributes} [hoverState]
         * SVG attributes for the hover state.
         *
         * @param {Highcharts.SVGAttributes} [selectState]
         * SVG attributes for the pressed state.
         *
         * @param {Highcharts.SVGAttributes} [disabledState]
         * SVG attributes for the disabled state.
         *
         * @param {Highcharts.SymbolKeyValue} [shape=rect]
         * The shape type.
         *
         * @param {boolean} [useHTML=false]
         * Whether to use HTML to render the label.
         *
         * @return {Highcharts.SVGElement}
         * The button element.
         */
        button(text, x, y, callback, theme = {}, hoverState, selectState, disabledState, shape, useHTML) {
            const label = this.label(text, x, y, shape, void 0, void 0, useHTML, void 0, 'button'), styledMode = this.styledMode, args = arguments;
            let curState = 0;
            theme = merge$2(defaultOptions$1.global.buttonTheme, theme);
            // @todo Consider moving this to a lower level, like .attr
            if (styledMode) {
                delete theme.fill;
                delete theme.stroke;
                delete theme['stroke-width'];
            }
            const states = theme.states || {}, normalStyle = theme.style || {};
            delete theme.states;
            delete theme.style;
            // Presentational
            const stateAttribs = [
                AST.filterUserAttributes(theme)
            ], 
            // The string type is a mistake, it is just for compliance with
            // SVGAttribute and is not used in button theme.
            stateStyles = [normalStyle];
            if (!styledMode) {
                ['hover', 'select', 'disabled'].forEach((stateName, i) => {
                    stateAttribs.push(merge$2(stateAttribs[0], AST.filterUserAttributes(args[i + 5] || states[stateName] || {})));
                    stateStyles.push(stateAttribs[i + 1].style);
                    delete stateAttribs[i + 1].style;
                });
            }
            // Add the events. IE9 and IE10 need mouseover and mouseout to function
            // (#667).
            addEvent$1(label.element, isMS ? 'mouseover' : 'mouseenter', function () {
                if (curState !== 3) {
                    label.setState(1);
                }
            });
            addEvent$1(label.element, isMS ? 'mouseout' : 'mouseleave', function () {
                if (curState !== 3) {
                    label.setState(curState);
                }
            });
            label.setState = (state = 0) => {
                // Hover state is temporary, don't record it
                if (state !== 1) {
                    label.state = curState = state;
                }
                // Update visuals
                label
                    .removeClass(/highcharts-button-(normal|hover|pressed|disabled)/)
                    .addClass('highcharts-button-' +
                    ['normal', 'hover', 'pressed', 'disabled'][state]);
                if (!styledMode) {
                    label.attr(stateAttribs[state]);
                    const css = stateStyles[state];
                    if (isObject$1(css)) {
                        label.css(css);
                    }
                }
            };
            label.attr(stateAttribs[0]);
            // Presentational attributes
            if (!styledMode) {
                label.css(extend$2({ cursor: 'default' }, normalStyle));
                // HTML labels don't need to handle pointer events because click and
                // mouseenter/mouseleave is bound to the underlying <g> element.
                // Should this be reconsidered, we need more complex logic to share
                // events between the <g> and its <div> counterpart, and avoid
                // triggering mouseenter/mouseleave when hovering from one to the
                // other (#17440).
                if (useHTML) {
                    label.text.css({ pointerEvents: 'none' });
                }
            }
            return label
                .on('touchstart', (e) => e.stopPropagation())
                .on('click', function (e) {
                if (curState !== 3) {
                    callback.call(label, e);
                }
            });
        }
        /**
         * Make a straight line crisper by not spilling out to neighbour pixels.
         *
         * @function Highcharts.SVGRenderer#crispLine
         *
         * @param {Highcharts.SVGPathArray} points
         *        The original points on the format `[['M', 0, 0], ['L', 100, 0]]`.
         *
         * @param {number} width
         *        The width of the line.
         *
         * @return {Highcharts.SVGPathArray}
         *         The original points array, but modified to render crisply.
         */
        crispLine(points, width) {
            const [start, end] = points;
            // Normalize to a crisp line
            if (defined$2(start[1]) && start[1] === end[1]) {
                start[1] = end[1] = crisp$1(start[1], width);
            }
            if (defined$2(start[2]) && start[2] === end[2]) {
                start[2] = end[2] = crisp$1(start[2], width);
            }
            return points;
        }
        /**
         * Draw a path, wraps the SVG `path` element.
         *
         * @sample highcharts/members/renderer-path-on-chart/
         *         Draw a path in a chart
         * @sample highcharts/members/renderer-path/
         *         Draw a path independent from a chart
         *
         * @example
         * let path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])
         *     .attr({ stroke: '#ff00ff' })
         *     .add();
         *
         * @function Highcharts.SVGRenderer#path
         *
         * @param {Highcharts.SVGPathArray} [path]
         * An SVG path definition in array form.
         *
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         *
         */ /**
        * Draw a path, wraps the SVG `path` element.
        *
        * @function Highcharts.SVGRenderer#path
        *
        * @param {Highcharts.SVGAttributes} [attribs]
        * The initial attributes.
        *
        * @return {Highcharts.SVGElement}
        * The generated wrapper element.
        */
        path(path) {
            const attribs = (this.styledMode ? {} : {
                fill: 'none'
            });
            if (isArray$2(path)) {
                attribs.d = path;
            }
            else if (isObject$1(path)) { // Attributes
                extend$2(attribs, path);
            }
            return this.createElement('path').attr(attribs);
        }
        /**
         * Draw a circle, wraps the SVG `circle` element.
         *
         * @sample highcharts/members/renderer-circle/
         *         Drawing a circle
         *
         * @function Highcharts.SVGRenderer#circle
         *
         * @param {number} [x]
         * The center x position.
         *
         * @param {number} [y]
         * The center y position.
         *
         * @param {number} [r]
         * The radius.
         *
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         */ /**
        * Draw a circle, wraps the SVG `circle` element.
        *
        * @function Highcharts.SVGRenderer#circle
        *
        * @param {Highcharts.SVGAttributes} [attribs]
        * The initial attributes.
        *
        * @return {Highcharts.SVGElement}
        * The generated wrapper element.
        */
        circle(x, y, r) {
            const attribs = (isObject$1(x) ?
                x :
                typeof x === 'undefined' ? {} : { x: x, y: y, r: r }), wrapper = this.createElement('circle');
            // Setting x or y translates to cx and cy
            wrapper.xSetter = wrapper.ySetter = function (value, key, element) {
                element.setAttribute('c' + key, value);
            };
            return wrapper.attr(attribs);
        }
        /**
         * Draw and return an arc.
         *
         * @sample highcharts/members/renderer-arc/
         *         Drawing an arc
         *
         * @function Highcharts.SVGRenderer#arc
         *
         * @param {number} [x=0]
         * Center X position.
         *
         * @param {number} [y=0]
         * Center Y position.
         *
         * @param {number} [r=0]
         * The outer radius' of the arc.
         *
         * @param {number} [innerR=0]
         * Inner radius like used in donut charts.
         *
         * @param {number} [start=0]
         * The starting angle of the arc in radians, where 0 is to the right and
         * `-Math.PI/2` is up.
         *
         * @param {number} [end=0]
         * The ending angle of the arc in radians, where 0 is to the right and
         * `-Math.PI/2` is up.
         *
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         */ /**
        * Draw and return an arc. Overloaded function that takes arguments object.
        *
        * @function Highcharts.SVGRenderer#arc
        *
        * @param {Highcharts.SVGAttributes} attribs
        * Initial SVG attributes.
        *
        * @return {Highcharts.SVGElement}
        * The generated wrapper element.
        */
        arc(x, y, r, innerR, start, end) {
            let options;
            if (isObject$1(x)) {
                options = x;
                y = options.y;
                r = options.r;
                innerR = options.innerR;
                start = options.start;
                end = options.end;
                x = options.x;
            }
            else {
                options = { innerR, start, end };
            }
            // Arcs are defined as symbols for the ability to set
            // attributes in attr and animate
            const arc = this.symbol('arc', x, y, r, r, options);
            arc.r = r; // #959
            return arc;
        }
        /**
         * Draw and return a rectangle.
         *
         * @function Highcharts.SVGRenderer#rect
         *
         * @param {number} [x]
         * Left position.
         *
         * @param {number} [y]
         * Top position.
         *
         * @param {number} [width]
         * Width of the rectangle.
         *
         * @param {number} [height]
         * Height of the rectangle.
         *
         * @param {number} [r]
         * Border corner radius.
         *
         * @param {number} [strokeWidth]
         * A stroke width can be supplied to allow crisp drawing.
         *
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         */ /**
        * Draw and return a rectangle.
        *
        * @sample highcharts/members/renderer-rect-on-chart/
        *         Draw a rectangle in a chart
        * @sample highcharts/members/renderer-rect/
        *         Draw a rectangle independent from a chart
        *
        * @function Highcharts.SVGRenderer#rect
        *
        * @param {Highcharts.SVGAttributes} [attributes]
        * General SVG attributes for the rectangle.
        *
        * @return {Highcharts.SVGElement}
        * The generated wrapper element.
        */
        rect(x, y, width, height, r, strokeWidth) {
            const attribs = (isObject$1(x) ?
                x :
                typeof x === 'undefined' ?
                    {} :
                    {
                        x,
                        y,
                        r,
                        width: Math.max(width || 0, 0),
                        height: Math.max(height || 0, 0)
                    }), wrapper = this.createElement('rect');
            if (!this.styledMode) {
                if (typeof strokeWidth !== 'undefined') {
                    attribs['stroke-width'] = strokeWidth;
                    extend$2(attribs, wrapper.crisp(attribs));
                }
                attribs.fill = 'none';
            }
            wrapper.rSetter = function (value, _key, element) {
                wrapper.r = value;
                attr$1(element, {
                    rx: value,
                    ry: value
                });
            };
            wrapper.rGetter = function () {
                return wrapper.r || 0;
            };
            return wrapper.attr(attribs);
        }
        /**
         * Draw and return a rectangle with advanced corner rounding options.
         *
         * @function Highcharts.SVGRenderer#roundedRect
         *
         * @param {Highcharts.SVGAttributes} attribs
         *      Attributes
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         */
        roundedRect(attribs) {
            return this.symbol('roundedRect').attr(attribs);
        }
        /**
         * Resize the {@link SVGRenderer#box} and re-align all aligned child
         * elements.
         *
         * @sample highcharts/members/renderer-g/
         *         Show and hide grouped objects
         *
         * @function Highcharts.SVGRenderer#setSize
         *
         * @param {number} width
         * The new pixel width.
         *
         * @param {number} height
         * The new pixel height.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animate=true]
         * Whether and how to animate.
         */
        setSize(width, height, animate) {
            const renderer = this;
            renderer.width = width;
            renderer.height = height;
            renderer.boxWrapper.animate({
                width: width,
                height: height
            }, {
                step: function () {
                    this.attr({
                        viewBox: '0 0 ' + this.attr('width') + ' ' +
                            this.attr('height')
                    });
                },
                duration: pick$2(animate, true) ? void 0 : 0
            });
            renderer.alignElements();
        }
        /**
         * Create and return an svg group element. Child
         * {@link Highcharts.SVGElement} objects are added to the group by using the
         * group as the first parameter in {@link Highcharts.SVGElement#add|add()}.
         *
         * @function Highcharts.SVGRenderer#g
         *
         * @param {string} [name]
         *        The group will be given a class name of `highcharts-{name}`. This
         *        can be used for styling and scripting.
         *
         * @return {Highcharts.SVGElement}
         *         The generated wrapper element.
         */
        g(name) {
            const elem = this.createElement('g');
            return name ?
                elem.attr({ 'class': 'highcharts-' + name }) :
                elem;
        }
        /**
         * Display an image.
         *
         * @sample highcharts/members/renderer-image-on-chart/
         *         Add an image in a chart
         * @sample highcharts/members/renderer-image/
         *         Add an image independent of a chart
         *
         * @function Highcharts.SVGRenderer#image
         *
         * @param {string} href
         *        The image source.
         *
         * @param {number} [x]
         *        The X position.
         *
         * @param {number} [y]
         *        The Y position.
         *
         * @param {number} [width]
         *        The image width. If omitted, it defaults to the image file width.
         *
         * @param {number} [height]
         *        The image height. If omitted it defaults to the image file
         *        height.
         *
         * @param {Function} [onload]
         *        Event handler for image load.
         *
         * @return {Highcharts.SVGElement}
         *         The generated wrapper element.
         */
        image(href, x, y, width, height, onload) {
            const attribs = { preserveAspectRatio: 'none' };
            // Optional properties (#11756)
            if (isNumber$2(x)) {
                attribs.x = x;
            }
            if (isNumber$2(y)) {
                attribs.y = y;
            }
            if (isNumber$2(width)) {
                attribs.width = width;
            }
            if (isNumber$2(height)) {
                attribs.height = height;
            }
            const elemWrapper = this.createElement('image').attr(attribs), onDummyLoad = function (e) {
                elemWrapper.attr({ href });
                onload.call(elemWrapper, e);
            };
            // Add load event if supplied
            if (onload) {
                // We have to use a dummy HTML image since IE support for SVG image
                // load events is very buggy. First set a transparent src, wait for
                // dummy to load, and then add the real src to the SVG image.
                elemWrapper.attr({
                    /* eslint-disable-next-line max-len */
                    href: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='
                });
                const dummy = new win$1.Image();
                addEvent$1(dummy, 'load', onDummyLoad);
                dummy.src = href;
                if (dummy.complete) {
                    onDummyLoad({});
                }
            }
            else {
                elemWrapper.attr({ href });
            }
            return elemWrapper;
        }
        /**
         * Draw a symbol out of pre-defined shape paths from
         * {@link SVGRenderer#symbols}.
         * It is used in Highcharts for point makers, which cake a `symbol` option,
         * and label and button backgrounds like in the tooltip and stock flags.
         *
         * @function Highcharts.SVGRenderer#symbol
         *
         * @param {string} symbol
         * The symbol name.
         *
         * @param {number} [x]
         * The X coordinate for the top left position.
         *
         * @param {number} [y]
         * The Y coordinate for the top left position.
         *
         * @param {number} [width]
         * The pixel width.
         *
         * @param {number} [height]
         * The pixel height.
         *
         * @param {Highcharts.SymbolOptionsObject} [options]
         * Additional options, depending on the actual symbol drawn.
         *
         * @return {Highcharts.SVGElement}
         * SVG symbol.
         */
        symbol(symbol, x, y, width, height, options) {
            const ren = this, imageRegex = /^url\((.*?)\)$/, isImage = imageRegex.test(symbol), sym = (!isImage && (this.symbols[symbol] ? symbol : 'circle')), 
            // Get the symbol definition function
            symbolFn = (sym && this.symbols[sym]);
            let obj, path, imageSrc, centerImage;
            if (symbolFn) {
                // Check if there's a path defined for this symbol
                if (typeof x === 'number') {
                    path = symbolFn.call(this.symbols, x || 0, y || 0, width || 0, height || 0, options);
                }
                obj = this.path(path);
                if (!ren.styledMode) {
                    obj.attr('fill', 'none');
                }
                // Expando properties for use in animate and attr
                extend$2(obj, {
                    symbolName: (sym || void 0),
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
                if (options) {
                    extend$2(obj, options);
                }
                // Image symbols
            }
            else if (isImage) {
                imageSrc = symbol.match(imageRegex)[1];
                // Create the image synchronously, add attribs async
                const img = obj = this.image(imageSrc);
                // The image width is not always the same as the symbol width. The
                // image may be centered within the symbol, as is the case when
                // image shapes are used as label backgrounds, for example in flags.
                img.imgwidth = pick$2(options && options.width, symbolSizes[imageSrc] && symbolSizes[imageSrc].width);
                img.imgheight = pick$2(options && options.height, symbolSizes[imageSrc] && symbolSizes[imageSrc].height);
                /**
                 * Set the size and position
                 */
                centerImage = (obj) => obj.attr({
                    width: obj.width,
                    height: obj.height
                });
                /**
                 * Width and height setters that take both the image's physical size
                 * and the label size into consideration, and translates the image
                 * to center within the label.
                 */
                ['width', 'height'].forEach((key) => {
                    img[`${key}Setter`] = function (value, key) {
                        this[key] = value;
                        const { alignByTranslate, element, width, height, imgwidth, imgheight } = this, imgSize = key === 'width' ? imgwidth : imgheight;
                        let scale = 1;
                        // Scale and center the image within its container. The name
                        // `backgroundSize` is taken from the CSS spec, but the
                        // value `within` is made up. Other possible values in the
                        // spec, `cover` and `contain`, can be implemented if
                        // needed.
                        if (options &&
                            options.backgroundSize === 'within' &&
                            width &&
                            height &&
                            imgwidth &&
                            imgheight) {
                            scale = Math.min(width / imgwidth, height / imgheight);
                            // Update both width and height to keep the ratio
                            // correct (#17315)
                            attr$1(element, {
                                width: Math.round(imgwidth * scale),
                                height: Math.round(imgheight * scale)
                            });
                        }
                        else if (element && imgSize) {
                            element.setAttribute(key, imgSize);
                        }
                        if (!alignByTranslate && imgwidth && imgheight) {
                            this.translate(((width || 0) - (imgwidth * scale)) / 2, ((height || 0) - (imgheight * scale)) / 2);
                        }
                    };
                });
                if (defined$2(x)) {
                    img.attr({
                        x: x,
                        y: y
                    });
                }
                img.isImg = true;
                img.symbolUrl = symbol;
                if (defined$2(img.imgwidth) && defined$2(img.imgheight)) {
                    centerImage(img);
                }
                else {
                    // Initialize image to be 0 size so export will still function
                    // if there's no cached sizes.
                    img.attr({ width: 0, height: 0 });
                    // Create a dummy JavaScript image to get the width and height.
                    createElement$1('img', {
                        onload: function () {
                            const chart = charts$1[ren.chartIndex];
                            // Special case for SVGs on IE11, the width is not
                            // accessible until the image is part of the DOM
                            // (#2854).
                            if (this.width === 0) {
                                css$1(this, {
                                    position: 'absolute',
                                    top: '-999em'
                                });
                                doc$1.body.appendChild(this);
                            }
                            // Center the image
                            symbolSizes[imageSrc] = {
                                width: this.width,
                                height: this.height
                            };
                            img.imgwidth = this.width;
                            img.imgheight = this.height;
                            if (img.element) {
                                centerImage(img);
                            }
                            // Clean up after #2854 workaround.
                            if (this.parentNode) {
                                this.parentNode.removeChild(this);
                            }
                            // Fire the load event when all external images are
                            // loaded
                            ren.imgCount--;
                            if (!ren.imgCount && chart && !chart.hasLoaded) {
                                chart.onload();
                            }
                        },
                        src: imageSrc
                    });
                    this.imgCount++;
                }
            }
            return obj;
        }
        /**
         * Define a clipping rectangle. The clipping rectangle is later applied
         * to {@link SVGElement} objects through the {@link SVGElement#clip}
         * function.
         *
         * This function is deprecated as of v11.2. Instead, use a regular shape
         * (`rect`, `path` etc), and the `SVGElement.clipTo` function.
         *
         * @example
         * let circle = renderer.circle(100, 100, 100)
         *     .attr({ fill: 'red' })
         *     .add();
         * let clipRect = renderer.clipRect(100, 100, 100, 100);
         *
         * // Leave only the lower right quarter visible
         * circle.clip(clipRect);
         *
         * @deprecated
         *
         * @function Highcharts.SVGRenderer#clipRect
         *
         * @param {number} [x]
         *
         * @param {number} [y]
         *
         * @param {number} [width]
         *
         * @param {number} [height]
         *
         * @return {Highcharts.ClipRectElement}
         *         A clipping rectangle.
         */
        clipRect(x, y, width, height) {
            return this.rect(x, y, width, height, 0);
        }
        /**
         * Draw text. The text can contain a subset of HTML, like spans and anchors
         * and some basic text styling of these. For more advanced features like
         * border and background, use {@link Highcharts.SVGRenderer#label} instead.
         * To update the text after render, run `text.attr({ text: 'New text' })`.
         *
         * @sample highcharts/members/renderer-text-on-chart/
         *         Annotate the chart freely
         * @sample highcharts/members/renderer-on-chart/
         *         Annotate with a border and in response to the data
         * @sample highcharts/members/renderer-text/
         *         Formatted text
         *
         * @function Highcharts.SVGRenderer#text
         *
         * @param {string} [str]
         * The text of (subset) HTML to draw.
         *
         * @param {number} [x]
         * The x position of the text's lower left corner.
         *
         * @param {number} [y]
         * The y position of the text's lower left corner.
         *
         * @param {boolean} [useHTML=false]
         * Use HTML to render the text.
         *
         * @return {Highcharts.SVGElement}
         * The text object.
         */
        text(str, x, y, useHTML) {
            const renderer = this, attribs = {};
            if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
                return renderer.html(str, x, y);
            }
            attribs.x = Math.round(x || 0); // X always needed for line-wrap logic
            if (y) {
                attribs.y = Math.round(y);
            }
            if (defined$2(str)) {
                attribs.text = str;
            }
            const wrapper = renderer.createElement('text').attr(attribs);
            if (!useHTML || (renderer.forExport && !renderer.allowHTML)) {
                wrapper.xSetter = function (value, key, element) {
                    const tspans = element.getElementsByTagName('tspan'), parentVal = element.getAttribute(key);
                    for (let i = 0, tspan; i < tspans.length; i++) {
                        tspan = tspans[i];
                        // If the x values are equal, the tspan represents a line
                        // break
                        if (tspan.getAttribute(key) === parentVal) {
                            tspan.setAttribute(key, value);
                        }
                    }
                    element.setAttribute(key, value);
                };
            }
            return wrapper;
        }
        /**
         * Utility to return the baseline offset and total line height from the font
         * size.
         *
         * @function Highcharts.SVGRenderer#fontMetrics
         *
         * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement|number} [element]
         *        The element to inspect for a current font size. If a number is
         *        given, it's used as a fall back for direct font size in pixels.
         *
         * @return {Highcharts.FontMetricsObject}
         *         The font metrics.
         */
        fontMetrics(element) {
            const f = pInt$1(SVGElement.prototype.getStyle.call(element, 'font-size') || 0);
            // Empirical values found by comparing font size and bounding box
            // height. Applies to the default font family.
            // https://jsfiddle.net/highcharts/7xvn7/
            const h = f < 24 ? f + 3 : Math.round(f * 1.2), b = Math.round(h * 0.8);
            return {
                // Line height
                h,
                // Baseline
                b,
                // Font size
                f
            };
        }
        /**
         * Correct X and Y positioning of a label for rotation (#1764).
         *
         * @private
         * @function Highcharts.SVGRenderer#rotCorr
         */
        rotCorr(baseline, rotation, alterY) {
            let y = baseline;
            if (rotation && alterY) {
                y = Math.max(y * Math.cos(rotation * deg2rad), 4);
            }
            return {
                x: (-baseline / 3) * Math.sin(rotation * deg2rad),
                y: y
            };
        }
        /**
         * Compatibility function to convert the legacy one-dimensional path array
         * into an array of segments.
         *
         * It is used in maps to parse the `path` option, and in SVGRenderer.dSetter
         * to support legacy paths from demos.
         *
         * @private
         * @function Highcharts.SVGRenderer#pathToSegments
         */
        pathToSegments(path) {
            const ret = [];
            const segment = [];
            const commandLength = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
            };
            // Short, non-typesafe parsing of the one-dimensional array. It splits
            // the path on any string. This is not type checked against the tuple
            // types, but is shorter, and doesn't require specific checks for any
            // command type in SVG.
            for (let i = 0; i < path.length; i++) {
                // Command skipped, repeat previous or insert L/l for M/m
                if (isString$1(segment[0]) &&
                    isNumber$2(path[i]) &&
                    segment.length === commandLength[(segment[0].toUpperCase())]) {
                    path.splice(i, 0, segment[0].replace('M', 'L').replace('m', 'l'));
                }
                // Split on string
                if (typeof path[i] === 'string') {
                    if (segment.length) {
                        ret.push(segment.slice(0));
                    }
                    segment.length = 0;
                }
                segment.push(path[i]);
            }
            ret.push(segment.slice(0));
            return ret;
            /*
            // Fully type-safe version where each tuple type is checked. The
            // downside is filesize and a lack of flexibility for unsupported
            // commands
            const ret: SVGPath = [],
                commands = {
                    A: 7,
                    C: 6,
                    H: 1,
                    L: 2,
                    M: 2,
                    Q: 4,
                    S: 4,
                    T: 2,
                    V: 1,
                    Z: 0
                };

            let i = 0,
                lastI = 0,
                lastCommand;

            while (i < path.length) {
                const item = path[i];

                let command;

                if (typeof item === 'string') {
                    command = item;
                    i += 1;
                } else {
                    command = lastCommand || 'M';
                }

                // Upper case
                const commandUC = command.toUpperCase();

                if (commandUC in commands) {

                    // No numeric parameters
                    if (command === 'Z' || command === 'z') {
                        ret.push([command]);

                    // One numeric parameter
                    } else {
                        const val0 = path[i];
                        if (typeof val0 === 'number') {

                            // Horizontal line to
                            if (command === 'H' || command === 'h') {
                                ret.push([command, val0]);
                                i += 1;

                            // Vertical line to
                            } else if (command === 'V' || command === 'v') {
                                ret.push([command, val0]);
                                i += 1;

                            // Two numeric parameters
                            } else {
                                const val1 = path[i + 1];
                                if (typeof val1 === 'number') {
                                    // lineTo
                                    if (command === 'L' || command === 'l') {
                                        ret.push([command, val0, val1]);
                                        i += 2;

                                    // moveTo
                                    } else if (command === 'M' || command === 'm') {
                                        ret.push([command, val0, val1]);
                                        i += 2;

                                    // Smooth quadratic bezier
                                    } else if (command === 'T' || command === 't') {
                                        ret.push([command, val0, val1]);
                                        i += 2;

                                    // Four numeric parameters
                                    } else {
                                        const val2 = path[i + 2],
                                            val3 = path[i + 3];
                                        if (
                                            typeof val2 === 'number' &&
                                            typeof val3 === 'number'
                                        ) {
                                            // Quadratic bezier to
                                            if (
                                                command === 'Q' ||
                                                command === 'q'
                                            ) {
                                                ret.push([
                                                    command,
                                                    val0,
                                                    val1,
                                                    val2,
                                                    val3
                                                ]);
                                                i += 4;

                                            // Smooth cubic bezier to
                                            } else if (
                                                command === 'S' ||
                                                command === 's'
                                            ) {
                                                ret.push([
                                                    command,
                                                    val0,
                                                    val1,
                                                    val2,
                                                    val3
                                                ]);
                                                i += 4;

                                            // Six numeric parameters
                                            } else {
                                                const val4 = path[i + 4],
                                                    val5 = path[i + 5];

                                                if (
                                                    typeof val4 === 'number' &&
                                                    typeof val5 === 'number'
                                                ) {
                                                    // Curve to
                                                    if (
                                                        command === 'C' ||
                                                        command === 'c'
                                                    ) {
                                                        ret.push([
                                                            command,
                                                            val0,
                                                            val1,
                                                            val2,
                                                            val3,
                                                            val4,
                                                            val5
                                                        ]);
                                                        i += 6;

                                                    // Seven numeric parameters
                                                    } else {
                                                        const val6 = path[i + 6];

                                                        // Arc to
                                                        if (
                                                            typeof val6 ===
                                                            'number' &&
                                                            (
                                                                command === 'A' ||
                                                                command === 'a'
                                                            )
                                                        ) {
                                                            ret.push([
                                                                command,
                                                                val0,
                                                                val1,
                                                                val2,
                                                                val3,
                                                                val4,
                                                                val5,
                                                                val6
                                                            ]);
                                                            i += 7;

                                                        }

                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                            }
                        }
                    }
                }

                // An unmarked command following a moveTo is a lineTo
                lastCommand = command === 'M' ? 'L' : command;

                if (i === lastI) {
                    break;
                }
                lastI = i;
            }
            return ret;
            */
        }
        /**
         * Draw a label, which is an extended text element with support for border
         * and background. Highcharts creates a `g` element with a text and a `path`
         * or `rect` inside, to make it behave somewhat like a HTML div. Border and
         * background are set through `stroke`, `stroke-width` and `fill` attributes
         * using the {@link Highcharts.SVGElement#attr|attr} method. To update the
         * text after render, run `label.attr({ text: 'New text' })`.
         *
         * @sample highcharts/members/renderer-label-on-chart/
         *         A label on the chart
         *
         * @function Highcharts.SVGRenderer#label
         *
         * @param {string} str
         *        The initial text string or (subset) HTML to render.
         *
         * @param {number} x
         *        The x position of the label's left side.
         *
         * @param {number} [y]
         *        The y position of the label's top side or baseline, depending on
         *        the `baseline` parameter.
         *
         * @param {string} [shape='rect']
         *        The shape of the label's border/background, if any. Defaults to
         *        `rect`. Other possible values are `callout` or other shapes
         *        defined in {@link Highcharts.SVGRenderer#symbols}.
         *
         * @param {number} [anchorX]
         *        In case the `shape` has a pointer, like a flag, this is the
         *        coordinates it should be pinned to.
         *
         * @param {number} [anchorY]
         *        In case the `shape` has a pointer, like a flag, this is the
         *        coordinates it should be pinned to.
         *
         * @param {boolean} [useHTML=false]
         *        Whether to use HTML to render the label.
         *
         * @param {boolean} [baseline=false]
         *        Whether to position the label relative to the text baseline,
         *        like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the
         *        upper border of the rectangle.
         *
         * @param {string} [className]
         *        Class name for the group.
         *
         * @return {Highcharts.SVGElement}
         *         The generated label.
         */
        label(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
            return new SVGLabel(this, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className);
        }
        /**
         * Re-align all aligned elements.
         *
         * @private
         * @function Highcharts.SVGRenderer#alignElements
         */
        alignElements() {
            this.alignedObjects.forEach((el) => el.align());
        }
    }
    extend$2(SVGRenderer.prototype, {
        /**
         * A pointer to the renderer's associated Element class.
         *
         * @name Highcharts.SVGRenderer#Element
         * @type {Highcharts.SVGElement}
         */
        Element: SVGElement,
        SVG_NS,
        /**
         * A collection of characters mapped to HTML entities. When `useHTML` on an
         * element is true, these entities will be rendered correctly by HTML. In
         * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
         * so for example `&lt;` will render as `<`.
         *
         * @example
         * // Add support for unescaping quotes
         * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
         *
         * @name Highcharts.SVGRenderer#escapes
         * @type {Highcharts.Dictionary<string>}
         */
        escapes: {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            "'": '&#39;', // eslint-disable-line quotes
            '"': '&quot;'
        },
        /**
         * An extendable collection of functions for defining symbol paths.
         *
         * @name Highcharts.SVGRenderer#symbols
         * @type {Highcharts.SymbolDictionary}
         */
        symbols: Symbols,
        /**
         * Dummy function for plugins, called every time the renderer is updated.
         * Prior to Highcharts 5, this was used for the canvg renderer.
         *
         * @deprecated
         * @function Highcharts.SVGRenderer#draw
         */
        draw: noop$1
    });
    /* *
     *
     *  Registry
     *
     * */
    RendererRegistry$1.registerRendererType('svg', SVGRenderer, true);

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animate, animObject: animObject$1, setAnimation } = animationExports;
    const { defaultOptions, defaultTime } = DefaultOptions;
    const { numberFormat } = Templating;
    const { registerEventOptions } = Foundation$1;
    const { charts, doc, marginNames, svg, win } = H;
    const { seriesTypes } = SeriesRegistry$1;
    const { addEvent, attr, createElement, css, defined: defined$1, diffObjects, discardElement, erase, error, extend: extend$1, find, fireEvent: fireEvent$1, getStyle, isArray: isArray$1, isNumber: isNumber$1, isObject, isString, merge: merge$1, objectEach: objectEach$1, pick: pick$1, pInt, relativeLength, removeEvent, splat, syncTimeout, uniqueKey } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * The Chart class. The recommended constructor is {@link Highcharts#chart}.
     *
     * @example
     * let chart = Highcharts.chart('container', {
     *        title: {
     *               text: 'My chart'
     *        },
     *        series: [{
     *            data: [1, 3, 2, 4]
     *        }]
     * })
     *
     * @class
     * @name Highcharts.Chart
     *
     * @param {string|Highcharts.HTMLDOMElement} [renderTo]
     *        The DOM element to render to, or its id.
     *
     * @param {Highcharts.Options} options
     *        The chart options structure.
     *
     * @param {Highcharts.ChartCallbackFunction} [callback]
     *        Function to run when the chart has loaded and all external images
     *        are loaded. Defining a
     *        [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)
     *        handler is equivalent.
     */
    class Chart {
        /**
         * Factory function for basic charts.
         *
         * @example
         * // Render a chart in to div#container
         * let chart = Highcharts.chart('container', {
         *     title: {
         *         text: 'My chart'
         *     },
         *     series: [{
         *         data: [1, 3, 2, 4]
         *     }]
         * });
         *
         * @function Highcharts.chart
         *
         * @param {string|Highcharts.HTMLDOMElement} [renderTo]
         * The DOM element to render to, or its id.
         *
         * @param {Highcharts.Options} options
         * The chart options structure.
         *
         * @param {Highcharts.ChartCallbackFunction} [callback]
         * Function to run when the chart has loaded and all external images are
         * loaded. Defining a
         * [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)
         * handler is equivalent.
         *
         * @return {Highcharts.Chart}
         * Returns the Chart object.
         */
        static chart(a, b, c) {
            return new Chart(a, b, c);
        }
        // Implementation
        constructor(a, 
        /* eslint-disable @typescript-eslint/no-unused-vars */
        b, c
        /* eslint-enable @typescript-eslint/no-unused-vars */
        ) {
            this.sharedClips = {};
            const args = [
                // ES5 builds fail unless we cast it to an Array
                ...arguments
            ];
            // Remove the optional first argument, renderTo, and set it on this.
            if (isString(a) || a.nodeName) {
                this.renderTo = args.shift();
            }
            this.init(args[0], args[1]);
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Function setting zoom options after chart init and after chart update.
         * Offers support for deprecated options.
         *
         * @private
         * @function Highcharts.Chart#setZoomOptions
         */
        setZoomOptions() {
            const chart = this, options = chart.options.chart, zooming = options.zooming;
            chart.zooming = {
                ...zooming,
                type: pick$1(options.zoomType, zooming.type),
                key: pick$1(options.zoomKey, zooming.key),
                pinchType: pick$1(options.pinchType, zooming.pinchType),
                singleTouch: pick$1(options.zoomBySingleTouch, zooming.singleTouch, false),
                resetButton: merge$1(zooming.resetButton, options.resetZoomButton)
            };
        }
        /**
         * Overridable function that initializes the chart. The constructor's
         * arguments are passed on directly.
         *
         * @function Highcharts.Chart#init
         *
         * @param {Highcharts.Options} userOptions
         *        Custom options.
         *
         * @param {Function} [callback]
         *        Function to run when the chart has loaded and all external
         *        images are loaded.
         *
         *
         * @emits Highcharts.Chart#event:init
         * @emits Highcharts.Chart#event:afterInit
         */
        init(userOptions, callback) {
            // Fire the event with a default function
            fireEvent$1(this, 'init', { args: arguments }, function () {
                const options = merge$1(defaultOptions, userOptions), // Do the merge
                optionsChart = options.chart;
                /**
                 * The original options given to the constructor or a chart factory
                 * like {@link Highcharts.chart} and {@link Highcharts.stockChart}.
                 * The original options are shallow copied to avoid mutation. The
                 * copy, `chart.userOptions`, may later be mutated to reflect
                 * updated options throughout the lifetime of the chart.
                 *
                 * For collections, like `series`, `xAxis` and `yAxis`, the chart
                 * user options should always be reflected by the item user option,
                 * so for example the following should always be true:
                 *
                 * `chart.xAxis[0].userOptions === chart.userOptions.xAxis[0]`
                 *
                 * @name Highcharts.Chart#userOptions
                 * @type {Highcharts.Options}
                 */
                this.userOptions = extend$1({}, userOptions);
                this.margin = [];
                this.spacing = [];
                // An array of functions that returns labels that should be
                // considered for anti-collision
                this.labelCollectors = [];
                this.callback = callback;
                this.isResizing = 0;
                /**
                 * The options structure for the chart after merging
                 * {@link #defaultOptions} and {@link #userOptions}. It contains
                 * members for the sub elements like series, legend, tooltip etc.
                 *
                 * @name Highcharts.Chart#options
                 * @type {Highcharts.Options}
                 */
                this.options = options;
                /**
                 * All the axes in the chart.
                 *
                 * @see  Highcharts.Chart.xAxis
                 * @see  Highcharts.Chart.yAxis
                 *
                 * @name Highcharts.Chart#axes
                 * @type {Array<Highcharts.Axis>}
                 */
                this.axes = [];
                /**
                 * All the current series in the chart.
                 *
                 * @name Highcharts.Chart#series
                 * @type {Array<Highcharts.Series>}
                 */
                this.series = [];
                /**
                 * The `Time` object associated with the chart. Since v6.0.5,
                 * time settings can be applied individually for each chart. If
                 * no individual settings apply, the `Time` object is shared by
                 * all instances.
                 *
                 * @name Highcharts.Chart#time
                 * @type {Highcharts.Time}
                 */
                this.time =
                    userOptions.time && Object.keys(userOptions.time).length ?
                        new Time(userOptions.time) :
                        H.time;
                /**
                 * Callback function to override the default function that formats
                 * all the numbers in the chart. Returns a string with the formatted
                 * number.
                 *
                 * @name Highcharts.Chart#numberFormatter
                 * @type {Highcharts.NumberFormatterCallbackFunction}
                 */
                this.numberFormatter = optionsChart.numberFormatter || numberFormat;
                /**
                 * Whether the chart is in styled mode, meaning all presentational
                 * attributes are avoided.
                 *
                 * @name Highcharts.Chart#styledMode
                 * @type {boolean}
                 */
                this.styledMode = optionsChart.styledMode;
                this.hasCartesianSeries = optionsChart.showAxes;
                const chart = this;
                /**
                 * Index position of the chart in the {@link Highcharts#charts}
                 * property.
                 *
                 * @name Highcharts.Chart#index
                 * @type {number}
                 * @readonly
                 */
                chart.index = charts.length; // Add the chart to the global lookup
                charts.push(chart);
                H.chartCount++;
                // Chart event handlers
                registerEventOptions(this, optionsChart);
                /**
                 * A collection of the X axes in the chart.
                 *
                 * @name Highcharts.Chart#xAxis
                 * @type {Array<Highcharts.Axis>}
                 */
                chart.xAxis = [];
                /**
                 * A collection of the Y axes in the chart.
                 *
                 * @name Highcharts.Chart#yAxis
                 * @type {Array<Highcharts.Axis>}
                 *
                 * @todo
                 * Make events official: Fire the event `afterInit`.
                 */
                chart.yAxis = [];
                chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
                this.setZoomOptions();
                // Fire after init but before first render, before axes and series
                // have been initialized.
                fireEvent$1(chart, 'afterInit');
                chart.firstRender();
            });
        }
        /**
         * Internal function to unitialize an individual series.
         *
         * @private
         * @function Highcharts.Chart#initSeries
         */
        initSeries(options) {
            const chart = this, optionsChart = chart.options.chart, type = (options.type ||
                optionsChart.type), SeriesClass = seriesTypes[type];
            // No such series type
            if (!SeriesClass) {
                error(17, true, chart, { missingModuleFor: type });
            }
            const series = new SeriesClass();
            if (typeof series.init === 'function') {
                series.init(chart, options);
            }
            return series;
        }
        /**
         * Internal function to set data for all series with enabled sorting.
         *
         * @private
         * @function Highcharts.Chart#setSortedData
         */
        setSortedData() {
            this.getSeriesOrderByLinks().forEach(function (series) {
                // We need to set data for series with sorting after series init
                if (!series.points && !series.data && series.enabledDataSorting) {
                    series.setData(series.options.data, false);
                }
            });
        }
        /**
         * Sort and return chart series in order depending on the number of linked
         * series.
         *
         * @private
         * @function Highcharts.Series#getSeriesOrderByLinks
         */
        getSeriesOrderByLinks() {
            return this.series.concat().sort(function (a, b) {
                if (a.linkedSeries.length || b.linkedSeries.length) {
                    return b.linkedSeries.length - a.linkedSeries.length;
                }
                return 0;
            });
        }
        /**
         * Order all series or axes above a given index. When series or axes are
         * added and ordered by configuration, only the last series is handled
         * (#248, #1123, #2456, #6112). This function is called on series and axis
         * initialization and destroy.
         *
         * @private
         * @function Highcharts.Chart#orderItems
         * @param {string} coll The collection name
         * @param {number} [fromIndex=0]
         * If this is given, only the series above this index are handled.
         */
        orderItems(coll, fromIndex = 0) {
            const collection = this[coll], 
            // Item options should be reflected in chart.options.series,
            // chart.options.yAxis etc
            optionsArray = this.options[coll] = splat(this.options[coll])
                .slice(), userOptionsArray = this.userOptions[coll] = this.userOptions[coll] ?
                splat(this.userOptions[coll]).slice() :
                [];
            if (this.hasRendered) {
                // Remove all above index
                optionsArray.splice(fromIndex);
                userOptionsArray.splice(fromIndex);
            }
            if (collection) {
                for (let i = fromIndex, iEnd = collection.length; i < iEnd; ++i) {
                    const item = collection[i];
                    if (item) {
                        /**
                         * Contains the series' index in the `Chart.series` array.
                         *
                         * @name Highcharts.Series#index
                         * @type {number}
                         * @readonly
                         */
                        item.index = i;
                        if (item instanceof Series) {
                            item.name = item.getName();
                        }
                        if (!item.options.isInternal) {
                            optionsArray[i] = item.options;
                            userOptionsArray[i] = item.userOptions;
                        }
                    }
                }
            }
        }
        /**
         * Check whether a given point is within the plot area.
         *
         * @function Highcharts.Chart#isInsidePlot
         *
         * @param {number} plotX
         * Pixel x relative to the plot area.
         *
         * @param {number} plotY
         * Pixel y relative to the plot area.
         *
         * @param {Highcharts.ChartIsInsideOptionsObject} [options]
         * Options object.
         *
         * @return {boolean}
         * Returns true if the given point is inside the plot area.
         */
        isInsidePlot(plotX, plotY, options = {}) {
            const { inverted, plotBox, plotLeft, plotTop, scrollablePlotBox } = this, { scrollLeft = 0, scrollTop = 0 } = (options.visiblePlotOnly &&
                this.scrollablePlotArea?.scrollingContainer) || {}, series = options.series, box = (options.visiblePlotOnly && scrollablePlotBox) || plotBox, x = options.inverted ? plotY : plotX, y = options.inverted ? plotX : plotY, e = {
                x,
                y,
                isInsidePlot: true,
                options
            };
            if (!options.ignoreX) {
                const xAxis = (series &&
                    (inverted && !this.polar ? series.yAxis : series.xAxis)) || {
                    pos: plotLeft,
                    len: Infinity
                };
                const chartX = options.paneCoordinates ?
                    xAxis.pos + x : plotLeft + x;
                if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis.pos) &&
                    chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis.pos + xAxis.len))) {
                    e.isInsidePlot = false;
                }
            }
            if (!options.ignoreY && e.isInsidePlot) {
                const yAxis = (!inverted && options.axis &&
                    !options.axis.isXAxis && options.axis) || (series && (inverted ? series.xAxis : series.yAxis)) || {
                    pos: plotTop,
                    len: Infinity
                };
                const chartY = options.paneCoordinates ?
                    yAxis.pos + y : plotTop + y;
                if (!(chartY >= Math.max(scrollTop + plotTop, yAxis.pos) &&
                    chartY <= Math.min(scrollTop + plotTop + box.height, yAxis.pos + yAxis.len))) {
                    e.isInsidePlot = false;
                }
            }
            fireEvent$1(this, 'afterIsInsidePlot', e);
            return e.isInsidePlot;
        }
        /**
         * Redraw the chart after changes have been done to the data, axis extremes
         * chart size or chart elements. All methods for updating axes, series or
         * points have a parameter for redrawing the chart. This is `true` by
         * default. But in many cases you want to do more than one operation on the
         * chart before redrawing, for example add a number of points. In those
         * cases it is a waste of resources to redraw the chart for each new point
         * added. So you add the points and call `chart.redraw()` after.
         *
         * @function Highcharts.Chart#redraw
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         * If or how to apply animation to the redraw. When `undefined`, it applies
         * the animation that is set in the `chart.animation` option.
         *
         * @emits Highcharts.Chart#event:afterSetExtremes
         * @emits Highcharts.Chart#event:beforeRedraw
         * @emits Highcharts.Chart#event:predraw
         * @emits Highcharts.Chart#event:redraw
         * @emits Highcharts.Chart#event:render
         * @emits Highcharts.Chart#event:updatedData
         */
        redraw(animation) {
            fireEvent$1(this, 'beforeRedraw');
            const chart = this, axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || [], series = chart.series, pointer = chart.pointer, legend = chart.legend, legendUserOptions = chart.userOptions.legend, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
            let hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
            renderer.rootFontSize = renderer.boxWrapper.getStyle('font-size');
            // Handle responsive rules, not only on resize (#6130)
            if (chart.setResponsive) {
                chart.setResponsive(false);
            }
            // Set the global animation. When chart.hasRendered is not true, the
            // redraw call comes from a responsive rule and animation should not
            // occur.
            setAnimation(chart.hasRendered ? animation : false, chart);
            if (isHiddenChart) {
                chart.temporaryDisplay();
            }
            // Adjust title layout (reflow multiline text)
            chart.layOutTitles(false);
            // Link stacked series
            i = series.length;
            while (i--) {
                serie = series[i];
                if (serie.options.stacking || serie.options.centerInCategory) {
                    hasStackedSeries = true;
                    if (serie.isDirty) {
                        hasDirtyStacks = true;
                        break;
                    }
                }
            }
            if (hasDirtyStacks) { // Mark others as dirty
                i = series.length;
                while (i--) {
                    serie = series[i];
                    if (serie.options.stacking) {
                        serie.isDirty = true;
                    }
                }
            }
            // Handle updated data in the series
            series.forEach(function (serie) {
                if (serie.isDirty) {
                    if (serie.options.legendType === 'point') {
                        if (typeof serie.updateTotals === 'function') {
                            serie.updateTotals();
                        }
                        redrawLegend = true;
                    }
                    else if (legendUserOptions &&
                        (!!legendUserOptions.labelFormatter ||
                            legendUserOptions.labelFormat)) {
                        redrawLegend = true; // #2165
                    }
                }
                if (serie.isDirtyData) {
                    fireEvent$1(serie, 'updatedData');
                }
            });
            // Handle added or removed series
            if (redrawLegend && legend && legend.options.enabled) {
                // Draw legend graphics
                legend.render();
                chart.isDirtyLegend = false;
            }
            // Reset stacks
            if (hasStackedSeries) {
                chart.getStacks();
            }
            // Set axes scales
            axes.forEach(function (axis) {
                axis.updateNames();
                axis.setScale();
            });
            chart.getMargins(); // #3098
            // If one axis is dirty, all axes must be redrawn (#792, #2169)
            axes.forEach(function (axis) {
                if (axis.isDirty) {
                    isDirtyBox = true;
                }
            });
            // Redraw axes
            axes.forEach(function (axis) {
                // Fire 'afterSetExtremes' only if extremes are set
                const key = axis.min + ',' + axis.max;
                if (axis.extKey !== key) { // #821, #4452
                    axis.extKey = key;
                    // Prevent a recursive call to chart.redraw() (#1119)
                    afterRedraw.push(function () {
                        fireEvent$1(axis, 'afterSetExtremes', extend$1(axis.eventArgs, axis.getExtremes())); // #747, #751
                        delete axis.eventArgs;
                    });
                }
                if (isDirtyBox || hasStackedSeries) {
                    axis.redraw();
                }
            });
            // The plot areas size has changed
            if (isDirtyBox) {
                chart.drawChartBox();
            }
            // Fire an event before redrawing series, used by the boost module to
            // clear previous series renderings.
            fireEvent$1(chart, 'predraw');
            // Redraw affected series
            series.forEach(function (serie) {
                if ((isDirtyBox || serie.isDirty) && serie.visible) {
                    serie.redraw();
                }
                // Set it here, otherwise we will have unlimited 'updatedData' calls
                // for a hidden series after setData(). Fixes #6012
                serie.isDirtyData = false;
            });
            // Move tooltip or reset
            if (pointer) {
                pointer.reset(true);
            }
            // Redraw if canvas
            renderer.draw();
            // Fire the events
            fireEvent$1(chart, 'redraw');
            fireEvent$1(chart, 'render');
            if (isHiddenChart) {
                chart.temporaryDisplay(true);
            }
            // Fire callbacks that are put on hold until after the redraw
            afterRedraw.forEach(function (callback) {
                callback.call();
            });
        }
        /**
         * Get an axis, series or point object by `id` as given in the configuration
         * options. Returns `undefined` if no item is found.
         *
         * @sample highcharts/plotoptions/series-id/
         *         Get series by id
         *
         * @function Highcharts.Chart#get
         *
         * @param {string} id
         * The id as given in the configuration options.
         *
         * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}
         * The retrieved item.
         */
        get(id) {
            const series = this.series;
            /**
             * @private
             */
            function itemById(item) {
                return (item.id === id ||
                    (item.options && item.options.id === id));
            }
            let ret = 
            // Search axes
            find(this.axes, itemById) ||
                // Search series
                find(this.series, itemById);
            // Search points
            for (let i = 0; !ret && i < series.length; i++) {
                ret = find(series[i].points || [], itemById);
            }
            return ret;
        }
        /**
         * Create the Axis instances based on the config options.
         *
         * @private
         * @function Highcharts.Chart#getAxes
         * @emits Highcharts.Chart#event:afterGetAxes
         * @emits Highcharts.Chart#event:getAxes
         */
        getAxes() {
            const options = this.userOptions;
            fireEvent$1(this, 'getAxes');
            for (const coll of ['xAxis', 'yAxis']) {
                const arr = options[coll] = splat(options[coll] || {});
                for (const axisOptions of arr) {
                    // eslint-disable-next-line no-new
                    new Axis(this, axisOptions, coll);
                }
            }
            fireEvent$1(this, 'afterGetAxes');
        }
        /**
         * Returns an array of all currently selected points in the chart. Points
         * can be selected by clicking or programmatically by the
         * {@link Highcharts.Point#select}
         * function.
         *
         * @sample highcharts/plotoptions/series-allowpointselect-line/
         *         Get selected points
         * @sample highcharts/members/point-select-lasso/
         *         Lasso selection
         * @sample highcharts/chart/events-selection-points/
         *         Rectangle selection
         *
         * @function Highcharts.Chart#getSelectedPoints
         *
         * @return {Array<Highcharts.Point>}
         *         The currently selected points.
         */
        getSelectedPoints() {
            return this.series.reduce((acc, series) => {
                // For one-to-one points inspect series.data in order to retrieve
                // points outside the visible range (#6445). For grouped data,
                // inspect the generated series.points.
                series.getPointsCollection()
                    .forEach((point) => {
                    if (pick$1(point.selectedStaging, point.selected)) {
                        acc.push(point);
                    }
                });
                return acc;
            }, []);
        }
        /**
         * Returns an array of all currently selected series in the chart. Series
         * can be selected either programmatically by the
         * {@link Highcharts.Series#select}
         * function or by checking the checkbox next to the legend item if
         * [series.showCheckBox](https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox)
         * is true.
         *
         * @sample highcharts/members/chart-getselectedseries/
         *         Get selected series
         *
         * @function Highcharts.Chart#getSelectedSeries
         *
         * @return {Array<Highcharts.Series>}
         *         The currently selected series.
         */
        getSelectedSeries() {
            return this.series.filter(function (serie) {
                return serie.selected;
            });
        }
        /**
         * Set a new title or subtitle for the chart.
         *
         * @sample highcharts/members/chart-settitle/
         *         Set title text and styles
         *
         * @function Highcharts.Chart#setTitle
         *
         * @param {Highcharts.TitleOptions} [titleOptions]
         *        New title options. The title text itself is set by the
         *        `titleOptions.text` property.
         *
         * @param {Highcharts.SubtitleOptions} [subtitleOptions]
         *        New subtitle options. The subtitle text itself is set by the
         *        `subtitleOptions.text` property.
         *
         * @param {boolean} [redraw]
         *        Whether to redraw the chart or wait for a later call to
         *        `chart.redraw()`.
         */
        setTitle(titleOptions, subtitleOptions, redraw) {
            this.applyDescription('title', titleOptions);
            this.applyDescription('subtitle', subtitleOptions);
            // The initial call also adds the caption. On update, chart.update will
            // relay to Chart.setCaption.
            this.applyDescription('caption', void 0);
            this.layOutTitles(redraw);
        }
        /**
         * Apply a title, subtitle or caption for the chart
         *
         * @private
         * @function Highcharts.Chart#applyDescription
         * @param name {string}
         * Either title, subtitle or caption
         * @param {Highcharts.TitleOptions|Highcharts.SubtitleOptions|Highcharts.CaptionOptions|undefined} explicitOptions
         * The options to set, will be merged with default options.
         */
        applyDescription(name, explicitOptions) {
            const chart = this;
            // Merge default options with explicit options
            const options = this.options[name] = merge$1(this.options[name], explicitOptions);
            let elem = this[name];
            if (elem && explicitOptions) {
                this[name] = elem = elem.destroy(); // Remove old
            }
            if (options && !elem) {
                elem = this.renderer.text(options.text, 0, 0, options.useHTML)
                    .attr({
                    align: options.align,
                    'class': 'highcharts-' + name,
                    zIndex: options.zIndex || 4
                })
                    .add();
                // Update methods, relay to `applyDescription`
                elem.update = function (updateOptions, redraw) {
                    chart.applyDescription(name, updateOptions);
                    chart.layOutTitles(redraw);
                };
                // Presentational
                if (!this.styledMode) {
                    elem.css(extend$1(name === 'title' ? {
                        // #2944
                        fontSize: this.options.isStock ? '1em' : '1.2em'
                    } : {}, options.style));
                }
                /**
                 * The chart title. The title has an `update` method that allows
                 * modifying the options directly or indirectly via
                 * `chart.update`.
                 *
                 * @sample highcharts/members/title-update/
                 *         Updating titles
                 *
                 * @name Highcharts.Chart#title
                 * @type {Highcharts.TitleObject}
                 */
                /**
                 * The chart subtitle. The subtitle has an `update` method that
                 * allows modifying the options directly or indirectly via
                 * `chart.update`.
                 *
                 * @name Highcharts.Chart#subtitle
                 * @type {Highcharts.SubtitleObject}
                 */
                this[name] = elem;
            }
        }
        /**
         * Internal function to lay out the chart title, subtitle and caption, and
         * cache the full offset height for use in `getMargins`. The result is
         * stored in `this.titleOffset`.
         *
         * @private
         * @function Highcharts.Chart#layOutTitles
         *
         * @param {boolean} [redraw=true]
         * @emits Highcharts.Chart#event:afterLayOutTitles
         */
        layOutTitles(redraw = true) {
            const titleOffset = [0, 0, 0], renderer = this.renderer, spacingBox = this.spacingBox;
            // Lay out the title and the subtitle respectively
            ['title', 'subtitle', 'caption'].forEach(function (key) {
                const title = this[key], titleOptions = (this.options[key]), verticalAlign = titleOptions.verticalAlign || 'top', offset = key === 'title' ?
                    verticalAlign === 'top' ? -3 : 0 :
                    // Floating subtitle (#6574)
                    verticalAlign === 'top' ? titleOffset[0] + 2 : 0;
                if (title) {
                    title
                        .css({
                        width: (titleOptions.width ||
                            spacingBox.width + (titleOptions.widthAdjust || 0)) + 'px'
                    });
                    const baseline = renderer.fontMetrics(title).b, 
                    // Skip the cache for HTML (#3481, #11666)
                    height = Math.round(title.getBBox(titleOptions.useHTML).height);
                    title.align(extend$1({
                        y: verticalAlign === 'bottom' ?
                            baseline :
                            offset + baseline,
                        height
                    }, titleOptions), false, 'spacingBox');
                    if (!titleOptions.floating) {
                        if (verticalAlign === 'top') {
                            titleOffset[0] = Math.ceil(titleOffset[0] +
                                height);
                        }
                        else if (verticalAlign === 'bottom') {
                            titleOffset[2] = Math.ceil(titleOffset[2] +
                                height);
                        }
                    }
                }
            }, this);
            // Handle title.margin and caption.margin
            if (titleOffset[0] &&
                (this.options.title.verticalAlign || 'top') === 'top') {
                titleOffset[0] += this.options.title.margin;
            }
            if (titleOffset[2] &&
                this.options.caption.verticalAlign === 'bottom') {
                titleOffset[2] += this.options.caption.margin;
            }
            const requiresDirtyBox = (!this.titleOffset ||
                this.titleOffset.join(',') !== titleOffset.join(','));
            // Used in getMargins
            this.titleOffset = titleOffset;
            fireEvent$1(this, 'afterLayOutTitles');
            if (!this.isDirtyBox && requiresDirtyBox) {
                this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
                // Redraw if necessary (#2719, #2744)
                if (this.hasRendered && redraw && this.isDirtyBox) {
                    this.redraw();
                }
            }
        }
        /**
         * Internal function to get the available size of the container element
         *
         * @private
         * @function Highcharts.Chart#getContainerBox
         */
        getContainerBox() {
            // Temporarily hide support divs from a11y and others, #21888
            const nonContainers = [].map.call(this.renderTo.children, (child) => {
                if (child !== this.container) {
                    const display = child.style.display;
                    child.style.display = 'none';
                    return [child, display];
                }
            }), box = {
                width: getStyle(this.renderTo, 'width', true) || 0,
                height: (getStyle(this.renderTo, 'height', true) || 0)
            };
            // Restore the non-containers
            nonContainers.filter(Boolean).forEach(([div, display]) => {
                div.style.display = display;
            });
            return box;
        }
        /**
         * Internal function to get the chart width and height according to options
         * and container size. Sets {@link Chart.chartWidth} and
         * {@link Chart.chartHeight}.
         *
         * @private
         * @function Highcharts.Chart#getChartSize
         */
        getChartSize() {
            const chart = this, optionsChart = chart.options.chart, widthOption = optionsChart.width, heightOption = optionsChart.height, containerBox = chart.getContainerBox(), enableDefaultHeight = containerBox.height > 1 &&
                !( // #21510, prevent infinite reflow
                !chart.renderTo.parentElement?.style.height &&
                    chart.renderTo.style.height === '100%');
            /**
             * The current pixel width of the chart.
             *
             * @name Highcharts.Chart#chartWidth
             * @type {number}
             */
            chart.chartWidth = Math.max(// #1393
            0, widthOption || containerBox.width || 600 // #1460
            );
            /**
             * The current pixel height of the chart.
             *
             * @name Highcharts.Chart#chartHeight
             * @type {number}
             */
            chart.chartHeight = Math.max(0, relativeLength(heightOption, chart.chartWidth) ||
                (enableDefaultHeight ? containerBox.height : 400));
            chart.containerBox = containerBox;
        }
        /**
         * If the renderTo element has no offsetWidth, most likely one or more of
         * its parents are hidden. Loop up the DOM tree to temporarily display the
         * parents, then save the original display properties, and when the true
         * size is retrieved, reset them. Used on first render and on redraws.
         *
         * @private
         * @function Highcharts.Chart#temporaryDisplay
         *
         * @param {boolean} [revert]
         * Revert to the saved original styles.
         */
        temporaryDisplay(revert) {
            let node = this.renderTo, tempStyle;
            if (!revert) {
                while (node && node.style) {
                    // When rendering to a detached node, it needs to be temporarily
                    // attached in order to read styling and bounding boxes (#5783,
                    // #7024).
                    if (!doc.body.contains(node) && !node.parentNode) {
                        node.hcOrigDetached = true;
                        doc.body.appendChild(node);
                    }
                    if (getStyle(node, 'display', false) === 'none' ||
                        node.hcOricDetached) {
                        node.hcOrigStyle = {
                            display: node.style.display,
                            height: node.style.height,
                            overflow: node.style.overflow
                        };
                        tempStyle = {
                            display: 'block',
                            overflow: 'hidden'
                        };
                        if (node !== this.renderTo) {
                            tempStyle.height = 0;
                        }
                        css(node, tempStyle);
                        // If it still doesn't have an offset width after setting
                        // display to block, it probably has an !important priority
                        // #2631, 6803
                        if (!node.offsetWidth) {
                            node.style.setProperty('display', 'block', 'important');
                        }
                    }
                    node = node.parentNode;
                    if (node === doc.body) {
                        break;
                    }
                }
            }
            else {
                while (node && node.style) {
                    if (node.hcOrigStyle) {
                        css(node, node.hcOrigStyle);
                        delete node.hcOrigStyle;
                    }
                    if (node.hcOrigDetached) {
                        doc.body.removeChild(node);
                        node.hcOrigDetached = false;
                    }
                    node = node.parentNode;
                }
            }
        }
        /**
         * Set the {@link Chart.container|chart container's} class name, in
         * addition to `highcharts-container`.
         *
         * @function Highcharts.Chart#setClassName
         *
         * @param {string} [className]
         * The additional class name.
         */
        setClassName(className) {
            this.container.className = 'highcharts-container ' + (className || '');
        }
        /**
         * Get the containing element, determine the size and create the inner
         * container div to hold the chart.
         *
         * @private
         * @function Highcharts.Chart#afterGetContainer
         * @emits Highcharts.Chart#event:afterGetContainer
         */
        getContainer() {
            const chart = this, options = chart.options, optionsChart = options.chart, indexAttrName = 'data-highcharts-chart', containerId = uniqueKey();
            let containerStyle, renderTo = chart.renderTo;
            if (!renderTo) {
                chart.renderTo = renderTo =
                    optionsChart.renderTo;
            }
            if (isString(renderTo)) {
                chart.renderTo = renderTo =
                    doc.getElementById(renderTo);
            }
            // Display an error if the renderTo is wrong
            if (!renderTo) {
                error(13, true, chart);
            }
            // If the container already holds a chart, destroy it. The check for
            // hasRendered is there because web pages that are saved to disk from
            // the browser, will preserve the data-highcharts-chart attribute and
            // the SVG contents, but not an interactive chart. So in this case,
            // charts[oldChartIndex] will point to the wrong chart if any (#2609).
            const oldChartIndex = pInt(attr(renderTo, indexAttrName));
            if (isNumber$1(oldChartIndex) &&
                charts[oldChartIndex] &&
                charts[oldChartIndex].hasRendered) {
                charts[oldChartIndex].destroy();
            }
            // Make a reference to the chart from the div
            attr(renderTo, indexAttrName, chart.index);
            // Remove previous chart
            renderTo.innerHTML = AST.emptyHTML;
            // If the container doesn't have an offsetWidth, it has or is a child of
            // a node that has display:none. We need to temporarily move it out to a
            // visible state to determine the size, else the legend and tooltips
            // won't render properly. The skipClone option is used in sparklines as
            // a micro optimization, saving about 1-2 ms each chart.
            if (!optionsChart.skipClone && !renderTo.offsetWidth) {
                chart.temporaryDisplay();
            }
            // Get the width and height
            chart.getChartSize();
            const chartHeight = chart.chartHeight;
            let chartWidth = chart.chartWidth;
            // Allow table cells and flex-boxes to shrink without the chart blocking
            // them out (#6427)
            css(renderTo, { overflow: 'hidden' });
            // Create the inner container
            if (!chart.styledMode) {
                containerStyle = extend$1({
                    position: 'relative',
                    // Needed for context menu (avoidscrollbars) and content
                    // overflow in IE
                    overflow: 'hidden',
                    width: chartWidth + 'px',
                    height: chartHeight + 'px',
                    textAlign: 'left',
                    lineHeight: 'normal', // #427
                    zIndex: 0, // #1072
                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
                    userSelect: 'none', // #13503
                    'touch-action': 'manipulation',
                    outline: 'none',
                    padding: '0px'
                }, optionsChart.style || {});
            }
            /**
             * The containing HTML element of the chart. The container is
             * dynamically inserted into the element given as the `renderTo`
             * parameter in the {@link Highcharts#chart} constructor.
             *
             * @name Highcharts.Chart#container
             * @type {Highcharts.HTMLDOMElement}
             */
            const container = createElement('div', {
                id: containerId
            }, containerStyle, renderTo);
            chart.container = container;
            // Adjust width if setting height affected it (#20334)
            chart.getChartSize();
            if (chartWidth !== chart.chartWidth) {
                chartWidth = chart.chartWidth;
                if (!chart.styledMode) {
                    css(container, {
                        width: pick$1(optionsChart.style?.width, chartWidth + 'px')
                    });
                }
            }
            chart.containerBox = chart.getContainerBox();
            // Cache the cursor (#1650)
            chart._cursor = container.style.cursor;
            // Initialize the renderer
            const Renderer = optionsChart.renderer || !svg ?
                RendererRegistry$1.getRendererType(optionsChart.renderer) :
                SVGRenderer;
            /**
             * The renderer instance of the chart. Each chart instance has only one
             * associated renderer.
             *
             * @name Highcharts.Chart#renderer
             * @type {Highcharts.SVGRenderer}
             */
            chart.renderer = new Renderer(container, chartWidth, chartHeight, void 0, optionsChart.forExport, options.exporting && options.exporting.allowHTML, chart.styledMode);
            // Set the initial animation from the options
            setAnimation(void 0, chart);
            chart.setClassName(optionsChart.className);
            if (!chart.styledMode) {
                chart.renderer.setStyle(optionsChart.style);
            }
            else {
                // Initialize definitions
                for (const key in options.defs) { // eslint-disable-line guard-for-in
                    this.renderer.definition(options.defs[key]);
                }
            }
            // Add a reference to the charts index
            chart.renderer.chartIndex = chart.index;
            fireEvent$1(this, 'afterGetContainer');
        }
        /**
         * Calculate margins by rendering axis labels in a preliminary position.
         * Title, subtitle and legend have already been rendered at this stage, but
         * will be moved into their final positions.
         *
         * @private
         * @function Highcharts.Chart#getMargins
         * @emits Highcharts.Chart#event:getMargins
         */
        getMargins(skipAxes) {
            const { spacing, margin, titleOffset } = this;
            this.resetMargins();
            // Adjust for title and subtitle
            if (titleOffset[0] && !defined$1(margin[0])) {
                this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0]);
            }
            if (titleOffset[2] && !defined$1(margin[2])) {
                this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2]);
            }
            // Adjust for legend
            if (this.legend && this.legend.display) {
                this.legend.adjustMargins(margin, spacing);
            }
            fireEvent$1(this, 'getMargins');
            if (!skipAxes) {
                this.getAxisMargins();
            }
        }
        /**
         * @private
         * @function Highcharts.Chart#getAxisMargins
         */
        getAxisMargins() {
            const chart = this, 
            // [top, right, bottom, left]
            axisOffset = chart.axisOffset = [0, 0, 0, 0], colorAxis = chart.colorAxis, margin = chart.margin, getOffset = function (axes) {
                axes.forEach(function (axis) {
                    if (axis.visible) {
                        axis.getOffset();
                    }
                });
            };
            // Pre-render axes to get labels offset width
            if (chart.hasCartesianSeries) {
                getOffset(chart.axes);
            }
            else if (colorAxis && colorAxis.length) {
                getOffset(colorAxis);
            }
            // Add the axis offsets
            marginNames.forEach(function (m, side) {
                if (!defined$1(margin[side])) {
                    chart[m] += axisOffset[side];
                }
            });
            chart.setChartSize();
        }
        /**
         * Return the current options of the chart, but only those that differ from
         * default options. Items that can be either an object or an array of
         * objects, like `series`, `xAxis` and `yAxis`, are always returned as
         * array.
         *
         * @sample highcharts/members/chart-getoptions
         *
         * @function Highcharts.Chart#getOptions
         *
         * @since 11.1.0
         */
        getOptions() {
            return diffObjects(this.userOptions, defaultOptions);
        }
        /**
         * Reflows the chart to its container. By default, the Resize Observer is
         * attached to the chart's div which allows to reflows the chart
         * automatically to its container, as per the
         * [chart.reflow](https://api.highcharts.com/highcharts/chart.reflow)
         * option.
         *
         * @sample highcharts/chart/events-container/
         *         Pop up and reflow
         *
         * @function Highcharts.Chart#reflow
         *
         * @param {global.Event} [e]
         *        Event arguments. Used primarily when the function is called
         *        internally as a response to window resize.
         */
        reflow(e) {
            const chart = this, oldBox = chart.containerBox, containerBox = chart.getContainerBox();
            delete chart.pointer?.chartPosition;
            // Width and height checks for display:none. Target is doc in Opera
            // and win in Firefox, Chrome and IE9.
            if (!chart.isPrinting &&
                !chart.isResizing &&
                oldBox &&
                // When fired by resize observer inside hidden container
                containerBox.width) {
                if (containerBox.width !== oldBox.width ||
                    containerBox.height !== oldBox.height) {
                    Utilities.clearTimeout(chart.reflowTimeout);
                    // When called from window.resize, e is set, else it's called
                    // directly (#2224)
                    chart.reflowTimeout = syncTimeout(function () {
                        // Set size, it may have been destroyed in the meantime
                        // (#1257)
                        if (chart.container) {
                            chart.setSize(void 0, void 0, false);
                        }
                    }, e ? 100 : 0);
                }
                chart.containerBox = containerBox;
            }
        }
        /**
         * Toggle the event handlers necessary for auto resizing, depending on the
         * `chart.reflow` option.
         *
         * @private
         * @function Highcharts.Chart#setReflow
         */
        setReflow() {
            const chart = this;
            const runReflow = (e) => {
                if (chart.options?.chart.reflow && chart.hasLoaded) {
                    chart.reflow(e);
                }
            };
            if (typeof ResizeObserver === 'function') {
                (new ResizeObserver(runReflow)).observe(chart.renderTo);
                // Fallback for more legacy browser versions.
            }
            else {
                const unbind = addEvent(win, 'resize', runReflow);
                addEvent(this, 'destroy', unbind);
            }
        }
        /**
         * Resize the chart to a given width and height. In order to set the width
         * only, the height argument may be skipped. To set the height only, pass
         * `undefined` for the width.
         *
         * @sample highcharts/members/chart-setsize-button/
         *         Test resizing from buttons
         * @sample highcharts/members/chart-setsize-jquery-resizable/
         *         Add a jQuery UI resizable
         * @sample stock/members/chart-setsize/
         *         Highcharts Stock with UI resizable
         *
         * @function Highcharts.Chart#setSize
         *
         * @param {number|null} [width]
         *        The new pixel width of the chart. Since v4.2.6, the argument can
         *        be `undefined` in order to preserve the current value (when
         *        setting height only), or `null` to adapt to the width of the
         *        containing element.
         *
         * @param {number|null} [height]
         *        The new pixel height of the chart. Since v4.2.6, the argument can
         *        be `undefined` in order to preserve the current value, or `null`
         *        in order to adapt to the height of the containing element.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether and how to apply animation. When `undefined`, it applies
         *        the animation that is set in the `chart.animation` option.
         *
         *
         * @emits Highcharts.Chart#event:endResize
         * @emits Highcharts.Chart#event:resize
         */
        setSize(width, height, animation) {
            const chart = this, renderer = chart.renderer;
            // Handle the isResizing counter
            chart.isResizing += 1;
            // Set the animation for the current process
            setAnimation(animation, chart);
            const globalAnimation = renderer.globalAnimation;
            chart.oldChartHeight = chart.chartHeight;
            chart.oldChartWidth = chart.chartWidth;
            if (typeof width !== 'undefined') {
                chart.options.chart.width = width;
            }
            if (typeof height !== 'undefined') {
                chart.options.chart.height = height;
            }
            chart.getChartSize();
            const { chartWidth, chartHeight, scrollablePixelsX = 0, scrollablePixelsY = 0 } = chart;
            // Avoid expensive redrawing if the computed size didn't change
            if (chart.isDirtyBox ||
                chartWidth !== chart.oldChartWidth ||
                chartHeight !== chart.oldChartHeight) {
                // Resize the container with the global animation applied if enabled
                // (#2503)
                if (!chart.styledMode) {
                    (globalAnimation ? animate : css)(chart.container, {
                        width: `${chartWidth + scrollablePixelsX}px`,
                        height: `${chartHeight + scrollablePixelsY}px`
                    }, globalAnimation);
                }
                chart.setChartSize(true);
                renderer.setSize(chartWidth, chartHeight, globalAnimation);
                // Handle axes
                chart.axes.forEach(function (axis) {
                    axis.isDirty = true;
                    axis.setScale();
                });
                chart.isDirtyLegend = true; // Force legend redraw
                chart.isDirtyBox = true; // Force redraw of plot and chart border
                chart.layOutTitles(); // #2857
                chart.getMargins();
                chart.redraw(globalAnimation);
                chart.oldChartHeight = void 0;
                fireEvent$1(chart, 'resize');
                // Fire endResize and set isResizing back. If animation is disabled,
                // fire without delay, but in a new thread to avoid triggering the
                // resize observer (#19027).
                setTimeout(() => {
                    if (chart) {
                        fireEvent$1(chart, 'endResize');
                    }
                }, animObject$1(globalAnimation).duration);
            }
            // Handle resizing counter even if we've re-rendered or not (#20548).
            chart.isResizing -= 1;
        }
        /**
         * Set the public chart properties. This is done before and after the
         * pre-render to determine margin sizes.
         *
         * @private
         * @function Highcharts.Chart#setChartSize
         * @emits Highcharts.Chart#event:afterSetChartSize
         */
        setChartSize(skipAxes) {
            const chart = this, { chartHeight, chartWidth, inverted, spacing, renderer } = chart, clipOffset = chart.clipOffset, clipRoundFunc = Math[inverted ? 'floor' : 'round'];
            let plotLeft, plotTop, plotWidth, plotHeight;
            /**
             * The current left position of the plot area in pixels.
             *
             * @name Highcharts.Chart#plotLeft
             * @type {number}
             */
            chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
            /**
             * The current top position of the plot area in pixels.
             *
             * @name Highcharts.Chart#plotTop
             * @type {number}
             */
            chart.plotTop = plotTop = Math.round(chart.plotTop);
            /**
             * The current width of the plot area in pixels.
             *
             * @name Highcharts.Chart#plotWidth
             * @type {number}
             */
            chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
            /**
             * The current height of the plot area in pixels.
             *
             * @name Highcharts.Chart#plotHeight
             * @type {number}
             */
            chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
            chart.plotSizeX = inverted ? plotHeight : plotWidth;
            chart.plotSizeY = inverted ? plotWidth : plotHeight;
            // Set boxes used for alignment
            chart.spacingBox = renderer.spacingBox = {
                x: spacing[3],
                y: spacing[0],
                width: chartWidth - spacing[3] - spacing[1],
                height: chartHeight - spacing[0] - spacing[2]
            };
            chart.plotBox = renderer.plotBox = {
                x: plotLeft,
                y: plotTop,
                width: plotWidth,
                height: plotHeight
            };
            // Compute the clipping box
            if (clipOffset) {
                chart.clipBox = {
                    x: clipRoundFunc(clipOffset[3]),
                    y: clipRoundFunc(clipOffset[0]),
                    width: clipRoundFunc(chart.plotSizeX - clipOffset[1] - clipOffset[3]),
                    height: clipRoundFunc(chart.plotSizeY - clipOffset[0] - clipOffset[2])
                };
            }
            if (!skipAxes) {
                chart.axes.forEach(function (axis) {
                    axis.setAxisSize();
                    axis.setAxisTranslation();
                });
                renderer.alignElements();
            }
            fireEvent$1(chart, 'afterSetChartSize', { skipAxes: skipAxes });
        }
        /**
         * Initial margins before auto size margins are applied.
         *
         * @private
         * @function Highcharts.Chart#resetMargins
         */
        resetMargins() {
            fireEvent$1(this, 'resetMargins');
            const chart = this, chartOptions = chart.options.chart, plotBorderWidth = chartOptions.plotBorderWidth || 0, halfWidth = plotBorderWidth / 2;
            // Create margin and spacing array
            ['margin', 'spacing'].forEach(function splashArrays(target) {
                const value = chartOptions[target], values = isObject(value) ? value : [value, value, value, value];
                [
                    'Top',
                    'Right',
                    'Bottom',
                    'Left'
                ].forEach(function (sideName, side) {
                    chart[target][side] = pick$1(chartOptions[target + sideName], values[side]);
                });
            });
            // Set margin names like chart.plotTop, chart.plotLeft,
            // chart.marginRight, chart.marginBottom.
            marginNames.forEach(function (m, side) {
                chart[m] = pick$1(chart.margin[side], chart.spacing[side]);
            });
            chart.axisOffset = [0, 0, 0, 0]; // Top, right, bottom, left
            chart.clipOffset = [
                halfWidth,
                halfWidth,
                halfWidth,
                halfWidth
            ];
            chart.plotBorderWidth = plotBorderWidth;
        }
        /**
         * Internal function to draw or redraw the borders and backgrounds for chart
         * and plot area.
         *
         * @private
         * @function Highcharts.Chart#drawChartBox
         * @emits Highcharts.Chart#event:afterDrawChartBox
         */
        drawChartBox() {
            const chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, styledMode = chart.styledMode, plotBGImage = chart.plotBGImage, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
            let chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, chartBorderWidth, mgn, bgAttr, verb = 'animate';
            // Chart area
            if (!chartBackground) {
                chart.chartBackground = chartBackground = renderer.rect()
                    .addClass('highcharts-background')
                    .add();
                verb = 'attr';
            }
            if (!styledMode) {
                // Presentational
                chartBorderWidth = optionsChart.borderWidth || 0;
                mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
                bgAttr = {
                    fill: chartBackgroundColor || 'none'
                };
                if (chartBorderWidth || chartBackground['stroke-width']) { // #980
                    bgAttr.stroke = optionsChart.borderColor;
                    bgAttr['stroke-width'] = chartBorderWidth;
                }
                chartBackground
                    .attr(bgAttr)
                    .shadow(optionsChart.shadow);
            }
            else {
                chartBorderWidth = mgn = chartBackground.strokeWidth();
            }
            chartBackground[verb]({
                x: mgn / 2,
                y: mgn / 2,
                width: chartWidth - mgn - chartBorderWidth % 2,
                height: chartHeight - mgn - chartBorderWidth % 2,
                r: optionsChart.borderRadius
            });
            // Plot background
            verb = 'animate';
            if (!plotBackground) {
                verb = 'attr';
                chart.plotBackground = plotBackground = renderer.rect()
                    .addClass('highcharts-plot-background')
                    .add();
            }
            plotBackground[verb](plotBox);
            if (!styledMode) {
                // Presentational attributes for the background
                plotBackground
                    .attr({
                    fill: plotBackgroundColor || 'none'
                })
                    .shadow(optionsChart.plotShadow);
                // Create the background image
                if (plotBackgroundImage) {
                    if (!plotBGImage) {
                        chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
                    }
                    else {
                        if (plotBackgroundImage !== plotBGImage.attr('href')) {
                            plotBGImage.attr('href', plotBackgroundImage);
                        }
                        plotBGImage.animate(plotBox);
                    }
                }
            }
            // Plot clip
            if (!clipRect) {
                chart.clipRect = renderer.clipRect(clipBox);
            }
            else {
                clipRect.animate({
                    width: clipBox.width,
                    height: clipBox.height
                });
            }
            // Plot area border
            verb = 'animate';
            if (!plotBorder) {
                verb = 'attr';
                chart.plotBorder = plotBorder = renderer.rect()
                    .addClass('highcharts-plot-border')
                    .attr({
                    zIndex: 1 // Above the grid
                })
                    .add();
            }
            if (!styledMode) {
                // Presentational
                plotBorder.attr({
                    stroke: optionsChart.plotBorderColor,
                    'stroke-width': optionsChart.plotBorderWidth || 0,
                    fill: 'none'
                });
            }
            plotBorder[verb](plotBorder.crisp({
                x: plotLeft,
                y: plotTop,
                width: plotWidth,
                height: plotHeight
            }, -plotBorder.strokeWidth())); // #3282 plotBorder should be negative;
            // reset
            chart.isDirtyBox = false;
            fireEvent$1(this, 'afterDrawChartBox');
        }
        /**
         * Detect whether a certain chart property is needed based on inspecting its
         * options and series. This mainly applies to the chart.inverted property,
         * and in extensions to the chart.angular and chart.polar properties.
         *
         * @private
         * @function Highcharts.Chart#propFromSeries
         */
        propFromSeries() {
            const chart = this, optionsChart = chart.options.chart, seriesOptions = chart.options.series;
            let i, klass, value;
            /**
             * The flag is set to `true` if a series of the chart is inverted.
             *
             * @name Highcharts.Chart#inverted
             * @type {boolean|undefined}
             */
            ['inverted', 'angular', 'polar'].forEach(function (key) {
                // The default series type's class
                klass = seriesTypes[optionsChart.type];
                // Get the value from available chart-wide properties
                value =
                    // It is set in the options:
                    optionsChart[key] ||
                        // The default series class:
                        (klass && klass.prototype[key]);
                // Requires it
                // 4. Check if any the chart's series require it
                i = seriesOptions && seriesOptions.length;
                while (!value && i--) {
                    klass = seriesTypes[seriesOptions[i].type];
                    if (klass && klass.prototype[key]) {
                        value = true;
                    }
                }
                // Set the chart property
                chart[key] = value;
            });
        }
        /**
         * Internal function to link two or more series together, based on the
         * `linkedTo` option. This is done from `Chart.render`, and after
         * `Chart.addSeries` and `Series.remove`.
         *
         * @private
         * @function Highcharts.Chart#linkSeries
         * @emits Highcharts.Chart#event:afterLinkSeries
         */
        linkSeries(isUpdating) {
            const chart = this, chartSeries = chart.series;
            // Reset links
            chartSeries.forEach(function (series) {
                series.linkedSeries.length = 0;
            });
            // Apply new links
            chartSeries.forEach(function (series) {
                const { linkedTo } = series.options;
                if (isString(linkedTo)) {
                    let linkedParent;
                    if (linkedTo === ':previous') {
                        linkedParent = chart.series[series.index - 1];
                    }
                    else {
                        linkedParent = chart.get(linkedTo);
                    }
                    // #3341 avoid mutual linking
                    if (linkedParent &&
                        linkedParent.linkedParent !== series) {
                        linkedParent.linkedSeries.push(series);
                        /**
                         * The parent series of the current series, if the current
                         * series has a [linkedTo](https://api.highcharts.com/highcharts/series.line.linkedTo)
                         * setting.
                         *
                         * @name Highcharts.Series#linkedParent
                         * @type {Highcharts.Series}
                         * @readonly
                         */
                        series.linkedParent = linkedParent;
                        if (linkedParent.enabledDataSorting) {
                            series.setDataSortingOptions();
                        }
                        series.visible = pick$1(series.options.visible, linkedParent.options.visible, series.visible); // #3879
                    }
                }
            });
            fireEvent$1(this, 'afterLinkSeries', { isUpdating });
        }
        /**
         * Render series for the chart.
         *
         * @private
         * @function Highcharts.Chart#renderSeries
         */
        renderSeries() {
            this.series.forEach(function (serie) {
                serie.translate();
                serie.render();
            });
        }
        /**
         * Render all graphics for the chart. Runs internally on initialization.
         *
         * @private
         * @function Highcharts.Chart#render
         */
        render() {
            const chart = this, axes = chart.axes, colorAxis = chart.colorAxis, renderer = chart.renderer, axisLayoutRuns = chart.options.chart.axisLayoutRuns || 2, renderAxes = (axes) => {
                axes.forEach((axis) => {
                    if (axis.visible) {
                        axis.render();
                    }
                });
            };
            let expectedSpace = 0, // Correction for X axis labels
            // If the plot area size has changed significantly, calculate tick
            // positions again
            redoHorizontal = true, redoVertical, run = 0;
            // Title
            chart.setTitle();
            // Fire an event before the margins are computed. This is where the
            // legend is assigned.
            fireEvent$1(chart, 'beforeMargins');
            // Get stacks
            chart.getStacks?.();
            // Get chart margins
            chart.getMargins(true);
            chart.setChartSize();
            for (const axis of axes) {
                const { options } = axis, { labels } = options;
                if (chart.hasCartesianSeries && // #20948
                    axis.horiz &&
                    axis.visible &&
                    labels.enabled &&
                    axis.series.length &&
                    axis.coll !== 'colorAxis' &&
                    !chart.polar) {
                    expectedSpace = options.tickLength;
                    axis.createGroups();
                    // Calculate expected space based on dummy tick
                    const mockTick = new Tick(axis, 0, '', true), label = mockTick.createLabel('x', labels);
                    mockTick.destroy();
                    if (label &&
                        pick$1(labels.reserveSpace, !isNumber$1(options.crossing))) {
                        expectedSpace = label.getBBox().height +
                            labels.distance +
                            Math.max(options.offset || 0, 0);
                    }
                    if (expectedSpace) {
                        label?.destroy();
                        break;
                    }
                }
            }
            // Use Math.max to prevent negative plotHeight
            chart.plotHeight = Math.max(chart.plotHeight - expectedSpace, 0);
            while ((redoHorizontal || redoVertical || axisLayoutRuns > 1) &&
                run < axisLayoutRuns // #19794
            ) {
                const tempWidth = chart.plotWidth, tempHeight = chart.plotHeight;
                for (const axis of axes) {
                    if (run === 0) {
                        // Get margins by pre-rendering axes
                        axis.setScale();
                    }
                    else if ((axis.horiz && redoHorizontal) ||
                        (!axis.horiz && redoVertical)) {
                        // Update to reflect the new margins
                        axis.setTickInterval(true);
                    }
                }
                if (run === 0) {
                    chart.getAxisMargins();
                }
                else {
                    // Check again for new, rotated or moved labels
                    chart.getMargins();
                }
                redoHorizontal = (tempWidth / chart.plotWidth) > (run ? 1 : 1.1);
                redoVertical = (tempHeight / chart.plotHeight) > (run ? 1 : 1.05);
                run++;
            }
            // Draw the borders and backgrounds
            chart.drawChartBox();
            // Axes
            if (chart.hasCartesianSeries) {
                renderAxes(axes);
            }
            else if (colorAxis && colorAxis.length) {
                renderAxes(colorAxis);
            }
            // The series
            if (!chart.seriesGroup) {
                chart.seriesGroup = renderer.g('series-group')
                    .attr({ zIndex: 3 })
                    .shadow(chart.options.chart.seriesGroupShadow)
                    .add();
            }
            chart.renderSeries();
            // Credits
            chart.addCredits();
            // Handle responsiveness
            if (chart.setResponsive) {
                chart.setResponsive();
            }
            // Set flag
            chart.hasRendered = true;
        }
        /**
         * Set a new credits label for the chart.
         *
         * @sample highcharts/credits/credits-update/
         *         Add and update credits
         *
         * @function Highcharts.Chart#addCredits
         *
         * @param {Highcharts.CreditsOptions} [credits]
         * A configuration object for the new credits.
         */
        addCredits(credits) {
            const chart = this, creds = merge$1(true, this.options.credits, credits);
            if (creds.enabled && !this.credits) {
                /**
                 * The chart's credits label. The label has an `update` method that
                 * allows setting new options as per the
                 * [credits options set](https://api.highcharts.com/highcharts/credits).
                 *
                 * @name Highcharts.Chart#credits
                 * @type {Highcharts.SVGElement}
                 */
                this.credits = this.renderer.text(creds.text + (this.mapCredits || ''), 0, 0)
                    .addClass('highcharts-credits')
                    .on('click', function () {
                    if (creds.href) {
                        win.location.href = creds.href;
                    }
                })
                    .attr({
                    align: creds.position.align,
                    zIndex: 8
                });
                if (!chart.styledMode) {
                    this.credits.css(creds.style);
                }
                this.credits
                    .add()
                    .align(creds.position);
                // Dynamically update
                this.credits.update = function (options) {
                    chart.credits = chart.credits.destroy();
                    chart.addCredits(options);
                };
            }
        }
        /**
         * Remove the chart and purge memory. This method is called internally
         * before adding a second chart into the same container, as well as on
         * window unload to prevent leaks.
         *
         * @sample highcharts/members/chart-destroy/
         *         Destroy the chart from a button
         * @sample stock/members/chart-destroy/
         *         Destroy with Highcharts Stock
         *
         * @function Highcharts.Chart#destroy
         *
         * @emits Highcharts.Chart#event:destroy
         */
        destroy() {
            const chart = this, axes = chart.axes, series = chart.series, container = chart.container, parentNode = container && container.parentNode;
            let i;
            // Fire the chart.destroy event
            fireEvent$1(chart, 'destroy');
            // Delete the chart from charts lookup array
            if (chart.renderer.forExport) {
                erase(charts, chart); // #6569
            }
            else {
                charts[chart.index] = void 0;
            }
            H.chartCount--;
            chart.renderTo.removeAttribute('data-highcharts-chart');
            // Remove events
            removeEvent(chart);
            // ==== Destroy collections:
            // Destroy axes
            i = axes.length;
            while (i--) {
                axes[i] = axes[i].destroy();
            }
            // Destroy scroller & scroller series before destroying base series
            if (this.scroller && this.scroller.destroy) {
                this.scroller.destroy();
            }
            // Destroy each series
            i = series.length;
            while (i--) {
                series[i] = series[i].destroy();
            }
            // ==== Destroy chart properties:
            [
                'title', 'subtitle', 'chartBackground', 'plotBackground',
                'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',
                'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',
                'renderer'
            ].forEach(function (name) {
                const prop = chart[name];
                if (prop && prop.destroy) {
                    chart[name] = prop.destroy();
                }
            });
            // Remove container and all SVG, check container as it can break in IE
            // when destroyed before finished loading
            if (container) {
                container.innerHTML = AST.emptyHTML;
                removeEvent(container);
                if (parentNode) {
                    discardElement(container);
                }
            }
            // Clean it all up
            objectEach$1(chart, function (val, key) {
                delete chart[key];
            });
        }
        /**
         * Prepare for first rendering after all data are loaded.
         *
         * @private
         * @function Highcharts.Chart#firstRender
         * @emits Highcharts.Chart#event:beforeRender
         */
        firstRender() {
            const chart = this, options = chart.options;
            // Create the container
            chart.getContainer();
            chart.resetMargins();
            chart.setChartSize();
            // Set the common chart properties (mainly invert) from the given series
            chart.propFromSeries();
            // Get axes
            chart.getAxes();
            // Initialize the series
            const series = isArray$1(options.series) ? options.series : [];
            options.series = []; // Avoid mutation
            series.forEach(
            // #9680
            function (serieOptions) {
                chart.initSeries(serieOptions);
            });
            chart.linkSeries();
            chart.setSortedData();
            // Run an event after axes and series are initialized, but before
            // render. At this stage, the series data is indexed and cached in the
            // xData and yData arrays, so we can access those before rendering. Used
            // in Highcharts Stock.
            fireEvent$1(chart, 'beforeRender');
            chart.render();
            chart.pointer?.getChartPosition(); // #14973
            // Fire the load event if there are no external images
            if (!chart.renderer.imgCount && !chart.hasLoaded) {
                chart.onload();
            }
            // If the chart was rendered outside the top container, put it back in
            // (#3679)
            chart.temporaryDisplay(true);
        }
        /**
         * Internal function that runs on chart load, async if any images are loaded
         * in the chart. Runs the callbacks and triggers the `load` and `render`
         * events.
         *
         * @private
         * @function Highcharts.Chart#onload
         * @emits Highcharts.Chart#event:load
         * @emits Highcharts.Chart#event:render
         */
        onload() {
            // Run callbacks, first the ones registered by modules, then user's one
            this.callbacks.concat([this.callback]).forEach(function (fn) {
                // Chart destroyed in its own callback (#3600)
                if (fn && typeof this.index !== 'undefined') {
                    fn.apply(this, [this]);
                }
            }, this);
            fireEvent$1(this, 'load');
            fireEvent$1(this, 'render');
            // Set up auto resize, check for not destroyed (#6068)
            if (defined$1(this.index)) {
                this.setReflow();
            }
            this.warnIfA11yModuleNotLoaded();
            // Don't run again
            this.hasLoaded = true;
        }
        /**
         * Emit console warning if the a11y module is not loaded.
         * @private
         */
        warnIfA11yModuleNotLoaded() {
            const { options, title } = this;
            if (options && !this.accessibility) {
                // Make chart behave as an image with the title as alt text
                this.renderer.boxWrapper.attr({
                    role: 'img',
                    'aria-label': ((title && title.element.textContent) || ''
                    // #17753, < is not allowed in SVG attributes
                    ).replace(/</g, '&lt;')
                });
                if (!(options.accessibility && options.accessibility.enabled === false)) {
                    error('Highcharts warning: Consider including the ' +
                        '"accessibility.js" module to make your chart more ' +
                        'usable for people with disabilities. Set the ' +
                        '"accessibility.enabled" option to false to remove this ' +
                        'warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this);
                }
            }
        }
        /**
         * Add a series to the chart after render time. Note that this method should
         * never be used when adding data synchronously at chart render time, as it
         * adds expense to the calculations and rendering. When adding data at the
         * same time as the chart is initialized, add the series as a configuration
         * option instead. With multiple axes, the `offset` is dynamically adjusted.
         *
         * @sample highcharts/members/chart-addseries/
         *         Add a series from a button
         * @sample stock/members/chart-addseries/
         *         Add a series in Highcharts Stock
         *
         * @function Highcharts.Chart#addSeries
         *
         * @param {Highcharts.SeriesOptionsType} options
         *        The config options for the series.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after adding.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether to apply animation, and optionally animation
         *        configuration. When `undefined`, it applies the animation that is
         *        set in the `chart.animation` option.
         *
         * @return {Highcharts.Series}
         *         The newly created series object.
         *
         * @emits Highcharts.Chart#event:addSeries
         * @emits Highcharts.Chart#event:afterAddSeries
         */
        addSeries(options, redraw, animation) {
            const chart = this;
            let series;
            if (options) { // <- not necessary
                redraw = pick$1(redraw, true); // Defaults to true
                fireEvent$1(chart, 'addSeries', { options: options }, function () {
                    series = chart.initSeries(options);
                    chart.isDirtyLegend = true;
                    chart.linkSeries();
                    if (series.enabledDataSorting) {
                        // We need to call `setData` after `linkSeries`
                        series.setData(options.data, false);
                    }
                    fireEvent$1(chart, 'afterAddSeries', { series: series });
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            }
            return series;
        }
        /**
         * Add an axis to the chart after render time. Note that this method should
         * never be used when adding data synchronously at chart render time, as it
         * adds expense to the calculations and rendering. When adding data at the
         * same time as the chart is initialized, add the axis as a configuration
         * option instead.
         *
         * @sample highcharts/members/chart-addaxis/
         *         Add and remove axes
         *
         * @function Highcharts.Chart#addAxis
         *
         * @param {Highcharts.AxisOptions} options
         *        The axis options.
         *
         * @param {boolean} [isX=false]
         *        Whether it is an X axis or a value axis.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after adding.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether and how to apply animation in the redraw. When
         *        `undefined`, it applies the animation that is set in the
         *        `chart.animation` option.
         *
         * @return {Highcharts.Axis}
         *         The newly generated Axis object.
         */
        addAxis(options, isX, redraw, animation) {
            return this.createAxis(isX ? 'xAxis' : 'yAxis', { axis: options, redraw: redraw, animation: animation });
        }
        /**
         * Add a color axis to the chart after render time. Note that this method
         * should never be used when adding data synchronously at chart render time,
         * as it adds expense to the calculations and rendering. When adding data at
         * the same time as the chart is initialized, add the axis as a
         * configuration option instead.
         *
         * @sample highcharts/members/chart-addaxis/
         *         Add and remove axes
         *
         * @function Highcharts.Chart#addColorAxis
         *
         * @param {Highcharts.ColorAxisOptions} options
         *        The axis options.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after adding.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether and how to apply animation in the redraw. When
         *        `undefined`, it applies the animation that is set in the
         *        `chart.animation` option.
         *
         * @return {Highcharts.Axis}
         *         The newly generated Axis object.
         */
        addColorAxis(options, redraw, animation) {
            return this.createAxis('colorAxis', { axis: options, redraw: redraw, animation: animation });
        }
        /**
         * Factory for creating different axis types.
         *
         * @private
         * @function Highcharts.Chart#createAxis
         *
         * @param {string} coll
         *        An axis type.
         *
         * @param {...Array<*>} arguments
         *        All arguments for the constructor.
         *
         * @return {Highcharts.Axis}
         *         The newly generated Axis object.
         */
        createAxis(coll, options) {
            const axis = new Axis(this, options.axis, coll);
            if (pick$1(options.redraw, true)) {
                this.redraw(options.animation);
            }
            return axis;
        }
        /**
         * Dim the chart and show a loading text or symbol. Options for the loading
         * screen are defined in {@link
         * https://api.highcharts.com/highcharts/loading|the loading options}.
         *
         * @sample highcharts/members/chart-hideloading/
         *         Show and hide loading from a button
         * @sample highcharts/members/chart-showloading/
         *         Apply different text labels
         * @sample stock/members/chart-show-hide-loading/
         *         Toggle loading in Highcharts Stock
         *
         * @function Highcharts.Chart#showLoading
         *
         * @param {string} [str]
         *        An optional text to show in the loading label instead of the
         *        default one. The default text is set in
         *        [lang.loading](https://api.highcharts.com/highcharts/lang.loading).
         */
        showLoading(str) {
            const chart = this, options = chart.options, loadingOptions = options.loading, setLoadingSize = function () {
                if (loadingDiv) {
                    css(loadingDiv, {
                        left: chart.plotLeft + 'px',
                        top: chart.plotTop + 'px',
                        width: chart.plotWidth + 'px',
                        height: chart.plotHeight + 'px'
                    });
                }
            };
            let loadingDiv = chart.loadingDiv, loadingSpan = chart.loadingSpan;
            // Create the layer at the first call
            if (!loadingDiv) {
                chart.loadingDiv = loadingDiv = createElement('div', {
                    className: 'highcharts-loading highcharts-loading-hidden'
                }, null, chart.container);
            }
            if (!loadingSpan) {
                chart.loadingSpan = loadingSpan = createElement('span', { className: 'highcharts-loading-inner' }, null, loadingDiv);
                addEvent(chart, 'redraw', setLoadingSize); // #1080
            }
            loadingDiv.className = 'highcharts-loading';
            // Update text
            AST.setElementHTML(loadingSpan, pick$1(str, options.lang.loading, ''));
            if (!chart.styledMode) {
                // Update visuals
                css(loadingDiv, extend$1(loadingOptions.style, {
                    zIndex: 10
                }));
                css(loadingSpan, loadingOptions.labelStyle);
                // Show it
                if (!chart.loadingShown) {
                    css(loadingDiv, {
                        opacity: 0,
                        display: ''
                    });
                    animate(loadingDiv, {
                        opacity: loadingOptions.style.opacity || 0.5
                    }, {
                        duration: loadingOptions.showDuration || 0
                    });
                }
            }
            chart.loadingShown = true;
            setLoadingSize();
        }
        /**
         * Hide the loading layer.
         *
         * @see Highcharts.Chart#showLoading
         *
         * @sample highcharts/members/chart-hideloading/
         *         Show and hide loading from a button
         * @sample stock/members/chart-show-hide-loading/
         *         Toggle loading in Highcharts Stock
         *
         * @function Highcharts.Chart#hideLoading
         */
        hideLoading() {
            const options = this.options, loadingDiv = this.loadingDiv;
            if (loadingDiv) {
                loadingDiv.className =
                    'highcharts-loading highcharts-loading-hidden';
                if (!this.styledMode) {
                    animate(loadingDiv, {
                        opacity: 0
                    }, {
                        duration: options.loading.hideDuration || 100,
                        complete: function () {
                            css(loadingDiv, { display: 'none' });
                        }
                    });
                }
            }
            this.loadingShown = false;
        }
        /**
         * A generic function to update any element of the chart. Elements can be
         * enabled and disabled, moved, re-styled, re-formatted etc.
         *
         * A special case is configuration objects that take arrays, for example
         * [xAxis](https://api.highcharts.com/highcharts/xAxis),
         * [yAxis](https://api.highcharts.com/highcharts/yAxis) or
         * [series](https://api.highcharts.com/highcharts/series). For these
         * collections, an `id` option is used to map the new option set to an
         * existing object. If an existing object of the same id is not found, the
         * corresponding item is updated. So for example, running `chart.update`
         * with a series item without an id, will cause the existing chart's series
         * with the same index in the series array to be updated. When the
         * `oneToOne` parameter is true, `chart.update` will also take care of
         * adding and removing items from the collection. Read more under the
         * parameter description below.
         *
         * Note that when changing series data, `chart.update` may mutate the passed
         * data options.
         *
         * See also the
         * [responsive option set](https://api.highcharts.com/highcharts/responsive).
         * Switching between `responsive.rules` basically runs `chart.update` under
         * the hood.
         *
         * @sample highcharts/members/chart-update/
         *         Update chart geometry
         *
         * @function Highcharts.Chart#update
         *
         * @param {Highcharts.Options} options
         *        A configuration object for the new chart options.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart.
         *
         * @param {boolean} [oneToOne=false]
         *        When `true`, the `series`, `xAxis`, `yAxis` and `annotations`
         *        collections will be updated one to one, and items will be either
         *        added or removed to match the new updated options. For example,
         *        if the chart has two series and we call `chart.update` with a
         *        configuration containing three series, one will be added. If we
         *        call `chart.update` with one series, one will be removed. Setting
         *        an empty `series` array will remove all series, but leaving out
         *        the`series` property will leave all series untouched. If the
         *        series have id's, the new series options will be matched by id,
         *        and the remaining ones removed.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether to apply animation, and optionally animation
         *        configuration. When `undefined`, it applies the animation that is
         *        set in the `chart.animation` option.
         *
         * @emits Highcharts.Chart#event:update
         * @emits Highcharts.Chart#event:afterUpdate
         */
        update(options, redraw, oneToOne, animation) {
            const chart = this, adders = {
                credits: 'addCredits',
                title: 'setTitle',
                subtitle: 'setSubtitle',
                caption: 'setCaption'
            }, isResponsiveOptions = options.isResponsiveOptions, itemsForRemoval = [];
            let updateAllAxes, updateAllSeries, runSetSize;
            fireEvent$1(chart, 'update', { options: options });
            // If there are responsive rules in action, undo the responsive rules
            // before we apply the updated options and replay the responsive rules
            // on top from the chart.redraw function (#9617).
            if (!isResponsiveOptions) {
                chart.setResponsive(false, true);
            }
            options = diffObjects(options, chart.options);
            chart.userOptions = merge$1(chart.userOptions, options);
            // If the top-level chart option is present, some special updates are
            // required
            const optionsChart = options.chart;
            if (optionsChart) {
                merge$1(true, chart.options.chart, optionsChart);
                // Add support for deprecated zooming options like zoomType, #17861
                this.setZoomOptions();
                // Setter function
                if ('className' in optionsChart) {
                    chart.setClassName(optionsChart.className);
                }
                if ('inverted' in optionsChart ||
                    'polar' in optionsChart ||
                    'type' in optionsChart) {
                    // Parse options.chart.inverted and options.chart.polar together
                    // with the available series.
                    chart.propFromSeries();
                    updateAllAxes = true;
                }
                if ('alignTicks' in optionsChart) { // #6452
                    updateAllAxes = true;
                }
                if ('events' in optionsChart) {
                    // Chart event handlers
                    registerEventOptions(this, optionsChart);
                }
                objectEach$1(optionsChart, function (val, key) {
                    if (chart.propsRequireUpdateSeries.indexOf('chart.' + key) !==
                        -1) {
                        updateAllSeries = true;
                    }
                    // Only dirty box
                    if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
                        chart.isDirtyBox = true;
                    }
                    // Chart setSize
                    if (chart.propsRequireReflow.indexOf(key) !== -1) {
                        chart.isDirtyBox = true;
                        if (!isResponsiveOptions) {
                            runSetSize = true;
                        }
                    }
                });
                if (!chart.styledMode && optionsChart.style) {
                    chart.renderer.setStyle(chart.options.chart.style || {});
                }
            }
            // Moved up, because tooltip needs updated plotOptions (#6218)
            if (!chart.styledMode && options.colors) {
                this.options.colors = options.colors;
            }
            if (options.time) {
                // Maintaining legacy global time. If the chart is instantiated
                // first with global time, then updated with time options, we need
                // to create a new Time instance to avoid mutating the global time
                // (#10536).
                if (this.time === defaultTime) {
                    this.time = new Time(options.time);
                }
                // If we're updating, the time class is different from other chart
                // classes (chart.legend, chart.tooltip etc) in that it doesn't know
                // about the chart. The other chart[something].update functions also
                // set the chart.options[something]. For the time class however we
                // need to update the chart options separately. #14230.
                merge$1(true, chart.options.time, options.time);
            }
            // Some option structures correspond one-to-one to chart objects that
            // have update methods, for example
            // options.credits => chart.credits
            // options.legend => chart.legend
            // options.title => chart.title
            // options.tooltip => chart.tooltip
            // options.subtitle => chart.subtitle
            // options.mapNavigation => chart.mapNavigation
            // options.navigator => chart.navigator
            // options.scrollbar => chart.scrollbar
            objectEach$1(options, function (val, key) {
                if (chart[key] &&
                    typeof chart[key].update === 'function') {
                    chart[key].update(val, false);
                    // If a one-to-one object does not exist, look for an adder function
                }
                else if (typeof chart[adders[key]] === 'function') {
                    chart[adders[key]](val);
                    // Else, just merge the options. For nodes like loading, noData,
                    // plotOptions
                }
                else if (key !== 'colors' &&
                    chart.collectionsWithUpdate.indexOf(key) === -1) {
                    merge$1(true, chart.options[key], options[key]);
                }
                if (key !== 'chart' &&
                    chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
                    updateAllSeries = true;
                }
            });
            // Setters for collections. For axes and series, each item is referred
            // by an id. If the id is not found, it defaults to the corresponding
            // item in the collection, so setting one series without an id, will
            // update the first series in the chart. Setting two series without
            // an id will update the first and the second respectively (#6019)
            // chart.update and responsive.
            this.collectionsWithUpdate.forEach(function (coll) {
                if (options[coll]) {
                    splat(options[coll]).forEach(function (newOptions, i) {
                        const hasId = defined$1(newOptions.id);
                        let item;
                        // Match by id
                        if (hasId) {
                            item = chart.get(newOptions.id);
                        }
                        // No match by id found, match by index instead
                        if (!item && chart[coll]) {
                            item = chart[coll][pick$1(newOptions.index, i)];
                            // Check if we grabbed an item with an existing but
                            // different id (#13541). Check that the item in this
                            // position is not internal (navigator).
                            if (item && ((hasId && defined$1(item.options.id)) ||
                                item.options.isInternal)) {
                                item = void 0;
                            }
                        }
                        if (item && item.coll === coll) {
                            item.update(newOptions, false);
                            if (oneToOne) {
                                item.touched = true;
                            }
                        }
                        // If oneToOne and no matching item is found, add one
                        if (!item && oneToOne && chart.collectionsWithInit[coll]) {
                            chart.collectionsWithInit[coll][0].apply(chart, 
                            // [newOptions, ...extraArguments, redraw=false]
                            [
                                newOptions
                            ].concat(
                            // Not all initializers require extra args
                            chart.collectionsWithInit[coll][1] || []).concat([
                                false
                            ])).touched = true;
                        }
                    });
                    // Add items for removal
                    if (oneToOne) {
                        chart[coll].forEach(function (item) {
                            if (!item.touched && !item.options.isInternal) {
                                itemsForRemoval.push(item);
                            }
                            else {
                                delete item.touched;
                            }
                        });
                    }
                }
            });
            itemsForRemoval.forEach(function (item) {
                if (item.chart && item.remove) { // #9097, avoid removing twice
                    item.remove(false);
                }
            });
            if (updateAllAxes) {
                chart.axes.forEach(function (axis) {
                    axis.update({}, false);
                });
            }
            // Certain options require the whole series structure to be thrown away
            // and rebuilt
            if (updateAllSeries) {
                chart.getSeriesOrderByLinks().forEach(function (series) {
                    // Avoid removed navigator series
                    if (series.chart) {
                        series.update({}, false);
                    }
                }, this);
            }
            // Update size. Redraw is forced.
            const newWidth = optionsChart && optionsChart.width;
            const newHeight = optionsChart && (isString(optionsChart.height) ?
                relativeLength(optionsChart.height, newWidth || chart.chartWidth) :
                optionsChart.height);
            if (
            // In this case, run chart.setSize with newWidth and newHeight which
            // are undefined, only for reflowing chart elements because margin
            // or spacing has been set (#8190)
            runSetSize ||
                // In this case, the size is actually set
                (isNumber$1(newWidth) && newWidth !== chart.chartWidth) ||
                (isNumber$1(newHeight) && newHeight !== chart.chartHeight)) {
                chart.setSize(newWidth, newHeight, animation);
            }
            else if (pick$1(redraw, true)) {
                chart.redraw(animation);
            }
            fireEvent$1(chart, 'afterUpdate', {
                options: options,
                redraw: redraw,
                animation: animation
            });
        }
        /**
         * Shortcut to set the subtitle options. This can also be done from {@link
         * Chart#update} or {@link Chart#setTitle}.
         *
         * @function Highcharts.Chart#setSubtitle
         *
         * @param {Highcharts.SubtitleOptions} options
         *        New subtitle options. The subtitle text itself is set by the
         *        `options.text` property.
         */
        setSubtitle(options, redraw) {
            this.applyDescription('subtitle', options);
            this.layOutTitles(redraw);
        }
        /**
         * Set the caption options. This can also be done from {@link
         * Chart#update}.
         *
         * @function Highcharts.Chart#setCaption
         *
         * @param {Highcharts.CaptionOptions} options
         *        New caption options. The caption text itself is set by the
         *        `options.text` property.
         */
        setCaption(options, redraw) {
            this.applyDescription('caption', options);
            this.layOutTitles(redraw);
        }
        /**
         * Display the zoom button, so users can reset zoom to the default view
         * settings.
         *
         * @function Highcharts.Chart#showResetZoom
         *
         * @emits Highcharts.Chart#event:afterShowResetZoom
         * @emits Highcharts.Chart#event:beforeShowResetZoom
         */
        showResetZoom() {
            const chart = this, lang = defaultOptions.lang, btnOptions = chart.zooming.resetButton, theme = btnOptions.theme, alignTo = (btnOptions.relativeTo === 'chart' ||
                btnOptions.relativeTo === 'spacingBox' ?
                null :
                'plotBox');
            /**
             * @private
             */
            function zoomOut() {
                chart.zoomOut();
            }
            fireEvent$1(this, 'beforeShowResetZoom', null, function () {
                chart.resetZoomButton = chart.renderer
                    .button(lang.resetZoom, null, null, zoomOut, theme)
                    .attr({
                    align: btnOptions.position.align,
                    title: lang.resetZoomTitle
                })
                    .addClass('highcharts-reset-zoom')
                    .add()
                    .align(btnOptions.position, false, alignTo);
            });
            fireEvent$1(this, 'afterShowResetZoom');
        }
        /**
         * Zoom the chart out after a user has zoomed in. See also
         * [Axis.setExtremes](/class-reference/Highcharts.Axis#setExtremes).
         *
         * @function Highcharts.Chart#zoomOut
         *
         * @emits Highcharts.Chart#event:selection
         */
        zoomOut() {
            fireEvent$1(this, 'selection', { resetSelection: true }, () => this.transform({ reset: true, trigger: 'zoom' }));
        }
        /**
         * Pan the chart by dragging the mouse across the pane. This function is
         * called on mouse move, and the distance to pan is computed from chartX
         * compared to the first chartX position in the dragging operation.
         *
         * @private
         * @function Highcharts.Chart#pan
         * @param {Highcharts.PointerEventObject} event
         * @param {string} panning
         */
        pan(event, panning) {
            const chart = this, panningOptions = (typeof panning === 'object' ?
                panning :
                {
                    enabled: panning,
                    type: 'x'
                }), type = panningOptions.type, axes = type && chart[{
                x: 'xAxis',
                xy: 'axes',
                y: 'yAxis'
            }[type]]
                .filter((axis) => axis.options.panningEnabled && !axis.options.isInternal), chartOptions = chart.options.chart;
            if (chartOptions?.panning) {
                chartOptions.panning = panningOptions;
            }
            fireEvent$1(this, 'pan', { originalEvent: event }, () => {
                chart.transform({
                    axes,
                    event,
                    to: {
                        x: event.chartX - (chart.mouseDownX || 0),
                        y: event.chartY - (chart.mouseDownY || 0)
                    },
                    trigger: 'pan'
                });
                css(chart.container, { cursor: 'move' });
            });
        }
        /**
         * Pan and scale the chart. Used internally by mouse-pan, touch-pan,
         * touch-zoom, and mousewheel zoom.
         *
         * The main positioning logic is created around two imaginary boxes. What is
         * currently within the `from` rectangle, should be transformed to fill up
         * the `to` rectangle.
         * - In a mouse zoom, the `from` rectangle is the selection, while the `to`
         *   rectangle is the full plot area.
         * - In a touch zoom, the `from` rectangle is made up of the last two-finger
         *   touch, while the `to`` rectangle is the current touch.
         * - In a mousewheel zoom, the `to` rectangle is a 10x10 px square,
         *   while the `to` rectangle reflects the scale around that.
         *
         * @private
         * @function Highcharts.Chart#transform
         */
        transform(params) {
            const { axes = this.axes, event, from = {}, reset, selection, to = {}, trigger } = params, { inverted } = this;
            let hasZoomed = false, displayButton, isAnyAxisPanning;
            // Remove active points for shared tooltip
            this.hoverPoints?.forEach((point) => point.setState());
            for (const axis of axes) {
                const { horiz, len, minPointOffset = 0, options, reversed } = axis, wh = horiz ? 'width' : 'height', xy = horiz ? 'x' : 'y', toLength = pick$1(to[wh], axis.len), fromLength = pick$1(from[wh], axis.len), 
                // If fingers pinched very close on this axis, treat as pan
                scale = Math.abs(toLength) < 10 ?
                    1 :
                    toLength / fromLength, fromCenter = (from[xy] || 0) + fromLength / 2 - axis.pos, toCenter = (to[xy] ?? axis.pos) +
                    toLength / 2 - axis.pos, move = fromCenter - toCenter / scale, pointRangeDirection = (reversed && !inverted) ||
                    (!reversed && inverted) ?
                    -1 :
                    1, minPx = move;
                // Zooming in multiple panes, zoom only in the pane that receives
                // the input
                if (!reset && (fromCenter < 0 || fromCenter > axis.len)) {
                    continue;
                }
                let newMin = axis.toValue(minPx, true) +
                    // Don't apply offset for selection (#20784)
                    (selection || axis.isOrdinal ?
                        0 : minPointOffset * pointRangeDirection), newMax = axis.toValue(minPx + len / scale, true) -
                    (
                    // Don't apply offset for selection (#20784)
                    selection || axis.isOrdinal ?
                        0 :
                        ((minPointOffset * pointRangeDirection) ||
                            // Polar zoom tests failed when this was not
                            // commented:
                            // (axis.isXAxis && axis.pointRangePadding) ||
                            0)), allExtremes = axis.allExtremes;
                if (newMin > newMax) {
                    [newMin, newMax] = [newMax, newMin];
                }
                // General calculations of the full data extremes. It is calculated
                // on the first call to transform, then reused for subsequent
                // touch/pan calls. (#11315).
                if (scale === 1 &&
                    !reset &&
                    axis.coll === 'yAxis' &&
                    !allExtremes) {
                    for (const series of axis.series) {
                        const seriesExtremes = series.getExtremes(series.getProcessedData(true).yData, true);
                        allExtremes ?? (allExtremes = {
                            dataMin: Number.MAX_VALUE,
                            dataMax: -Number.MAX_VALUE
                        });
                        if (isNumber$1(seriesExtremes.dataMin) &&
                            isNumber$1(seriesExtremes.dataMax)) {
                            allExtremes.dataMin = Math.min(seriesExtremes.dataMin, allExtremes.dataMin);
                            allExtremes.dataMax = Math.max(seriesExtremes.dataMax, allExtremes.dataMax);
                        }
                    }
                    axis.allExtremes = allExtremes;
                }
                const { dataMin, dataMax, min, max } = extend$1(axis.getExtremes(), allExtremes || {}), 
                // For boosted chart where data extremes are skipped
                safeDataMin = dataMin ?? options.min, safeDataMax = dataMax ?? options.max, range = newMax - newMin, padRange = axis.categories ? 0 : Math.min(range, safeDataMax - safeDataMin), paddedMin = safeDataMin - padRange * (defined$1(options.min) ? 0 : options.minPadding), paddedMax = safeDataMax + padRange * (defined$1(options.max) ? 0 : options.maxPadding), 
                // We're allowed to zoom outside the data extremes if we're
                // dealing with a bubble chart, if we're panning, or if we're
                // pinching or mousewheeling in.
                allowZoomOutside = axis.allowZoomOutside ||
                    scale === 1 ||
                    (trigger !== 'zoom' && scale > 1), 
                // Calculate the floor and the ceiling
                floor = Math.min(options.min ?? paddedMin, paddedMin, allowZoomOutside ? min : paddedMin), ceiling = Math.max(options.max ?? paddedMax, paddedMax, allowZoomOutside ? max : paddedMax);
                // It is not necessary to calculate extremes on ordinal axis,
                // because they are already calculated, so we don't want to override
                // them.
                if (!axis.isOrdinal ||
                    axis.options.overscroll || // #21316
                    scale !== 1 ||
                    reset) {
                    // If the new range spills over, either to the min or max,
                    // adjust it.
                    if (newMin < floor) {
                        newMin = floor;
                        if (scale >= 1) {
                            newMax = newMin + range;
                        }
                    }
                    if (newMax > ceiling) {
                        newMax = ceiling;
                        if (scale >= 1) {
                            newMin = newMax - range;
                        }
                    }
                    // Set new extremes if they are actually new
                    if (reset || (axis.series.length &&
                        (newMin !== min || newMax !== max) &&
                        newMin >= floor &&
                        newMax <= ceiling)) {
                        if (selection) {
                            selection[axis.coll].push({
                                axis,
                                min: newMin,
                                max: newMax
                            });
                        }
                        else {
                            // Temporarily flag the axis as `isPanning` in order to
                            // disallow certain axis padding options that would make
                            // panning/zooming hard. Reset and redraw after the
                            // operation has finished.
                            axis.isPanning = trigger !== 'zoom';
                            if (axis.isPanning) {
                                isAnyAxisPanning = true; // #21319
                            }
                            axis.setExtremes(reset ? void 0 : newMin, reset ? void 0 : newMax, false, false, { move, trigger, scale });
                            if (!reset &&
                                (newMin > floor || newMax < ceiling) &&
                                trigger !== 'mousewheel') {
                                displayButton = true;
                            }
                        }
                        hasZoomed = true;
                    }
                    if (event) {
                        this[horiz ? 'mouseDownX' : 'mouseDownY'] =
                            event[horiz ? 'chartX' : 'chartY'];
                    }
                }
            }
            if (hasZoomed) {
                if (selection) {
                    fireEvent$1(this, 'selection', selection, 
                    // Run transform again, this time without the selection data
                    // so that the transform is applied.
                    () => {
                        delete params.selection;
                        params.trigger = 'zoom';
                        this.transform(params);
                    });
                }
                else {
                    // Show or hide the Reset zoom button, but not while panning
                    if (displayButton &&
                        !isAnyAxisPanning &&
                        !this.resetZoomButton) {
                        this.showResetZoom();
                    }
                    else if (!displayButton && this.resetZoomButton) {
                        this.resetZoomButton = this.resetZoomButton.destroy();
                    }
                    this.redraw(trigger === 'zoom' &&
                        (this.options.chart.animation ?? this.pointCount < 100));
                }
            }
            return hasZoomed;
        }
    }
    extend$1(Chart.prototype, {
        // Hook for adding callbacks in modules
        callbacks: [],
        /**
         * These collections (arrays) implement `Chart.addSomething` method used in
         * chart.update() to create new object in the collection. Equivalent for
         * deleting is resolved by simple `Something.remove()`.
         *
         * Note: We need to define these references after initializers are bound to
         * chart's prototype.
         *
         * @private
         */
        collectionsWithInit: {
            // CollectionName: [ initializingMethod, [extraArguments] ]
            xAxis: [Chart.prototype.addAxis, [true]],
            yAxis: [Chart.prototype.addAxis, [false]],
            series: [Chart.prototype.addSeries]
        },
        /**
         * These collections (arrays) implement update() methods with support for
         * one-to-one option.
         * @private
         */
        collectionsWithUpdate: [
            'xAxis',
            'yAxis',
            'series'
        ],
        /**
         * These properties cause isDirtyBox to be set to true when updating. Can be
         * extended from plugins.
         * @private
         */
        propsRequireDirtyBox: [
            'backgroundColor',
            'borderColor',
            'borderWidth',
            'borderRadius',
            'plotBackgroundColor',
            'plotBackgroundImage',
            'plotBorderColor',
            'plotBorderWidth',
            'plotShadow',
            'shadow'
        ],
        /**
         * These properties require a full reflow of chart elements, best
         * implemented through running `Chart.setSize` internally (#8190).
         * @private
         */
        propsRequireReflow: [
            'margin',
            'marginTop',
            'marginRight',
            'marginBottom',
            'marginLeft',
            'spacing',
            'spacingTop',
            'spacingRight',
            'spacingBottom',
            'spacingLeft'
        ],
        /**
         * These properties cause all series to be updated when updating. Can be
         * extended from plugins.
         * @private
         */
        propsRequireUpdateSeries: [
            'chart.inverted',
            'chart.polar',
            'chart.ignoreHiddenSeries',
            'chart.type',
            'colors',
            'plotOptions',
            'time',
            'tooltip'
        ]
    });

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  API Options
     *
     * */
    /**
     * Column series display one column per value along an X axis.
     *
     * @sample {highcharts} highcharts/demo/column-basic/
     *         Column chart
     * @sample {highstock} stock/demo/column/
     *         Column chart
     *
     * @extends      plotOptions.line
     * @excluding    connectEnds, connectNulls, gapSize, gapUnit, linecap,
     *               lineWidth, marker, step, useOhlcData
     * @product      highcharts highstock
     * @optionparent plotOptions.column
     */
    const ColumnSeriesDefaults = {
        /**
         * The corner radius of the border surrounding each column or bar. A number
         * signifies pixels. A percentage string, like for example `50%`, signifies
         * a relative size. For columns this is relative to the column width, for
         * pies it is relative to the radius and the inner radius.
         *
         * @sample  {highcharts} highcharts/plotoptions/column-borderradius/
         *          Rounded columns
         * @sample  highcharts/plotoptions/series-border-radius
         *          Column and pie with rounded border
         *
         * @type    {number|string|Highcharts.BorderRadiusOptionsObject}
         * @product highcharts highstock gantt
         */
        borderRadius: 3,
        /**
         * When using automatic point colors pulled from the global
         * [colors](colors) or series-specific
         * [plotOptions.column.colors](series.colors) collections, this option
         * determines whether the chart should receive one color per series or
         * one color per point.
         *
         * In styled mode, the `colors` or `series.colors` arrays are not
         * supported, and instead this option gives the points individual color
         * class names on the form `highcharts-color-{n}`.
         *
         * @see [series colors](#plotOptions.column.colors)
         *
         * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/
         *         False by default
         * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/
         *         True
         *
         * @type      {boolean}
         * @default   false
         * @since     2.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.colorByPoint
         */
        /**
         * A series specific or series type specific color set to apply instead
         * of the global [colors](#colors) when [colorByPoint](
         * #plotOptions.column.colorByPoint) is true.
         *
         * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
         * @since     3.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.colors
         */
        /**
         * When `true`, the columns will center in the category, ignoring null
         * or missing points. When `false`, space will be reserved for null or
         * missing points.
         *
         * @sample {highcharts} highcharts/series-column/centerincategory/
         *         Center in category
         *
         * @since   8.0.1
         * @product highcharts highstock gantt
         */
        centerInCategory: false,
        /**
         * Padding between each value groups, in x axis units.
         *
         * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/
         *         0.2 by default
         * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/
         *         No group padding - all columns are evenly spaced
         *
         * @product highcharts highstock gantt
         */
        groupPadding: 0.2,
        /**
         * Whether to group non-stacked columns or to let them render
         * independent of each other. Non-grouped columns will be laid out
         * individually and overlap each other.
         *
         * @sample {highcharts} highcharts/plotoptions/column-grouping-false/
         *         Grouping disabled
         * @sample {highstock} highcharts/plotoptions/column-grouping-false/
         *         Grouping disabled
         *
         * @type      {boolean}
         * @default   true
         * @since     2.3.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.grouping
         */
        /** @ignore-option */
        marker: null, // Point options are specified in the base options
        /**
         * The maximum allowed pixel width for a column, translated to the
         * height of a bar in a bar chart. This prevents the columns from
         * becoming too wide when there is a small number of points in the
         * chart.
         *
         * @see [pointWidth](#plotOptions.column.pointWidth)
         *
         * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
         *         Limited to 50
         * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/
         *         Limited to 50
         *
         * @type      {number}
         * @since     4.1.8
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.maxPointWidth
         */
        /**
         * Padding between each column or bar, in x axis units.
         *
         * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/
         *         0.1 by default
         * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/
         *          0.25
         * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/
         *         0 for tightly packed columns
         *
         * @product highcharts highstock gantt
         */
        pointPadding: 0.1,
        /**
         * A pixel value specifying a fixed width for each column or bar point.
         * When set to `undefined`, the width is calculated from the
         * `pointPadding` and `groupPadding`. The width effects the dimension
         * that is not based on the point value. For column series it is the
         * horizontal length and for bar series it is the vertical length.
         *
         * @see [maxPointWidth](#plotOptions.column.maxPointWidth)
         *
         * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/
         *         20px wide columns regardless of chart width or the amount of
         *         data points
         *
         * @type      {number}
         * @since     1.2.5
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.pointWidth
         */
        /**
         * A pixel value specifying a fixed width for the column or bar.
         * Overrides pointWidth on the series.
         *
         * @see [series.pointWidth](#plotOptions.column.pointWidth)
         *
         * @type      {number}
         * @default   undefined
         * @since     7.0.0
         * @product   highcharts highstock gantt
         * @apioption series.column.data.pointWidth
         */
        /**
         * The minimal height for a column or width for a bar. By default,
         * 0 values are not shown. To visualize a 0 (or close to zero) point,
         * set the minimal point length to a pixel value like 3\. In stacked
         * column charts, minPointLength might not be respected for tightly
         * packed values.
         *
         * @sample {highcharts} highcharts/plotoptions/column-minpointlength/
         *         Zero base value
         * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/
         *         Positive and negative close to zero values
         *
         * @product highcharts highstock gantt
         */
        minPointLength: 0,
        /**
         * When the series contains less points than the crop threshold, all
         * points are drawn, event if the points fall outside the visible plot
         * area at the current zoom. The advantage of drawing all points
         * (including markers and columns), is that animation is performed on
         * updates. On the other hand, when the series contains more points than
         * the crop threshold, the series data is cropped to only contain points
         * that fall within the plot area. The advantage of cropping away
         * invisible points is to increase performance on large series.
         *
         * @product highcharts highstock gantt
         */
        cropThreshold: 50,
        /**
         * The X axis range that each point is valid for. This determines the
         * width of the column. On a categorized axis, the range will be 1
         * by default (one category unit). On linear and datetime axes, the
         * range will be computed as the distance between the two closest data
         * points.
         *
         * The default `null` means it is computed automatically, but this
         * option can be used to override the automatic value.
         *
         * This option is set by default to 1 if data sorting is enabled.
         *
         * @sample {highcharts} highcharts/plotoptions/column-pointrange/
         *         Set the point range to one day on a data set with one week
         *         between the points
         *
         * @type    {number|null}
         * @since   2.3
         * @product highcharts highstock gantt
         */
        pointRange: null,
        states: {
            /**
             * Options for the hovered point. These settings override the normal
             * state options when a point is moused over or touched.
             *
             * @extends   plotOptions.series.states.hover
             * @excluding halo, lineWidth, lineWidthPlus, marker
             * @product   highcharts highstock gantt
             */
            hover: {
                /** @ignore-option */
                halo: false,
                /**
                 * A specific border color for the hovered point. Defaults to
                 * inherit the normal state border color.
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts gantt
                 * @apioption plotOptions.column.states.hover.borderColor
                 */
                /**
                 * A specific color for the hovered point.
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts gantt
                 * @apioption plotOptions.column.states.hover.color
                 */
                /**
                 * How much to brighten the point on interaction. Requires the
                 * main color to be defined in hex or rgb(a) format.
                 *
                 * In styled mode, the hover brightening is by default replaced
                 * with a fill-opacity set in the `.highcharts-point:hover`
                 * rule.
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/
                 *         Brighten by 0.5
                 *
                 * @product highcharts highstock gantt
                 */
                brightness: 0.1
            },
            /**
             * Options for the selected point. These settings override the
             * normal state options when a point is selected.
             *
             * @extends   plotOptions.series.states.select
             * @excluding halo, lineWidth, lineWidthPlus, marker
             * @product   highcharts highstock gantt
             */
            select: {
                /**
                 * A specific color for the selected point.
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @default #cccccc
                 * @product highcharts highstock gantt
                 */
                color: "#cccccc" /* Palette.neutralColor20 */,
                /**
                 * A specific border color for the selected point.
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @default #000000
                 * @product highcharts highstock gantt
                 */
                borderColor: "#000000" /* Palette.neutralColor100 */
            }
        },
        dataLabels: {
            align: void 0,
            verticalAlign: void 0,
            /**
             * The y position offset of the label relative to the point in
             * pixels.
             *
             * @type {number}
             */
            y: void 0
        },
        // False doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/
        /** @ignore-option */
        startFromThreshold: true,
        stickyTracking: false,
        tooltip: {
            distance: 6
        },
        /**
         * The Y axis value to serve as the base for the columns, for
         * distinguishing between values above and below a threshold. If `null`,
         * the columns extend from the padding Y axis minimum.
         *
         * @type    {number|null}
         * @since   2.0
         * @product highcharts
         */
        threshold: 0,
        /**
         * The width of the border surrounding each column or bar. Defaults to
         * `1` when there is room for a border, but to `0` when the columns are
         * so dense that a border would cover the next column.
         *
         * In styled mode, the stroke width can be set with the
         * `.highcharts-point` rule.
         *
         * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
         *         2px black border
         *
         * @type      {number}
         * @default   undefined
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.borderWidth
         */
        /**
         * The color of the border surrounding each column or bar.
         *
         * In styled mode, the border stroke can be set with the
         * `.highcharts-point` rule.
         *
         * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
         *         Dark gray border
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @default   #ffffff
         * @product   highcharts highstock gantt
         */
        borderColor: "#ffffff" /* Palette.backgroundColor */
    };

    /* *
     *
     *  (c) 2010-2024 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animObject } = animationExports;
    const { parse: color } = Color;
    const { noop } = H;
    const { clamp, crisp, defined, extend, fireEvent, isArray, isNumber, merge, pick, objectEach } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /**
     * The column series type.
     *
     * @private
     * @class
     * @name Highcharts.seriesTypes.column
     *
     * @augments Highcharts.Series
     */
    class ColumnSeries extends Series {
        /* *
         *
         *  Functions
         *
         * */
        /* eslint-disable valid-jsdoc */
        /**
         * Animate the column heights one by one from zero.
         *
         * @private
         * @function Highcharts.seriesTypes.column#animate
         *
         * @param {boolean} init
         *        Whether to initialize the animation or run it
         */
        animate(init) {
            const series = this, yAxis = this.yAxis, yAxisPos = yAxis.pos, reversed = yAxis.reversed, options = series.options, { clipOffset, inverted } = this.chart, attr = {}, translateProp = inverted ?
                'translateX' :
                'translateY';
            let translateStart, translatedThreshold;
            if (init && clipOffset) {
                attr.scaleY = 0.001;
                translatedThreshold = clamp(yAxis.toPixels(options.threshold), yAxisPos, yAxisPos + yAxis.len);
                if (inverted) {
                    // Make sure the columns don't cover the axis line during
                    // entrance animation
                    translatedThreshold += reversed ?
                        -Math.floor(clipOffset[0]) :
                        Math.ceil(clipOffset[2]);
                    attr.translateX = translatedThreshold - yAxis.len;
                }
                else {
                    // Make sure the columns don't cover the axis line during
                    // entrance animation
                    translatedThreshold += reversed ?
                        Math.ceil(clipOffset[0]) :
                        -Math.floor(clipOffset[2]);
                    attr.translateY = translatedThreshold;
                }
                // Apply final clipping (used in Highcharts Stock) (#7083)
                // animation is done by scaleY, so clipping is for panes
                if (series.clipBox) {
                    series.setClip();
                }
                series.group.attr(attr);
            }
            else { // Run the animation
                translateStart = Number(series.group.attr(translateProp));
                series.group.animate({ scaleY: 1 }, extend(animObject(series.options.animation), {
                    // Do the scale synchronously to ensure smooth
                    // updating (#5030, #7228)
                    step: function (val, fx) {
                        if (series.group) {
                            attr[translateProp] = translateStart +
                                fx.pos * (yAxisPos - translateStart);
                            series.group.attr(attr);
                        }
                    }
                }));
            }
        }
        /**
         * Initialize the series. Extends the basic Series.init method by
         * marking other series of the same type as dirty.
         *
         * @private
         * @function Highcharts.seriesTypes.column#init
         */
        init(chart, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        options) {
            super.init.apply(this, arguments);
            const series = this;
            chart = series.chart;
            // If the series is added dynamically, force redraw of other
            // series affected by a new column
            if (chart.hasRendered) {
                chart.series.forEach(function (otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
        }
        /**
         * Return the width and x offset of the columns adjusted for grouping,
         * groupPadding, pointPadding, pointWidth etc.
         *
         * @private
         * @function Highcharts.seriesTypes.column#getColumnMetrics
         */
        getColumnMetrics() {
            const series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, 
            // Keep backward compatibility: reversed xAxis had reversed
            // stacks
            reverseStacks = (xAxis.reversed && !reversedStacks) ||
                (!xAxis.reversed && reversedStacks), stackGroups = {};
            let stackKey, columnCount = 0;
            // Get the total number of column type series. This is called on
            // every series. Consider moving this logic to a chart.orderStacks()
            // function and call it on init, addSeries and removeSeries
            if (options.grouping === false) {
                columnCount = 1;
            }
            else {
                series.chart.series.forEach(function (otherSeries) {
                    const otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;
                    let columnIndex;
                    if (otherSeries.type === series.type &&
                        otherSeries.reserveSpace() &&
                        yAxis.len === otherYAxis.len &&
                        yAxis.pos === otherYAxis.pos) { // #642, #2086
                        if (otherOptions.stacking &&
                            otherOptions.stacking !== 'group') {
                            stackKey = otherSeries.stackKey;
                            if (typeof stackGroups[stackKey] ===
                                'undefined') {
                                stackGroups[stackKey] = columnCount++;
                            }
                            columnIndex = stackGroups[stackKey];
                        }
                        else if (otherOptions.grouping !== false) { // #1162
                            columnIndex = columnCount++;
                        }
                        otherSeries.columnIndex = columnIndex;
                    }
                });
            }
            const categoryWidth = Math.min(Math.abs(xAxis.transA) * ((!xAxis.brokenAxis?.hasBreaks && xAxis.ordinal?.slope) ||
                options.pointRange ||
                xAxis.closestPointRange ||
                xAxis.tickInterval ||
                1), // #2610
            xAxis.len // #1535
            ), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, 
            // #1251, #3737
            colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding +
                (groupPadding +
                    colIndex * pointOffsetWidth -
                    (categoryWidth / 2)) * (reverseStacks ? -1 : 1);
            // Save it for reading in linked series (Error bars particularly)
            series.columnMetrics = {
                width: pointWidth,
                offset: pointXOffset,
                paddedWidth: pointOffsetWidth,
                columnCount
            };
            return series.columnMetrics;
        }
        /**
         * Make the columns crisp. The edges are rounded to the nearest full
         * pixel.
         *
         * @private
         * @function Highcharts.seriesTypes.column#crispCol
         */
        crispCol(x, y, width, height) {
            const borderWidth = this.borderWidth, inverted = this.chart.inverted, bottom = crisp(y + height, borderWidth, inverted);
            // Vertical
            y = crisp(y, borderWidth, inverted);
            height = bottom - y;
            // Horizontal. We need to first compute the exact right edge, then
            // round it and compute the width from there.
            if (this.options.crisp) {
                const right = crisp(x + width, borderWidth);
                x = crisp(x, borderWidth);
                width = right - x;
            }
            return { x, y, width, height };
        }
        /**
         * Adjust for missing columns, according to the `centerInCategory`
         * option. Missing columns are either single points or stacks where the
         * point or points are either missing or null.
         *
         * @private
         * @function Highcharts.seriesTypes.column#adjustForMissingColumns
         * @param {number} x
         * The x coordinate of the column, left side
         *
         * @param {number} pointWidth
         * The pointWidth, already computed upstream
         *
         * @param {Highcharts.ColumnPoint} point
         * The point instance
         *
         * @param {Highcharts.ColumnMetricsObject} metrics
         * The series-wide column metrics
         *
         * @return {number}
         * The adjusted x position, or the original if not adjusted
         */
        adjustForMissingColumns(x, pointWidth, point, metrics) {
            if (!point.isNull && metrics.columnCount > 1) {
                const visibleSeries = this.xAxis.series
                    .filter((s) => s.visible)
                    .map((s) => s.index);
                let indexInCategory = 0, totalInCategory = 0;
                // Loop over all the stacks on the Y axis. When stacking is enabled,
                // these are real point stacks. When stacking is not enabled, but
                // `centerInCategory` is true, there is one stack handling the
                // grouping of points in each category. This is done in the
                // `setGroupedPoints` function.
                objectEach(this.xAxis.stacking?.stacks, (stack) => {
                    if (typeof point.x === 'number') {
                        const stackItem = stack[point.x.toString()];
                        if (stackItem) {
                            const pointValues = stackItem.points[this.index];
                            // Look for the index
                            if (isArray(pointValues)) {
                                // If there are multiple points with the same X
                                // then gather all series in category, and
                                // assign index
                                const seriesIndexes = Object
                                    .keys(stackItem.points)
                                    .filter((pointKey) => 
                                // Filter out duplicate X's
                                !pointKey.match(',') &&
                                    // Filter out null points
                                    stackItem.points[pointKey] &&
                                    stackItem.points[pointKey].length > 1)
                                    .map(parseFloat)
                                    .filter((index) => visibleSeries.indexOf(index) !== -1)
                                    .sort((a, b) => b - a);
                                indexInCategory = seriesIndexes.indexOf(this.index);
                                totalInCategory = seriesIndexes.length;
                            }
                        }
                    }
                });
                indexInCategory = this.xAxis.reversed ?
                    totalInCategory - 1 - indexInCategory : indexInCategory;
                // Compute the adjusted x position
                const boxWidth = (totalInCategory - 1) * metrics.paddedWidth +
                    pointWidth;
                x = (point.plotX || 0) + boxWidth / 2 - pointWidth -
                    indexInCategory * metrics.paddedWidth;
            }
            return x;
        }
        /**
         * Translate each point to the plot area coordinate system and find
         * shape positions
         *
         * @private
         * @function Highcharts.seriesTypes.column#translate
         */
        translate() {
            const series = this, chart = series.chart, options = series.options, dense = series.dense =
                series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635
            ), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax, translatedThreshold = series.translatedThreshold =
                yAxis.getThreshold(threshold);
            // Postprocessed for border width
            let seriesBarW = series.barW =
                Math.max(seriesPointWidth, 1 + 2 * borderWidth);
            // When the pointPadding is 0, we want the columns to be packed
            // tightly, so we allow individual columns to have individual sizes.
            // When pointPadding is greater, we strive for equal-width columns
            // (#2694).
            if (options.pointPadding) {
                seriesBarW = Math.ceil(seriesBarW);
            }
            Series.prototype.translate.apply(series);
            // Record the new values
            series.points.forEach(function (point) {
                const yBottom = pick(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, 
                // Don't draw too far outside plot area (#1303, #2241,
                // #4264)
                plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance);
                let up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
                // Handle options.minPointLength
                if (minPointLength && Math.abs(barH) < minPointLength) {
                    barH = minPointLength;
                    up = (!yAxis.reversed && !point.negative) ||
                        (yAxis.reversed && point.negative);
                    // Reverse zeros if there's no positive value in the series
                    // in visible range (#7046)
                    if (isNumber(threshold) &&
                        isNumber(dataMax) &&
                        point.y === threshold &&
                        dataMax <= threshold &&
                        // And if there's room for it (#7311)
                        (yAxis.min || 0) < threshold &&
                        // If all points are the same value (i.e zero) not draw
                        // as negative points (#10646), but only if there's room
                        // for it (#14876)
                        (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {
                        up = !up;
                        point.negative = !point.negative;
                    }
                    // If stacked...
                    barY = (Math.abs(barY - translatedThreshold) > minPointLength ?
                        // ...keep position
                        yBottom - minPointLength :
                        // #1485, #4051
                        translatedThreshold -
                            (up ? minPointLength : 0));
                }
                // Handle point.options.pointWidth
                // @todo Handle grouping/stacking too. Calculate offset properly
                if (defined(point.options.pointWidth)) {
                    pointWidth = barW =
                        Math.ceil(point.options.pointWidth);
                    barX -= Math.round((pointWidth - seriesPointWidth) / 2);
                }
                // Adjust for null or missing points
                if (options.centerInCategory && !options.stacking) {
                    barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
                }
                // Cache for access in polar
                point.barX = barX;
                point.pointWidth = pointWidth;
                // Fix the tooltip on center of grouped columns (#1216, #424,
                // #3648)
                point.tooltipPos = chart.inverted ?
                    [
                        clamp(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),
                        xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,
                        barH
                    ] :
                    [
                        xAxis.left - chart.plotLeft + barX + barW / 2,
                        clamp(plotY + yAxis.pos -
                            chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),
                        barH
                    ];
                // Register shape type and arguments to be used in drawPoints. Allow
                // `shapeType` defined on `pointClass` level.
                point.shapeType = series.pointClass.prototype.shapeType ||
                    'roundedRect';
                point.shapeArgs = series.crispCol(barX, 
                // #3169, drilldown from null must have a position to work from.
                // #6585, dataLabel should be placed on xAxis, not floating in
                // the middle of the chart.
                point.isNull ? translatedThreshold : barY, barW, point.isNull ? 0 : barH);
            });
            // Fire a specific event after column translate. We could instead apply
            // all the column logic in an `afterTranslate` event handler, but there
            // are so many other series types that use the column translation, that
            // it is more convenient to have a specific event for it.
            fireEvent(this, 'afterColumnTranslate');
        }
        /**
         * Columns have no graph
         *
         * @private
         * @function Highcharts.seriesTypes.column#drawGraph
         */
        drawGraph() {
            this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');
        }
        /**
         * Get presentational attributes
         *
         * @private
         * @function Highcharts.seriesTypes.column#pointAttribs
         */
        pointAttribs(point, state) {
            const options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || 'borderColor', strokeWidthOption = p2o['stroke-width'] || 'borderWidth';
            let stateOptions, zone, brightness, fill = (point && point.color) || this.color, 
            // Set to fill when borderColor null:
            stroke = ((point && point[strokeOption]) ||
                options[strokeOption] ||
                fill), dashstyle = (point && point.options.dashStyle) || options.dashStyle, strokeWidth = (point && point[strokeWidthOption]) ||
                options[strokeWidthOption] ||
                this[strokeWidthOption] || 0, opacity = pick(point && point.opacity, options.opacity, 1);
            // Handle zone colors
            if (point && this.zones.length) {
                zone = point.getZone();
                // When zones are present, don't use point.color (#4267).
                // Changed order (#6527), added support for colorAxis (#10670)
                fill = (point.options.color ||
                    (zone && (zone.color || point.nonZonedColor)) ||
                    this.color);
                if (zone) {
                    stroke = zone.borderColor || stroke;
                    dashstyle = zone.dashStyle || dashstyle;
                    strokeWidth = zone.borderWidth || strokeWidth;
                }
            }
            // Select or hover states
            if (state && point) {
                stateOptions = merge(options.states[state], 
                // #6401
                point.options.states &&
                    point.options.states[state] ||
                    {});
                brightness = stateOptions.brightness;
                fill =
                    stateOptions.color || (typeof brightness !== 'undefined' &&
                        color(fill)
                            .brighten(stateOptions.brightness)
                            .get()) || fill;
                stroke = stateOptions[strokeOption] || stroke;
                strokeWidth =
                    stateOptions[strokeWidthOption] || strokeWidth;
                dashstyle = stateOptions.dashStyle || dashstyle;
                opacity = pick(stateOptions.opacity, opacity);
            }
            const ret = {
                fill: fill,
                stroke: stroke,
                'stroke-width': strokeWidth,
                opacity: opacity
            };
            if (dashstyle) {
                ret.dashstyle = dashstyle;
            }
            return ret;
        }
        /**
         * Draw the columns. For bars, the series.group is rotated, so the same
         * coordinates apply for columns and bars. This method is inherited by
         * scatter series.
         *
         * @private
         * @function Highcharts.seriesTypes.column#drawPoints
         */
        drawPoints(points = this.points) {
            const series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;
            let shapeArgs;
            // Draw the columns
            points.forEach(function (point) {
                const plotY = point.plotY;
                let graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ?
                    'animate' : 'attr';
                if (isNumber(plotY) && point.y !== null) {
                    shapeArgs = point.shapeArgs;
                    // When updating a series between 2d and 3d or cartesian and
                    // polar, the shape type changes.
                    if (graphic && point.hasNewShapeType()) {
                        graphic = graphic.destroy();
                    }
                    // Set starting position for point sliding animation.
                    if (series.enabledDataSorting) {
                        point.startXPos = series.xAxis.reversed ?
                            -(shapeArgs ? (shapeArgs.width || 0) : 0) :
                            series.xAxis.width;
                    }
                    if (!graphic) {
                        point.graphic = graphic =
                            renderer[point.shapeType](shapeArgs)
                                .add(point.group || series.group);
                        if (graphic &&
                            series.enabledDataSorting &&
                            chart.hasRendered &&
                            chart.pointCount < animationLimit) {
                            graphic.attr({
                                x: point.startXPos
                            });
                            hasGraphic = true;
                            verb = 'animate';
                        }
                    }
                    if (graphic && hasGraphic) { // Update
                        graphic[verb](merge(shapeArgs));
                    }
                    // Presentational
                    if (!chart.styledMode) {
                        graphic[verb](series.pointAttribs(point, (point.selected && 'select')))
                            .shadow(point.allowShadow !== false && options.shadow);
                    }
                    if (graphic) {
                        graphic.addClass(point.getClassName(), true);
                        graphic.attr({
                            visibility: point.visible ? 'inherit' : 'hidden'
                        });
                    }
                }
                else if (graphic) {
                    point.graphic = graphic.destroy(); // #1269
                }
            });
        }
        /**
         * Draw the tracker for a point.
         * @private
         */
        drawTracker(points = this.points) {
            const series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function (e) {
                const point = pointer?.getPointFromEvent(e);
                // Undefined on graph in scatterchart
                if (pointer &&
                    point &&
                    series.options.enableMouseTracking) {
                    pointer.isDirectTouch = true;
                    point.onMouseOver(e);
                }
            };
            let dataLabels;
            // Add reference to the point
            points.forEach(function (point) {
                dataLabels = (isArray(point.dataLabels) ?
                    point.dataLabels :
                    (point.dataLabel ? [point.dataLabel] : []));
                if (point.graphic) {
                    point.graphic.element.point = point;
                }
                dataLabels.forEach(function (dataLabel) {
                    (dataLabel.div || dataLabel.element).point = point;
                });
            });
            // Add the event listeners, we need to do this only once
            if (!series._hasTracking) {
                series.trackerGroups.forEach(function (key) {
                    if (series[key]) {
                        // We don't always have dataLabelsGroup
                        series[key]
                            .addClass('highcharts-tracker')
                            .on('mouseover', onMouseOver)
                            .on('mouseout', function (e) {
                            pointer?.onTrackerMouseOut(e);
                        })
                            .on('touchstart', onMouseOver);
                        if (!chart.styledMode && series.options.cursor) {
                            series[key]
                                .css({ cursor: series.options.cursor });
                        }
                    }
                });
                series._hasTracking = true;
            }
            fireEvent(this, 'afterDrawTracker');
        }
        /**
         * Remove this series from the chart
         *
         * @private
         * @function Highcharts.seriesTypes.column#remove
         */
        remove() {
            const series = this, chart = series.chart;
            // Column and bar series affects other series of the same type
            // as they are either stacked or grouped
            if (chart.hasRendered) {
                chart.series.forEach(function (otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
            Series.prototype.remove.apply(series, arguments);
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    ColumnSeries.defaultOptions = merge(Series.defaultOptions, ColumnSeriesDefaults);
    extend(ColumnSeries.prototype, {
        // When tooltip is not shared, this series (and derivatives) requires
        // direct touch/hover. KD-tree does not apply.
        directTouch: true,
        getSymbol: noop,
        // Use separate negative stacks, unlike area stacks where a negative
        // point is subtracted from previous (#1910)
        negStacks: true,
        trackerGroups: ['group', 'dataLabelsGroup']
    });
    SeriesRegistry$1.registerSeriesType('column', ColumnSeries);

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var highcharts = {exports: {}};

    (function (module) {
    	!/**
    	 * Highcharts JS v11.4.8 (2024-08-29)
    	 *
    	 * (c) 2009-2024 Torstein Honsi
    	 *
    	 * License: www.highcharts.com/license
    	 */function(t,e){module.exports?(e.default=e,module.exports=t&&t.document?e(t):e):(t.Highcharts&&t.Highcharts.error(16,!0),t.Highcharts=e(t));}("undefined"!=typeof window?window:commonjsGlobal,function(t){var e={};function i(e,i,s,r){!e.hasOwnProperty(i)&&(e[i]=r.apply(null,s),t&&"function"==typeof CustomEvent&&t.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:i,module:e[i]}})));}return i(e,"Core/Globals.js",[],function(){var e,i;return (i=e||(e={})).SVG_NS="http://www.w3.org/2000/svg",i.product="Highcharts",i.version="11.4.8",i.win=void 0!==t?t:{},i.doc=i.win.document,i.svg=i.doc&&i.doc.createElementNS&&!!i.doc.createElementNS(i.SVG_NS,"svg").createSVGRect,i.userAgent=i.win.navigator&&i.win.navigator.userAgent||"",i.isChrome=i.win.chrome,i.isFirefox=-1!==i.userAgent.indexOf("Firefox"),i.isMS=/(edge|msie|trident)/i.test(i.userAgent)&&!i.win.opera,i.isSafari=!i.isChrome&&-1!==i.userAgent.indexOf("Safari"),i.isTouchDevice=/(Mobile|Android|Windows Phone)/.test(i.userAgent),i.isWebKit=-1!==i.userAgent.indexOf("AppleWebKit"),i.deg2rad=2*Math.PI/360,i.hasBidiBug=i.isFirefox&&4>parseInt(i.userAgent.split("Firefox/")[1],10),i.marginNames=["plotTop","marginRight","marginBottom","plotLeft"],i.noop=function(){},i.supportsPassiveEvents=function(){let t=!1;if(!i.isMS){let e=Object.defineProperty({},"passive",{get:function(){t=!0;}});i.win.addEventListener&&i.win.removeEventListener&&(i.win.addEventListener("testPassive",i.noop,e),i.win.removeEventListener("testPassive",i.noop,e));}return t}(),i.charts=[],i.composed=[],i.dateFormats={},i.seriesTypes={},i.symbolSizes={},i.chartCount=0,e}),i(e,"Core/Utilities.js",[e["Core/Globals.js"]],function(t){let e;let{charts:i,doc:s,win:r}=t;function o(e,i,s,n){let a=i?"Highcharts error":"Highcharts warning";32===e&&(e=`${a}: Deprecated member`);let h=p(e),l=h?`${a} #${e}: www.highcharts.com/errors/${e}/`:e.toString();if(void 0!==n){let t="";h&&(l+="?"),C(n,function(e,i){t+=`
 - ${i}: ${e}`,h&&(l+=encodeURI(i)+"="+encodeURI(e));}),l+=t;}M(t,"displayError",{chart:s,code:e,message:l,params:n},function(){if(i)throw Error(l);r.console&&-1===o.messages.indexOf(l)&&console.warn(l);}),o.messages.push(l);}function n(t,e){return parseInt(t,e||10)}function a(t){return "string"==typeof t}function h(t){let e=Object.prototype.toString.call(t);return "[object Array]"===e||"[object Array Iterator]"===e}function l(t,e){return !!t&&"object"==typeof t&&(!e||!h(t))}function d(t){return l(t)&&"number"==typeof t.nodeType}function c(t){let e=t&&t.constructor;return !!(l(t,!0)&&!d(t)&&e&&e.name&&"Object"!==e.name)}function p(t){return "number"==typeof t&&!isNaN(t)&&t<1/0&&t>-1/0}function u(t){return null!=t}function g(t,e,i){let s;let r=a(e)&&!u(i),o=(e,i)=>{u(e)?t.setAttribute(i,e):r?(s=t.getAttribute(i))||"class"!==i||(s=t.getAttribute(i+"Name")):t.removeAttribute(i);};return a(e)?o(i,e):C(e,o),s}function f(t){return h(t)?t:[t]}function m(t,e){let i;for(i in t||(t={}),e)t[i]=e[i];return t}function x(){let t=arguments,e=t.length;for(let i=0;i<e;i++){let e=t[i];if(null!=e)return e}}function y(t,e){m(t.style,e);}function b(t){return Math.pow(10,Math.floor(Math.log(t)/Math.LN10))}function v(t,e){return t>1e14?t:parseFloat(t.toPrecision(e||14))}(o||(o={})).messages=[],Math.easeInOutSine=function(t){return -.5*(Math.cos(Math.PI*t)-1)};let S=Array.prototype.find?function(t,e){return t.find(e)}:function(t,e){let i;let s=t.length;for(i=0;i<s;i++)if(e(t[i],i))return t[i]};function C(t,e,i){for(let s in t)Object.hasOwnProperty.call(t,s)&&e.call(i||t[s],t[s],s,t);}function k(t,e,i){function s(e,i){let s=t.removeEventListener;s&&s.call(t,e,i,!1);}function r(i){let r,o;t.nodeName&&(e?(r={})[e]=!0:r=i,C(r,function(t,e){if(i[e])for(o=i[e].length;o--;)s(e,i[e][o].fn);}));}let o="function"==typeof t&&t.prototype||t;if(Object.hasOwnProperty.call(o,"hcEvents")){let t=o.hcEvents;if(e){let o=t[e]||[];i?(t[e]=o.filter(function(t){return i!==t.fn}),s(e,i)):(r(t),t[e]=[]);}else r(t),delete o.hcEvents;}}function M(e,i,r,o){if(r=r||{},s.createEvent&&(e.dispatchEvent||e.fireEvent&&e!==t)){let t=s.createEvent("Events");t.initEvent(i,!0,!0),r=m(t,r),e.dispatchEvent?e.dispatchEvent(r):e.fireEvent(i,r);}else if(e.hcEvents){r.target||m(r,{preventDefault:function(){r.defaultPrevented=!0;},target:e,type:i});let t=[],s=e,o=!1;for(;s.hcEvents;)Object.hasOwnProperty.call(s,"hcEvents")&&s.hcEvents[i]&&(t.length&&(o=!0),t.unshift.apply(t,s.hcEvents[i])),s=Object.getPrototypeOf(s);o&&t.sort((t,e)=>t.order-e.order),t.forEach(t=>{!1===t.fn.call(e,r)&&r.preventDefault();});}o&&!r.defaultPrevented&&o.call(e,r);}C({map:"map",each:"forEach",grep:"filter",reduce:"reduce",some:"some"},function(e,i){t[i]=function(t){return o(32,!1,void 0,{[`Highcharts.${i}`]:`use Array.${e}`}),Array.prototype[e].apply(t,[].slice.call(arguments,1))};});let w=function(){let t=Math.random().toString(36).substring(2,9)+"-",i=0;return function(){return "highcharts-"+(e?"":t)+i++}}();return r.jQuery&&(r.jQuery.fn.highcharts=function(){let e=[].slice.call(arguments);if(this[0])return e[0]?(new t[a(e[0])?e.shift():"Chart"](this[0],e[0],e[1]),this):i[g(this[0],"data-highcharts-chart")]}),{addEvent:function(e,i,s,r={}){let o="function"==typeof e&&e.prototype||e;Object.hasOwnProperty.call(o,"hcEvents")||(o.hcEvents={});let n=o.hcEvents;t.Point&&e instanceof t.Point&&e.series&&e.series.chart&&(e.series.chart.runTrackerClick=!0);let a=e.addEventListener;a&&a.call(e,i,s,!!t.supportsPassiveEvents&&{passive:void 0===r.passive?-1!==i.indexOf("touch"):r.passive,capture:!1}),n[i]||(n[i]=[]);let h={fn:s,order:"number"==typeof r.order?r.order:1/0};return n[i].push(h),n[i].sort((t,e)=>t.order-e.order),function(){k(e,i,s);}},arrayMax:function(t){let e=t.length,i=t[0];for(;e--;)t[e]>i&&(i=t[e]);return i},arrayMin:function(t){let e=t.length,i=t[0];for(;e--;)t[e]<i&&(i=t[e]);return i},attr:g,clamp:function(t,e,i){return t>e?t<i?t:i:e},clearTimeout:function(t){u(t)&&clearTimeout(t);},correctFloat:v,createElement:function(t,e,i,r,o){let n=s.createElement(t);return e&&m(n,e),o&&y(n,{padding:"0",border:"none",margin:"0"}),i&&y(n,i),r&&r.appendChild(n),n},crisp:(t,e=0,i)=>{let s=e%2/2,r=i?-1:1;return (Math.round(t*r-s)+s)*r},css:y,defined:u,destroyObjectProperties:function(t,e,i){C(t,function(s,r){s!==e&&s?.destroy&&s.destroy(),(s?.destroy||!i)&&delete t[r];});},diffObjects:function(t,e,i,s){let r={};return function t(e,r,o,n){let a=i?r:e;C(e,function(i,d){if(!n&&s&&s.indexOf(d)>-1&&r[d]){i=f(i),o[d]=[];for(let e=0;e<Math.max(i.length,r[d].length);e++)r[d][e]&&(void 0===i[e]?o[d][e]=r[d][e]:(o[d][e]={},t(i[e],r[d][e],o[d][e],n+1)));}else l(i,!0)&&!i.nodeType?(o[d]=h(i)?[]:{},t(i,r[d]||{},o[d],n+1),0!==Object.keys(o[d]).length||"colorAxis"===d&&0===n||delete o[d]):(e[d]!==r[d]||d in e&&!(d in r))&&"__proto__"!==d&&"constructor"!==d&&(o[d]=a[d]);});}(t,e,r,0),r},discardElement:function(t){t&&t.parentElement&&t.parentElement.removeChild(t);},erase:function(t,e){let i=t.length;for(;i--;)if(t[i]===e){t.splice(i,1);break}},error:o,extend:m,extendClass:function(t,e){let i=function(){};return i.prototype=new t,m(i.prototype,e),i},find:S,fireEvent:M,getClosestDistance:function(t,e){let i,r,o;let n=!e;return t.forEach(t=>{if(t.length>1)for(o=t.length-1;o>0;o--)(r=t[o]-t[o-1])<0&&!n?(e?.(),e=void 0):r&&(void 0===i||r<i)&&(i=r);}),i},getMagnitude:b,getNestedProperty:function(t,e){let i=t.split(".");for(;i.length&&u(e);){let t=i.shift();if(void 0===t||"__proto__"===t)return;if("this"===t){let t;return l(e)&&(t=e["@this"]),t??e}let s=e[t];if(!u(s)||"function"==typeof s||"number"==typeof s.nodeType||s===r)return;e=s;}return e},getStyle:function t(e,i,s){let o;if("width"===i){let i=Math.min(e.offsetWidth,e.scrollWidth),s=e.getBoundingClientRect&&e.getBoundingClientRect().width;return s<i&&s>=i-1&&(i=Math.floor(s)),Math.max(0,i-(t(e,"padding-left",!0)||0)-(t(e,"padding-right",!0)||0))}if("height"===i)return Math.max(0,Math.min(e.offsetHeight,e.scrollHeight)-(t(e,"padding-top",!0)||0)-(t(e,"padding-bottom",!0)||0));let a=r.getComputedStyle(e,void 0);return a&&(o=a.getPropertyValue(i),x(s,"opacity"!==i)&&(o=n(o))),o},inArray:function(t,e,i){return o(32,!1,void 0,{"Highcharts.inArray":"use Array.indexOf"}),e.indexOf(t,i)},insertItem:function(t,e){let i;let s=t.options.index,r=e.length;for(i=t.options.isInternal?r:0;i<r+1;i++)if(!e[i]||p(s)&&s<x(e[i].options.index,e[i]._i)||e[i].options.isInternal){e.splice(i,0,t);break}return i},isArray:h,isClass:c,isDOMElement:d,isFunction:function(t){return "function"==typeof t},isNumber:p,isObject:l,isString:a,keys:function(t){return o(32,!1,void 0,{"Highcharts.keys":"use Object.keys"}),Object.keys(t)},merge:function(){let t,e=arguments,i={},s=function(t,e){return "object"!=typeof t&&(t={}),C(e,function(i,r){"__proto__"!==r&&"constructor"!==r&&(!l(i,!0)||c(i)||d(i)?t[r]=e[r]:t[r]=s(t[r]||{},i));}),t};!0===e[0]&&(i=e[1],e=Array.prototype.slice.call(e,2));let r=e.length;for(t=0;t<r;t++)i=s(i,e[t]);return i},normalizeTickInterval:function(t,e,i,s,r){let o,n=t;i=x(i,b(t));let a=t/i;for(!e&&(e=r?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===s&&(1===i?e=e.filter(function(t){return t%1==0}):i<=.1&&(e=[1/i]))),o=0;o<e.length&&(n=e[o],(!r||!(n*i>=t))&&(r||!(a<=(e[o]+(e[o+1]||e[o]))/2)));o++);return v(n*i,-Math.round(Math.log(.001)/Math.LN10))},objectEach:C,offset:function(t){let e=s.documentElement,i=t.parentElement||t.parentNode?t.getBoundingClientRect():{top:0,left:0,width:0,height:0};return {top:i.top+(r.pageYOffset||e.scrollTop)-(e.clientTop||0),left:i.left+(r.pageXOffset||e.scrollLeft)-(e.clientLeft||0),width:i.width,height:i.height}},pad:function(t,e,i){return Array((e||2)+1-String(t).replace("-","").length).join(i||"0")+t},pick:x,pInt:n,pushUnique:function(t,e){return 0>t.indexOf(e)&&!!t.push(e)},relativeLength:function(t,e,i){return /%$/.test(t)?e*parseFloat(t)/100+(i||0):parseFloat(t)},removeEvent:k,replaceNested:function(t,...e){let i,s;do for(s of(i=t,e))t=t.replace(s[0],s[1]);while(t!==i);return t},splat:f,stableSort:function(t,e){let i,s;let r=t.length;for(s=0;s<r;s++)t[s].safeI=s;for(t.sort(function(t,s){return 0===(i=e(t,s))?t.safeI-s.safeI:i}),s=0;s<r;s++)delete t[s].safeI;},syncTimeout:function(t,e,i){return e>0?setTimeout(t,e,i):(t.call(0,i),-1)},timeUnits:{millisecond:1,second:1e3,minute:6e4,hour:36e5,day:864e5,week:6048e5,month:24192e5,year:314496e5},uniqueKey:w,useSerialIds:function(t){return e=x(t,e)},wrap:function(t,e,i){let s=t[e];t[e]=function(){let t=arguments,e=this;return i.apply(this,[function(){return s.apply(e,arguments.length?arguments:t)}].concat([].slice.call(arguments)))};}}}),i(e,"Core/Chart/ChartDefaults.js",[],function(){return {alignThresholds:!1,panning:{enabled:!1,type:"x"},styledMode:!1,borderRadius:0,colorCount:10,allowMutatingData:!0,ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{},position:{}},reflow:!0,type:"line",zooming:{singleTouch:!1,resetButton:{theme:{zIndex:6},position:{align:"right",x:-10,y:10}}},width:null,height:null,borderColor:"#334eff",backgroundColor:"#ffffff",plotBorderColor:"#cccccc"}}),i(e,"Core/Color/Palettes.js",[],function(){return {colors:["#2caffe","#544fc5","#00e272","#fe6a35","#6b8abc","#d568fb","#2ee0ca","#fa4b42","#feb56a","#91e8e1"]}}),i(e,"Core/Time.js",[e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e){let{win:i}=t,{defined:s,error:r,extend:o,isNumber:n,isObject:a,merge:h,objectEach:l,pad:d,pick:c,splat:p,timeUnits:u}=e,g=t.isSafari&&i.Intl&&i.Intl.DateTimeFormat.prototype.formatRange,f=t.isSafari&&i.Intl&&!i.Intl.DateTimeFormat.prototype.formatRange;class m{constructor(t){this.options={},this.useUTC=!1,this.variableTimezone=!1,this.Date=i.Date,this.getTimezoneOffset=this.timezoneOffsetFunction(),this.update(t);}get(t,e){if(this.variableTimezone||this.timezoneOffset){let i=e.getTime(),s=i-this.getTimezoneOffset(e);e.setTime(s);let r=e["getUTC"+t]();return e.setTime(i),r}return this.useUTC?e["getUTC"+t]():e["get"+t]()}set(t,e,i){if(this.variableTimezone||this.timezoneOffset){if("Milliseconds"===t||"Seconds"===t||"Minutes"===t&&this.getTimezoneOffset(e)%36e5==0)return e["setUTC"+t](i);let s=this.getTimezoneOffset(e),r=e.getTime()-s;e.setTime(r),e["setUTC"+t](i);let o=this.getTimezoneOffset(e);return r=e.getTime()+o,e.setTime(r)}return this.useUTC||g&&"FullYear"===t?e["setUTC"+t](i):e["set"+t](i)}update(t={}){let e=c(t.useUTC,!0);this.options=t=h(!0,this.options,t),this.Date=t.Date||i.Date||Date,this.useUTC=e,this.timezoneOffset=e&&t.timezoneOffset||void 0,this.getTimezoneOffset=this.timezoneOffsetFunction(),this.variableTimezone=e&&!!(t.getTimezoneOffset||t.timezone);}makeTime(t,e,i,s,r,o){let n,a,h;return this.useUTC?(n=this.Date.UTC.apply(0,arguments),a=this.getTimezoneOffset(n),n+=a,a!==(h=this.getTimezoneOffset(n))?n+=h-a:a-36e5!==this.getTimezoneOffset(n-36e5)||f||(n-=36e5)):n=new this.Date(t,e,c(i,1),c(s,0),c(r,0),c(o,0)).getTime(),n}timezoneOffsetFunction(){let t=this,e=this.options,i=e.getTimezoneOffset;return this.useUTC?e.timezone?t=>{try{let i=`shortOffset,${e.timezone||""}`,[s,r,o,a,h=0]=(m.formatCache[i]=m.formatCache[i]||Intl.DateTimeFormat("en",{timeZone:e.timezone,timeZoneName:"shortOffset"})).format(t).split(/(GMT|:)/).map(Number),l=-(36e5*(o+h/60));if(n(l))return l}catch(t){r(34);}return 0}:this.useUTC&&i?t=>6e4*i(t.valueOf()):()=>6e4*(t.timezoneOffset||0):t=>6e4*new Date(t.toString()).getTimezoneOffset()}dateFormat(e,i,r){if(!s(i)||isNaN(i))return t.defaultOptions.lang&&t.defaultOptions.lang.invalidDate||"";e=c(e,"%Y-%m-%d %H:%M:%S");let n=this,a=new this.Date(i),h=this.get("Hours",a),p=this.get("Day",a),u=this.get("Date",a),g=this.get("Month",a),f=this.get("FullYear",a),m=t.defaultOptions.lang,x=m&&m.weekdays,y=m&&m.shortWeekdays;return l(o({a:y?y[p]:x[p].substr(0,3),A:x[p],d:d(u),e:d(u,2," "),w:p,b:m.shortMonths[g],B:m.months[g],m:d(g+1),o:g+1,y:f.toString().substr(2,2),Y:f,H:d(h),k:h,I:d(h%12||12),l:h%12||12,M:d(this.get("Minutes",a)),p:h<12?"AM":"PM",P:h<12?"am":"pm",S:d(this.get("Seconds",a)),L:d(Math.floor(i%1e3),3)},t.dateFormats),function(t,s){for(;-1!==e.indexOf("%"+s);)e=e.replace("%"+s,"function"==typeof t?t.call(n,i):t);}),r?e.substr(0,1).toUpperCase()+e.substr(1):e}resolveDTLFormat(t){return a(t,!0)?t:{main:(t=p(t))[0],from:t[1],to:t[2]}}getTimeTicks(t,e,i,r){let n,a,h,l;let d=this,p=d.Date,g=[],f={},m=new p(e),x=t.unitRange,y=t.count||1;if(r=c(r,1),s(e)){d.set("Milliseconds",m,x>=u.second?0:y*Math.floor(d.get("Milliseconds",m)/y)),x>=u.second&&d.set("Seconds",m,x>=u.minute?0:y*Math.floor(d.get("Seconds",m)/y)),x>=u.minute&&d.set("Minutes",m,x>=u.hour?0:y*Math.floor(d.get("Minutes",m)/y)),x>=u.hour&&d.set("Hours",m,x>=u.day?0:y*Math.floor(d.get("Hours",m)/y)),x>=u.day&&d.set("Date",m,x>=u.month?1:Math.max(1,y*Math.floor(d.get("Date",m)/y))),x>=u.month&&(d.set("Month",m,x>=u.year?0:y*Math.floor(d.get("Month",m)/y)),a=d.get("FullYear",m)),x>=u.year&&(a-=a%y,d.set("FullYear",m,a)),x===u.week&&(l=d.get("Day",m),d.set("Date",m,d.get("Date",m)-l+r+(l<r?-7:0))),a=d.get("FullYear",m);let t=d.get("Month",m),o=d.get("Date",m),c=d.get("Hours",m);e=m.getTime(),(d.variableTimezone||!d.useUTC)&&s(i)&&(h=i-e>4*u.month||d.getTimezoneOffset(e)!==d.getTimezoneOffset(i));let p=m.getTime();for(n=1;p<i;)g.push(p),x===u.year?p=d.makeTime(a+n*y,0):x===u.month?p=d.makeTime(a,t+n*y):h&&(x===u.day||x===u.week)?p=d.makeTime(a,t,o+n*y*(x===u.day?1:7)):h&&x===u.hour&&y>1?p=d.makeTime(a,t,o,c+n*y):p+=x*y,n++;g.push(p),x<=u.hour&&g.length<1e4&&g.forEach(function(t){t%18e5==0&&"000000000"===d.dateFormat("%H%M%S%L",t)&&(f[t]="day");});}return g.info=o(t,{higherRanks:f,totalRange:x*y}),g}getDateFormat(t,e,i,s){let r=this.dateFormat("%m-%d %H:%M:%S.%L",e),o="01-01 00:00:00.000",n={millisecond:15,second:12,minute:9,hour:6,day:3},a="millisecond",h=a;for(a in u){if(t===u.week&&+this.dateFormat("%w",e)===i&&r.substr(6)===o.substr(6)){a="week";break}if(u[a]>t){a=h;break}if(n[a]&&r.substr(n[a])!==o.substr(n[a]))break;"week"!==a&&(h=a);}return this.resolveDTLFormat(s[a]).main}}return m.formatCache={},m}),i(e,"Core/Defaults.js",[e["Core/Chart/ChartDefaults.js"],e["Core/Globals.js"],e["Core/Color/Palettes.js"],e["Core/Time.js"],e["Core/Utilities.js"]],function(t,e,i,s,r){let{isTouchDevice:o}=e,{fireEvent:n,merge:a}=r,h={colors:i.colors,symbols:["circle","diamond","square","triangle","triangle-down"],lang:{loading:"Loading...",months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],weekdays:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],decimalPoint:".",numericSymbols:["k","M","G","T","P","E"],resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{buttonTheme:{fill:"#f7f7f7",padding:8,r:2,stroke:"#cccccc","stroke-width":1,style:{color:"#333333",cursor:"pointer",fontSize:"0.8em",fontWeight:"normal"},states:{hover:{fill:"#e6e6e6"},select:{fill:"#e6e9ff",style:{color:"#000000",fontWeight:"bold"}},disabled:{style:{color:"#cccccc"}}}}},time:{Date:void 0,getTimezoneOffset:void 0,timezone:void 0,timezoneOffset:0,useUTC:!0},chart:t,title:{style:{color:"#333333",fontWeight:"bold"},text:"Chart title",align:"center",margin:15,widthAdjust:-44},subtitle:{style:{color:"#666666",fontSize:"0.8em"},text:"",align:"center",widthAdjust:-44},caption:{margin:15,style:{color:"#666666",fontSize:"0.8em"},text:"",align:"left",verticalAlign:"bottom"},plotOptions:{},legend:{enabled:!0,align:"center",alignColumns:!0,className:"highcharts-no-tooltip",events:{},layout:"horizontal",itemMarginBottom:2,itemMarginTop:2,labelFormatter:function(){return this.name},borderColor:"#999999",borderRadius:0,navigation:{style:{fontSize:"0.8em"},activeColor:"#0022ff",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",cursor:"pointer",fontSize:"0.8em",textDecoration:"none",textOverflow:"ellipsis"},itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#666666",textDecoration:"line-through"},shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontSize:"0.8em",fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:{duration:300,easing:t=>Math.sqrt(1-Math.pow(t-1,2))},borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %e %b, %H:%M:%S.%L",second:"%A, %e %b, %H:%M:%S",minute:"%A, %e %b, %H:%M",hour:"%A, %e %b, %H:%M",day:"%A, %e %b %Y",week:"Week from %A, %e %b %Y",month:"%B %Y",year:"%Y"},footerFormat:"",headerShape:"callout",hideDelay:500,padding:8,shape:"callout",shared:!1,snap:o?25:10,headerFormat:'<span style="font-size: 0.8em">{point.key}</span><br/>',pointFormat:'<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',backgroundColor:"#ffffff",borderWidth:void 0,shadow:!0,stickOnContact:!1,style:{color:"#333333",cursor:"default",fontSize:"0.8em"},useHTML:!1},credits:{enabled:!0,href:"https://www.highcharts.com?credits",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#999999",fontSize:"0.6em"},text:"Highcharts.com"}};h.chart.styledMode=!1;let l=new s(h.time);return {defaultOptions:h,defaultTime:l,getOptions:function(){return h},setOptions:function(t){return n(e,"setOptions",{options:t}),a(!0,h,t),(t.time||t.global)&&(e.time?e.time.update(a(h.global,h.time,t.global,t.time)):e.time=l),h}}}),i(e,"Core/Color/Color.js",[e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e){let{isNumber:i,merge:s,pInt:r}=e;class o{static parse(t){return t?new o(t):o.None}constructor(e){let i,s,r,n;this.rgba=[NaN,NaN,NaN,NaN],this.input=e;let a=t.Color;if(a&&a!==o)return new a(e);if("object"==typeof e&&void 0!==e.stops)this.stops=e.stops.map(t=>new o(t[1]));else if("string"==typeof e){if(this.input=e=o.names[e.toLowerCase()]||e,"#"===e.charAt(0)){let t=e.length,i=parseInt(e.substr(1),16);7===t?s=[(16711680&i)>>16,(65280&i)>>8,255&i,1]:4===t&&(s=[(3840&i)>>4|(3840&i)>>8,(240&i)>>4|240&i,(15&i)<<4|15&i,1]);}if(!s)for(r=o.parsers.length;r--&&!s;)(i=(n=o.parsers[r]).regex.exec(e))&&(s=n.parse(i));}s&&(this.rgba=s);}get(t){let e=this.input,r=this.rgba;if("object"==typeof e&&void 0!==this.stops){let i=s(e);return i.stops=[].slice.call(i.stops),this.stops.forEach((e,s)=>{i.stops[s]=[i.stops[s][0],e.get(t)];}),i}return r&&i(r[0])?"rgb"!==t&&(t||1!==r[3])?"a"===t?`${r[3]}`:"rgba("+r.join(",")+")":"rgb("+r[0]+","+r[1]+","+r[2]+")":e}brighten(t){let e=this.rgba;if(this.stops)this.stops.forEach(function(e){e.brighten(t);});else if(i(t)&&0!==t)for(let i=0;i<3;i++)e[i]+=r(255*t),e[i]<0&&(e[i]=0),e[i]>255&&(e[i]=255);return this}setOpacity(t){return this.rgba[3]=t,this}tweenTo(t,e){let s=this.rgba,r=t.rgba;if(!i(s[0])||!i(r[0]))return t.input||"none";let o=1!==r[3]||1!==s[3];return (o?"rgba(":"rgb(")+Math.round(r[0]+(s[0]-r[0])*(1-e))+","+Math.round(r[1]+(s[1]-r[1])*(1-e))+","+Math.round(r[2]+(s[2]-r[2])*(1-e))+(o?","+(r[3]+(s[3]-r[3])*(1-e)):"")+")"}}return o.names={white:"#ffffff",black:"#000000"},o.parsers=[{regex:/rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?(?:\.\d+)?)\s*\)/,parse:function(t){return [r(t[1]),r(t[2]),r(t[3]),parseFloat(t[4],10)]}},{regex:/rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/,parse:function(t){return [r(t[1]),r(t[2]),r(t[3]),1]}}],o.None=new o(""),o}),i(e,"Core/Animation/Fx.js",[e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e,i){let{parse:s}=t,{win:r}=e,{isNumber:o,objectEach:n}=i;class a{constructor(t,e,i){this.pos=NaN,this.options=e,this.elem=t,this.prop=i;}dSetter(){let t=this.paths,e=t&&t[0],i=t&&t[1],s=this.now||0,r=[];if(1!==s&&e&&i){if(e.length===i.length&&s<1)for(let t=0;t<i.length;t++){let n=e[t],a=i[t],h=[];for(let t=0;t<a.length;t++){let e=n[t],i=a[t];o(e)&&o(i)&&!("A"===a[0]&&(4===t||5===t))?h[t]=e+s*(i-e):h[t]=i;}r.push(h);}else r=i;}else r=this.toD||[];this.elem.attr("d",r,void 0,!0);}update(){let t=this.elem,e=this.prop,i=this.now,s=this.options.step;this[e+"Setter"]?this[e+"Setter"]():t.attr?t.element&&t.attr(e,i,null,!0):t.style[e]=i+this.unit,s&&s.call(t,i,this);}run(t,e,i){let s=this,o=s.options,n=function(t){return !n.stopped&&s.step(t)},h=r.requestAnimationFrame||function(t){setTimeout(t,13);},l=function(){for(let t=0;t<a.timers.length;t++)a.timers[t]()||a.timers.splice(t--,1);a.timers.length&&h(l);};t!==e||this.elem["forceAnimate:"+this.prop]?(this.startTime=+new Date,this.start=t,this.end=e,this.unit=i,this.now=this.start,this.pos=0,n.elem=this.elem,n.prop=this.prop,n()&&1===a.timers.push(n)&&h(l)):(delete o.curAnim[this.prop],o.complete&&0===Object.keys(o.curAnim).length&&o.complete.call(this.elem));}step(t){let e,i;let s=+new Date,r=this.options,o=this.elem,a=r.complete,h=r.duration,l=r.curAnim;return o.attr&&!o.element?e=!1:t||s>=h+this.startTime?(this.now=this.end,this.pos=1,this.update(),l[this.prop]=!0,i=!0,n(l,function(t){!0!==t&&(i=!1);}),i&&a&&a.call(o),e=!1):(this.pos=r.easing((s-this.startTime)/h),this.now=this.start+(this.end-this.start)*this.pos,this.update(),e=!0),e}initPath(t,e,i){let s=t.startX,r=t.endX,n=i.slice(),a=t.isArea,h=a?2:1,l=e&&i.length>e.length&&i.hasStackedCliffs,d,c,p,u,g=e&&e.slice();if(!g||l)return [n,n];function f(t,e){for(;t.length<c;){let i=t[0],s=e[c-t.length];if(s&&"M"===i[0]&&("C"===s[0]?t[0]=["C",i[1],i[2],i[1],i[2],i[1],i[2]]:t[0]=["L",i[1],i[2]]),t.unshift(i),a){let e=t.pop();t.push(t[t.length-1],e);}}}function m(t){for(;t.length<c;){let e=t[Math.floor(t.length/h)-1].slice();if("C"===e[0]&&(e[1]=e[5],e[2]=e[6]),a){let i=t[Math.floor(t.length/h)].slice();t.splice(t.length/2,0,e,i);}else t.push(e);}}if(s&&r&&r.length){for(p=0;p<s.length;p++){if(s[p]===r[0]){d=p;break}if(s[0]===r[r.length-s.length+p]){d=p,u=!0;break}if(s[s.length-1]===r[r.length-s.length+p]){d=s.length-p;break}}void 0===d&&(g=[]);}return g.length&&o(d)&&(c=n.length+d*h,u?(f(g,n),m(n)):(f(n,g),m(g))),[g,n]}fillSetter(){a.prototype.strokeSetter.apply(this,arguments);}strokeSetter(){this.elem.attr(this.prop,s(this.start).tweenTo(s(this.end),this.pos),void 0,!0);}}return a.timers=[],a}),i(e,"Core/Animation/AnimationUtilities.js",[e["Core/Animation/Fx.js"],e["Core/Utilities.js"]],function(t,e){let{defined:i,getStyle:s,isArray:r,isNumber:o,isObject:n,merge:a,objectEach:h,pick:l}=e;function d(t){return n(t)?a({duration:500,defer:0},t):{duration:t?500:0,defer:0}}function c(e,i){let s=t.timers.length;for(;s--;)t.timers[s].elem!==e||i&&i!==t.timers[s].prop||(t.timers[s].stopped=!0);}return {animate:function(e,i,l){let d,p="",u,g,f;n(l)||(f=arguments,l={duration:f[2],easing:f[3],complete:f[4]}),o(l.duration)||(l.duration=400),l.easing="function"==typeof l.easing?l.easing:Math[l.easing]||Math.easeInOutSine,l.curAnim=a(i),h(i,function(o,n){c(e,n),g=new t(e,l,n),u=void 0,"d"===n&&r(i.d)?(g.paths=g.initPath(e,e.pathArray,i.d),g.toD=i.d,d=0,u=1):e.attr?d=e.attr(n):(d=parseFloat(s(e,n))||0,"opacity"!==n&&(p="px")),u||(u=o),"string"==typeof u&&u.match("px")&&(u=u.replace(/px/g,"")),g.run(d,u,p);});},animObject:d,getDeferredAnimation:function(t,e,s){let r=d(e),o=s?[s]:t.series,a=0,h=0;return o.forEach(t=>{let s=d(t.options.animation);a=n(e)&&i(e.defer)?r.defer:Math.max(a,s.duration+s.defer),h=Math.min(r.duration,s.duration);}),t.renderer.forExport&&(a=0),{defer:Math.max(0,a-h),duration:Math.min(a,h)}},setAnimation:function(t,e){e.renderer.globalAnimation=l(t,e.options.chart.animation,!0);},stop:c}}),i(e,"Core/Renderer/HTML/AST.js",[e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e){let{SVG_NS:i,win:s}=t,{attr:r,createElement:o,css:n,error:a,isFunction:h,isString:l,objectEach:d,splat:c}=e,{trustedTypes:p}=s,u=p&&h(p.createPolicy)&&p.createPolicy("highcharts",{createHTML:t=>t}),g=u?u.createHTML(""):"",f=function(){try{return !!new DOMParser().parseFromString(g,"text/html")}catch(t){return !1}}();class m{static filterUserAttributes(t){return d(t,(e,i)=>{let s=!0;-1===m.allowedAttributes.indexOf(i)&&(s=!1),-1!==["background","dynsrc","href","lowsrc","src"].indexOf(i)&&(s=l(e)&&m.allowedReferences.some(t=>0===e.indexOf(t))),s||(a(33,!1,void 0,{"Invalid attribute in config":`${i}`}),delete t[i]),l(e)&&t[i]&&(t[i]=e.replace(/</g,"&lt;"));}),t}static parseStyle(t){return t.split(";").reduce((t,e)=>{let i=e.split(":").map(t=>t.trim()),s=i.shift();return s&&i.length&&(t[s.replace(/-([a-z])/g,t=>t[1].toUpperCase())]=i.join(":")),t},{})}static setElementHTML(t,e){t.innerHTML=m.emptyHTML,e&&new m(e).addToDOM(t);}constructor(t){this.nodes="string"==typeof t?this.parseMarkup(t):t;}addToDOM(e){return function e(s,o){let h;return c(s).forEach(function(s){let l;let c=s.tagName,p=s.textContent?t.doc.createTextNode(s.textContent):void 0,u=m.bypassHTMLFiltering;if(c){if("#text"===c)l=p;else if(-1!==m.allowedTags.indexOf(c)||u){let a="svg"===c?i:o.namespaceURI||i,h=t.doc.createElementNS(a,c),g=s.attributes||{};d(s,function(t,e){"tagName"!==e&&"attributes"!==e&&"children"!==e&&"style"!==e&&"textContent"!==e&&(g[e]=t);}),r(h,u?g:m.filterUserAttributes(g)),s.style&&n(h,s.style),p&&h.appendChild(p),e(s.children||[],h),l=h;}else a(33,!1,void 0,{"Invalid tagName in config":c});}l&&o.appendChild(l),h=l;}),h}(this.nodes,e)}parseMarkup(t){let e;let i=[];if(t=t.trim().replace(/ style=(["'])/g," data-style=$1"),f)e=new DOMParser().parseFromString(u?u.createHTML(t):t,"text/html");else {let i=o("div");i.innerHTML=t,e={body:i};}let s=(t,e)=>{let i=t.nodeName.toLowerCase(),r={tagName:i};"#text"===i&&(r.textContent=t.textContent||"");let o=t.attributes;if(o){let t={};[].forEach.call(o,e=>{"data-style"===e.name?r.style=m.parseStyle(e.value):t[e.name]=e.value;}),r.attributes=t;}if(t.childNodes.length){let e=[];[].forEach.call(t.childNodes,t=>{s(t,e);}),e.length&&(r.children=e);}e.push(r);};return [].forEach.call(e.body.childNodes,t=>s(t,i)),i}}return m.allowedAttributes=["alt","aria-controls","aria-describedby","aria-expanded","aria-haspopup","aria-hidden","aria-label","aria-labelledby","aria-live","aria-pressed","aria-readonly","aria-roledescription","aria-selected","class","clip-path","color","colspan","cx","cy","d","dx","dy","disabled","fill","filterUnits","flood-color","flood-opacity","height","href","id","in","in2","markerHeight","markerWidth","offset","opacity","operator","orient","padding","paddingLeft","paddingRight","patternUnits","r","radius","refX","refY","role","scope","slope","src","startOffset","stdDeviation","stroke","stroke-linecap","stroke-width","style","tableValues","result","rowspan","summary","target","tabindex","text-align","text-anchor","textAnchor","textLength","title","type","valign","width","x","x1","x2","xlink:href","y","y1","y2","zIndex"],m.allowedReferences=["https://","http://","mailto:","/","../","./","#"],m.allowedTags=["a","abbr","b","br","button","caption","circle","clipPath","code","dd","defs","div","dl","dt","em","feComponentTransfer","feComposite","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feMorphology","feOffset","feMerge","feMergeNode","filter","h1","h2","h3","h4","h5","h6","hr","i","img","li","linearGradient","marker","ol","p","path","pattern","pre","rect","small","span","stop","strong","style","sub","sup","svg","table","text","textPath","thead","title","tbody","tspan","td","th","tr","u","ul","#text"],m.emptyHTML=g,m.bypassHTMLFiltering=!1,m}),i(e,"Core/Templating.js",[e["Core/Defaults.js"],e["Core/Utilities.js"]],function(t,e){let{defaultOptions:i,defaultTime:s}=t,{extend:r,getNestedProperty:o,isArray:n,isNumber:a,isObject:h,pick:l,pInt:d}=e,c={add:(t,e)=>t+e,divide:(t,e)=>0!==e?t/e:"",eq:(t,e)=>t==e,each:function(t){let e=arguments[arguments.length-1];return !!n(t)&&t.map((i,s)=>p(e.body,r(h(i)?i:{"@this":i},{"@index":s,"@first":0===s,"@last":s===t.length-1}))).join("")},ge:(t,e)=>t>=e,gt:(t,e)=>t>e,if:t=>!!t,le:(t,e)=>t<=e,lt:(t,e)=>t<e,multiply:(t,e)=>t*e,ne:(t,e)=>t!=e,subtract:(t,e)=>t-e,unless:t=>!t};function p(t="",e,r){let n=/\{([\w\:\.\,;\-\/<>%@"'’= #\(\)]+)\}/g,a=/\(([\w\:\.\,;\-\/<>%@"'= ]+)\)/g,h=[],d=/f$/,g=/\.(\d)/,f=i.lang,m=r&&r.time||s,x=r&&r.numberFormatter||u,y=(t="")=>{let i;return "true"===t||"false"!==t&&((i=Number(t)).toString()===t?i:o(t,e))},b,v,S=0,C;for(;null!==(b=n.exec(t));){let i=a.exec(b[1]);i&&(b=i,C=!0),v&&v.isBlock||(v={ctx:e,expression:b[1],find:b[0],isBlock:"#"===b[1].charAt(0),start:b.index,startInner:b.index+b[0].length,length:b[0].length});let s=b[1].split(" ")[0].replace("#","");c[s]&&(v.isBlock&&s===v.fn&&S++,v.fn||(v.fn=s));let r="else"===b[1];if(v.isBlock&&v.fn&&(b[1]===`/${v.fn}`||r)){if(S)!r&&S--;else {let e=v.startInner,i=t.substr(e,b.index-e);void 0===v.body?(v.body=i,v.startInner=b.index+b[0].length):v.elseBody=i,v.find+=i+b[0],r||(h.push(v),v=void 0);}}else v.isBlock||h.push(v);if(i&&!v?.isBlock)break}return h.forEach(i=>{let s,o;let{body:n,elseBody:a,expression:h,fn:u}=i;if(u){let t=[i],l=h.split(" ");for(o=c[u].length;o--;)t.unshift(y(l[o+1]));s=c[u].apply(e,t),i.isBlock&&"boolean"==typeof s&&(s=p(s?n:a,e,r));}else {let t=h.split(":");if(s=y(t.shift()||""),t.length&&"number"==typeof s){let e=t.join(":");if(d.test(e)){let t=parseInt((e.match(g)||["","-1"])[1],10);null!==s&&(s=x(s,t,f.decimalPoint,e.indexOf(",")>-1?f.thousandsSep:""));}else s=m.dateFormat(e,s);}}t=t.replace(i.find,l(s,""));}),C?p(t,e,r):t}function u(t,e,s,r){let o,n;t=+t||0,e=+e;let h=i.lang,c=(t.toString().split(".")[1]||"").split("e")[0].length,p=t.toString().split("e"),u=e;-1===e?e=Math.min(c,20):a(e)?e&&p[1]&&p[1]<0&&((n=e+ +p[1])>=0?(p[0]=(+p[0]).toExponential(n).split("e")[0],e=n):(p[0]=p[0].split(".")[0]||0,t=e<20?(p[0]*Math.pow(10,p[1])).toFixed(e):0,p[1]=0)):e=2;let g=(Math.abs(p[1]?p[0]:t)+Math.pow(10,-Math.max(e,c)-1)).toFixed(e),f=String(d(g)),m=f.length>3?f.length%3:0;return s=l(s,h.decimalPoint),r=l(r,h.thousandsSep),o=(t<0?"-":"")+(m?f.substr(0,m)+r:""),0>+p[1]&&!u?o="0":o+=f.substr(m).replace(/(\d{3})(?=\d)/g,"$1"+r),e?o+=s+g.slice(-e):0==+o&&(o="0"),p[1]&&0!=+o&&(o+="e"+p[1]),o}return {dateFormat:function(t,e,i){return s.dateFormat(t,e,i)},format:p,helpers:c,numberFormat:u}}),i(e,"Core/Renderer/RendererRegistry.js",[e["Core/Globals.js"]],function(t){var e,i;let s;return (i=e||(e={})).rendererTypes={},i.getRendererType=function(t=s){return i.rendererTypes[t]||i.rendererTypes[s]},i.registerRendererType=function(e,r,o){i.rendererTypes[e]=r,(!s||o)&&(s=e,t.Renderer=r);},e}),i(e,"Core/Renderer/RendererUtilities.js",[e["Core/Utilities.js"]],function(t){var e;let{clamp:i,pick:s,pushUnique:r,stableSort:o}=t;return (e||(e={})).distribute=function t(e,n,a){let h=e,l=h.reducedLen||n,d=(t,e)=>t.target-e.target,c=[],p=e.length,u=[],g=c.push,f,m,x,y=!0,b,v,S=0,C;for(f=p;f--;)S+=e[f].size;if(S>l){for(o(e,(t,e)=>(e.rank||0)-(t.rank||0)),x=(C=e[0].rank===e[e.length-1].rank)?p/2:-1,m=C?x:p-1;x&&S>l;)b=e[f=Math.floor(m)],r(u,f)&&(S-=b.size),m+=x,C&&m>=e.length&&(x/=2,m=x);u.sort((t,e)=>e-t).forEach(t=>g.apply(c,e.splice(t,1)));}for(o(e,d),e=e.map(t=>({size:t.size,targets:[t.target],align:s(t.align,.5)}));y;){for(f=e.length;f--;)b=e[f],v=(Math.min.apply(0,b.targets)+Math.max.apply(0,b.targets))/2,b.pos=i(v-b.size*b.align,0,n-b.size);for(f=e.length,y=!1;f--;)f>0&&e[f-1].pos+e[f-1].size>e[f].pos&&(e[f-1].size+=e[f].size,e[f-1].targets=e[f-1].targets.concat(e[f].targets),e[f-1].align=.5,e[f-1].pos+e[f-1].size>n&&(e[f-1].pos=n-e[f-1].size),e.splice(f,1),y=!0);}return g.apply(h,c),f=0,e.some(e=>{let i=0;return (e.targets||[]).some(()=>(h[f].pos=e.pos+i,void 0!==a&&Math.abs(h[f].pos-h[f].target)>a)?(h.slice(0,f+1).forEach(t=>delete t.pos),h.reducedLen=(h.reducedLen||n)-.1*n,h.reducedLen>.1*n&&t(h,n,a),!0):(i+=h[f].size,f++,!1))}),o(h,d),h},e}),i(e,"Core/Renderer/SVG/SVGElement.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e,i,s){let{animate:r,animObject:o,stop:n}=t,{deg2rad:a,doc:h,svg:l,SVG_NS:d,win:c}=i,{addEvent:p,attr:u,createElement:g,crisp:f,css:m,defined:x,erase:y,extend:b,fireEvent:v,isArray:S,isFunction:C,isObject:k,isString:M,merge:w,objectEach:T,pick:A,pInt:P,pushUnique:L,replaceNested:O,syncTimeout:D,uniqueKey:E}=s;class I{_defaultGetter(t){let e=A(this[t+"Value"],this[t],this.element?this.element.getAttribute(t):null,0);return /^-?[\d\.]+$/.test(e)&&(e=parseFloat(e)),e}_defaultSetter(t,e,i){i.setAttribute(e,t);}add(t){let e;let i=this.renderer,s=this.element;return t&&(this.parentGroup=t),void 0!==this.textStr&&"text"===this.element.nodeName&&i.buildText(this),this.added=!0,(!t||t.handleZ||this.zIndex)&&(e=this.zIndexSetter()),e||(t?t.element:i.box).appendChild(s),this.onAdd&&this.onAdd(),this}addClass(t,e){let i=e?"":this.attr("class")||"";return (t=(t||"").split(/ /g).reduce(function(t,e){return -1===i.indexOf(e)&&t.push(e),t},i?[i]:[]).join(" "))!==i&&this.attr("class",t),this}afterSetters(){this.doTransform&&(this.updateTransform(),this.doTransform=!1);}align(t,e,i,s=!0){let r,o,n,a;let h={},l=this.renderer,d=l.alignedObjects,c=!!t;t?(this.alignOptions=t,this.alignByTranslate=e,this.alignTo=i):(t=this.alignOptions||{},e=this.alignByTranslate,i=this.alignTo);let p=!i||M(i)?i||"renderer":void 0;p&&(c&&L(d,this),i=void 0);let u=A(i,l[p],l),g=t.align,f=t.verticalAlign;return r=(u.x||0)+(t.x||0),o=(u.y||0)+(t.y||0),"right"===g?n=1:"center"===g&&(n=2),n&&(r+=((u.width||0)-(t.width||0))/n),h[e?"translateX":"x"]=Math.round(r),"bottom"===f?a=1:"middle"===f&&(a=2),a&&(o+=((u.height||0)-(t.height||0))/a),h[e?"translateY":"y"]=Math.round(o),s&&(this[this.placed?"animate":"attr"](h),this.placed=!0),this.alignAttr=h,this}alignSetter(t){let e={left:"start",center:"middle",right:"end"};e[t]&&(this.alignValue=t,this.element.setAttribute("text-anchor",e[t]));}animate(t,e,i){let s=o(A(e,this.renderer.globalAnimation,!0)),n=s.defer;return h.hidden&&(s.duration=0),0!==s.duration?(i&&(s.complete=i),D(()=>{this.element&&r(this,t,s);},n)):(this.attr(t,void 0,i||s.complete),T(t,function(t,e){s.step&&s.step.call(this,t,{prop:e,pos:1,elem:this});},this)),this}applyTextOutline(t){let e=this.element;-1!==t.indexOf("contrast")&&(t=t.replace(/contrast/g,this.renderer.getContrast(e.style.fill)));let s=t.split(" "),r=s[s.length-1],o=s[0];if(o&&"none"!==o&&i.svg){this.fakeTS=!0,o=o.replace(/(^[\d\.]+)(.*?)$/g,function(t,e,i){return 2*Number(e)+i}),this.removeTextOutline();let t=h.createElementNS(d,"tspan");u(t,{class:"highcharts-text-outline",fill:r,stroke:r,"stroke-width":o,"stroke-linejoin":"round"});let i=e.querySelector("textPath")||e;[].forEach.call(i.childNodes,e=>{let i=e.cloneNode(!0);i.removeAttribute&&["fill","stroke","stroke-width","stroke"].forEach(t=>i.removeAttribute(t)),t.appendChild(i);});let s=0;[].forEach.call(i.querySelectorAll("text tspan"),t=>{s+=Number(t.getAttribute("dy"));});let n=h.createElementNS(d,"tspan");n.textContent="​",u(n,{x:Number(e.getAttribute("x")),dy:-s}),t.appendChild(n),i.insertBefore(t,i.firstChild);}}attr(t,e,i,s){let{element:r}=this,o=I.symbolCustomAttribs,a,h,l=this,d;return "string"==typeof t&&void 0!==e&&(a=t,(t={})[a]=e),"string"==typeof t?l=(this[t+"Getter"]||this._defaultGetter).call(this,t,r):(T(t,function(e,i){d=!1,s||n(this,i),this.symbolName&&-1!==o.indexOf(i)&&(h||(this.symbolAttr(t),h=!0),d=!0),this.rotation&&("x"===i||"y"===i)&&(this.doTransform=!0),d||(this[i+"Setter"]||this._defaultSetter).call(this,e,i,r);},this),this.afterSetters()),i&&i.call(this),l}clip(t){if(t&&!t.clipPath){let e=E()+"-",i=this.renderer.createElement("clipPath").attr({id:e}).add(this.renderer.defs);b(t,{clipPath:i,id:e,count:0}),t.add(i);}return this.attr("clip-path",t?`url(${this.renderer.url}#${t.id})`:"none")}crisp(t,e){e=Math.round(e||t.strokeWidth||0);let i=t.x||this.x||0,s=t.y||this.y||0,r=(t.width||this.width||0)+i,o=(t.height||this.height||0)+s,n=f(i,e),a=f(s,e);return b(t,{x:n,y:a,width:f(r,e)-n,height:f(o,e)-a}),x(t.strokeWidth)&&(t.strokeWidth=e),t}complexColor(t,i,s){let r=this.renderer,o,n,a,h,l,d,c,p,u,g,f=[],m;v(this.renderer,"complexColor",{args:arguments},function(){if(t.radialGradient?n="radialGradient":t.linearGradient&&(n="linearGradient"),n){if(a=t[n],l=r.gradients,d=t.stops,u=s.radialReference,S(a)&&(t[n]=a={x1:a[0],y1:a[1],x2:a[2],y2:a[3],gradientUnits:"userSpaceOnUse"}),"radialGradient"===n&&u&&!x(a.gradientUnits)&&(h=a,a=w(a,r.getRadialAttr(u,h),{gradientUnits:"userSpaceOnUse"})),T(a,function(t,e){"id"!==e&&f.push(e,t);}),T(d,function(t){f.push(t);}),l[f=f.join(",")])g=l[f].attr("id");else {a.id=g=E();let t=l[f]=r.createElement(n).attr(a).add(r.defs);t.radAttr=h,t.stops=[],d.forEach(function(i){0===i[1].indexOf("rgba")?(c=(o=e.parse(i[1])).get("rgb"),p=o.get("a")):(c=i[1],p=1);let s=r.createElement("stop").attr({offset:i[0],"stop-color":c,"stop-opacity":p}).add(t);t.stops.push(s);});}m="url("+r.url+"#"+g+")",s.setAttribute(i,m),s.gradient=f,t.toString=function(){return m};}});}css(t){let e=this.styles,i={},s=this.element,r,o=!e;if(e&&T(t,function(t,s){e&&e[s]!==t&&(i[s]=t,o=!0);}),o){e&&(t=b(e,i)),null===t.width||"auto"===t.width?delete this.textWidth:"text"===s.nodeName.toLowerCase()&&t.width&&(r=this.textWidth=P(t.width)),b(this.styles,t),r&&!l&&this.renderer.forExport&&delete t.width;let o=w(t);s.namespaceURI===this.SVG_NS&&(["textOutline","textOverflow","width"].forEach(t=>o&&delete o[t]),o.color&&(o.fill=o.color)),m(s,o);}return this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),t.textOutline&&this.applyTextOutline(t.textOutline)),this}dashstyleSetter(t){let e,i=this["stroke-width"];if("inherit"===i&&(i=1),t=t&&t.toLowerCase()){let s=t.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(e=s.length;e--;)s[e]=""+P(s[e])*A(i,NaN);t=s.join(",").replace(/NaN/g,"none"),this.element.setAttribute("stroke-dasharray",t);}}destroy(){let t=this,e=t.element||{},i=t.renderer,s=e.ownerSVGElement,r="SPAN"===e.nodeName&&t.parentGroup||void 0,o,a;if(e.onclick=e.onmouseout=e.onmouseover=e.onmousemove=e.point=null,n(t),t.clipPath&&s){let e=t.clipPath;[].forEach.call(s.querySelectorAll("[clip-path],[CLIP-PATH]"),function(t){t.getAttribute("clip-path").indexOf(e.element.id)>-1&&t.removeAttribute("clip-path");}),t.clipPath=e.destroy();}if(t.connector=t.connector?.destroy(),t.stops){for(a=0;a<t.stops.length;a++)t.stops[a].destroy();t.stops.length=0,t.stops=void 0;}for(t.safeRemoveChild(e);r&&r.div&&0===r.div.childNodes.length;)o=r.parentGroup,t.safeRemoveChild(r.div),delete r.div,r=o;t.alignOptions&&y(i.alignedObjects,t),T(t,function(e,i){t[i]&&t[i].parentGroup===t&&t[i].destroy&&t[i].destroy(),delete t[i];});}dSetter(t,e,i){S(t)&&("string"==typeof t[0]&&(t=this.renderer.pathToSegments(t)),this.pathArray=t,t=t.reduce((t,e,i)=>e&&e.join?(i?t+" ":"")+e.join(" "):(e||"").toString(),"")),/(NaN| {2}|^$)/.test(t)&&(t="M 0 0"),this[e]!==t&&(i.setAttribute(e,t),this[e]=t);}fillSetter(t,e,i){"string"==typeof t?i.setAttribute(e,t):t&&this.complexColor(t,e,i);}hrefSetter(t,e,i){i.setAttributeNS("http://www.w3.org/1999/xlink",e,t);}getBBox(t,e){let i,s,r,o;let{alignValue:n,element:a,renderer:h,styles:l,textStr:d}=this,{cache:c,cacheKeys:p}=h,u=a.namespaceURI===this.SVG_NS,g=A(e,this.rotation,0),f=h.styledMode?a&&I.prototype.getStyle.call(a,"font-size"):l.fontSize;if(x(d)&&(-1===(o=d.toString()).indexOf("<")&&(o=o.replace(/\d/g,"0")),o+=["",h.rootFontSize,f,g,this.textWidth,n,l.textOverflow,l.fontWeight].join(",")),o&&!t&&(i=c[o]),!i||i.polygon){if(u||h.forExport){try{r=this.fakeTS&&function(t){let e=a.querySelector(".highcharts-text-outline");e&&m(e,{display:t});},C(r)&&r("none"),i=a.getBBox?b({},a.getBBox()):{width:a.offsetWidth,height:a.offsetHeight,x:0,y:0},C(r)&&r("");}catch(t){}(!i||i.width<0)&&(i={x:0,y:0,width:0,height:0});}else i=this.htmlGetBBox();s=i.height,u&&(i.height=s=({"11px,17":14,"13px,20":16})[`${f||""},${Math.round(s)}`]||s),g&&(i=this.getRotatedBox(i,g));let t={bBox:i};v(this,"afterGetBBox",t),i=t.bBox;}if(o&&(""===d||i.height>0)){for(;p.length>250;)delete c[p.shift()];c[o]||p.push(o),c[o]=i;}return i}getRotatedBox(t,e){let{x:i,y:s,width:r,height:o}=t,{alignValue:n,translateY:h,rotationOriginX:l=0,rotationOriginY:d=0}=this,c={right:1,center:.5}[n||0]||0,p=Number(this.element.getAttribute("y")||0)-(h?0:s),u=e*a,g=(e-90)*a,f=Math.cos(u),m=Math.sin(u),x=r*f,y=r*m,b=Math.cos(g),v=Math.sin(g),[[S,C],[k,M]]=[l,d].map(t=>[t-t*f,t*m]),w=i+c*(r-x)+S+M+p*b,T=w+x,A=T-o*b,P=A-x,L=s+p-c*y-C+k+p*v,O=L+y,D=O-o*v,E=D-y,I=Math.min(w,T,A,P),j=Math.min(L,O,D,E),B=Math.max(w,T,A,P)-I,R=Math.max(L,O,D,E)-j;return {x:I,y:j,width:B,height:R,polygon:[[w,L],[T,O],[A,D],[P,E]]}}getStyle(t){return c.getComputedStyle(this.element||this,"").getPropertyValue(t)}hasClass(t){return -1!==(""+this.attr("class")).split(" ").indexOf(t)}hide(){return this.attr({visibility:"hidden"})}htmlGetBBox(){return {height:0,width:0,x:0,y:0}}constructor(t,e){this.onEvents={},this.opacity=1,this.SVG_NS=d,this.element="span"===e||"body"===e?g(e):h.createElementNS(this.SVG_NS,e),this.renderer=t,this.styles={},v(this,"afterInit");}on(t,e){let{onEvents:i}=this;return i[t]&&i[t](),i[t]=p(this.element,t,e),this}opacitySetter(t,e,i){let s=Number(Number(t).toFixed(3));this.opacity=s,i.setAttribute(e,s);}reAlign(){this.alignOptions?.width&&"left"!==this.alignOptions.align&&(this.alignOptions.width=this.getBBox().width,this.placed=!1,this.align());}removeClass(t){return this.attr("class",(""+this.attr("class")).replace(M(t)?RegExp(`(^| )${t}( |$)`):t," ").replace(/ +/g," ").trim())}removeTextOutline(){let t=this.element.querySelector("tspan.highcharts-text-outline");t&&this.safeRemoveChild(t);}safeRemoveChild(t){let e=t.parentNode;e&&e.removeChild(t);}setRadialReference(t){let e=this.element.gradient&&this.renderer.gradients[this.element.gradient];return this.element.radialReference=t,e&&e.radAttr&&e.animate(this.renderer.getRadialAttr(t,e.radAttr)),this}shadow(t){let{renderer:e}=this,i=w(this.parentGroup?.rotation===90?{offsetX:-1,offsetY:-1}:{},k(t)?t:{}),s=e.shadowDefinition(i);return this.attr({filter:t?`url(${e.url}#${s})`:"none"})}show(t=!0){return this.attr({visibility:t?"inherit":"visible"})}"stroke-widthSetter"(t,e,i){this[e]=t,i.setAttribute(e,t);}strokeWidth(){if(!this.renderer.styledMode)return this["stroke-width"]||0;let t=this.getStyle("stroke-width"),e=0,i;return /px$/.test(t)?e=P(t):""!==t&&(u(i=h.createElementNS(d,"rect"),{width:t,"stroke-width":0}),this.element.parentNode.appendChild(i),e=i.getBBox().width,i.parentNode.removeChild(i)),e}symbolAttr(t){let e=this;I.symbolCustomAttribs.forEach(function(i){e[i]=A(t[i],e[i]);}),e.attr({d:e.renderer.symbols[e.symbolName](e.x,e.y,e.width,e.height,e)});}textSetter(t){t!==this.textStr&&(delete this.textPxLength,this.textStr=t,this.added&&this.renderer.buildText(this),this.reAlign());}titleSetter(t){let e=this.element,i=e.getElementsByTagName("title")[0]||h.createElementNS(this.SVG_NS,"title");e.insertBefore?e.insertBefore(i,e.firstChild):e.appendChild(i),i.textContent=O(A(t,""),[/<[^>]*>/g,""]).replace(/&lt;/g,"<").replace(/&gt;/g,">");}toFront(){let t=this.element;return t.parentNode.appendChild(t),this}translate(t,e){return this.attr({translateX:t,translateY:e})}updateTransform(t="transform"){let{element:e,matrix:i,rotation:s=0,rotationOriginX:r,rotationOriginY:o,scaleX:n,scaleY:a,translateX:h=0,translateY:l=0}=this,d=["translate("+h+","+l+")"];x(i)&&d.push("matrix("+i.join(",")+")"),s&&(d.push("rotate("+s+" "+A(r,e.getAttribute("x"),0)+" "+A(o,e.getAttribute("y")||0)+")"),this.text?.element.tagName==="SPAN"&&this.text.attr({rotation:s,rotationOriginX:(r||0)-this.padding,rotationOriginY:(o||0)-this.padding})),(x(n)||x(a))&&d.push("scale("+A(n,1)+" "+A(a,1)+")"),d.length&&!(this.text||this).textPath&&e.setAttribute(t,d.join(" "));}visibilitySetter(t,e,i){"inherit"===t?i.removeAttribute(e):this[e]!==t&&i.setAttribute(e,t),this[e]=t;}xGetter(t){return "circle"===this.element.nodeName&&("x"===t?t="cx":"y"===t&&(t="cy")),this._defaultGetter(t)}zIndexSetter(t,e){let i=this.renderer,s=this.parentGroup,r=(s||i).element||i.box,o=this.element,n=r===i.box,a,h,l,d=!1,c,p=this.added,u;if(x(t)?(o.setAttribute("data-z-index",t),t=+t,this[e]===t&&(p=!1)):x(this[e])&&o.removeAttribute("data-z-index"),this[e]=t,p){for((t=this.zIndex)&&s&&(s.handleZ=!0),u=(a=r.childNodes).length-1;u>=0&&!d;u--)c=!x(l=(h=a[u]).getAttribute("data-z-index")),h!==o&&(t<0&&c&&!n&&!u?(r.insertBefore(o,a[u]),d=!0):(P(l)<=t||c&&(!x(t)||t>=0))&&(r.insertBefore(o,a[u+1]),d=!0));d||(r.insertBefore(o,a[n?3:0]),d=!0);}return d}}return I.symbolCustomAttribs=["anchorX","anchorY","clockwise","end","height","innerR","r","start","width","x","y"],I.prototype.strokeSetter=I.prototype.fillSetter,I.prototype.yGetter=I.prototype.xGetter,I.prototype.matrixSetter=I.prototype.rotationOriginXSetter=I.prototype.rotationOriginYSetter=I.prototype.rotationSetter=I.prototype.scaleXSetter=I.prototype.scaleYSetter=I.prototype.translateXSetter=I.prototype.translateYSetter=I.prototype.verticalAlignSetter=function(t,e){this[e]=t,this.doTransform=!0;},I}),i(e,"Core/Renderer/SVG/SVGLabel.js",[e["Core/Renderer/SVG/SVGElement.js"],e["Core/Utilities.js"]],function(t,e){let{defined:i,extend:s,isNumber:r,merge:o,pick:n,removeEvent:a}=e;class h extends t{constructor(t,e,i,s,r,o,n,a,l,d){let c;super(t,"g"),this.paddingLeftSetter=this.paddingSetter,this.paddingRightSetter=this.paddingSetter,this.doUpdate=!1,this.textStr=e,this.x=i,this.y=s,this.anchorX=o,this.anchorY=n,this.baseline=l,this.className=d,this.addClass("button"===d?"highcharts-no-tooltip":"highcharts-label"),d&&this.addClass("highcharts-"+d),this.text=t.text(void 0,0,0,a).attr({zIndex:1}),"string"==typeof r&&((c=/^url\((.*?)\)$/.test(r))||this.renderer.symbols[r])&&(this.symbolKey=r),this.bBox=h.emptyBBox,this.padding=3,this.baselineOffset=0,this.needsBox=t.styledMode||c,this.deferredAttr={},this.alignFactor=0;}alignSetter(t){let e={left:0,center:.5,right:1}[t];e!==this.alignFactor&&(this.alignFactor=e,this.bBox&&r(this.xSetting)&&this.attr({x:this.xSetting}));}anchorXSetter(t,e){this.anchorX=t,this.boxAttr(e,Math.round(t)-this.getCrispAdjust()-this.xSetting);}anchorYSetter(t,e){this.anchorY=t,this.boxAttr(e,t-this.ySetting);}boxAttr(t,e){this.box?this.box.attr(t,e):this.deferredAttr[t]=e;}css(e){if(e){let t={};e=o(e),h.textProps.forEach(i=>{void 0!==e[i]&&(t[i]=e[i],delete e[i]);}),this.text.css(t),"fontSize"in t||"fontWeight"in t?this.updateTextPadding():("width"in t||"textOverflow"in t)&&this.updateBoxSize();}return t.prototype.css.call(this,e)}destroy(){a(this.element,"mouseenter"),a(this.element,"mouseleave"),this.text&&this.text.destroy(),this.box&&(this.box=this.box.destroy()),t.prototype.destroy.call(this);}fillSetter(t,e){t&&(this.needsBox=!0),this.fill=t,this.boxAttr(e,t);}getBBox(t,e){this.textStr&&0===this.bBox.width&&0===this.bBox.height&&this.updateBoxSize();let{padding:i,height:s=0,translateX:r=0,translateY:o=0,width:a=0}=this,h=n(this.paddingLeft,i),l=e??(this.rotation||0),d={width:a,height:s,x:r+this.bBox.x-h,y:o+this.bBox.y-i+this.baselineOffset};return l&&(d=this.getRotatedBox(d,l)),d}getCrispAdjust(){return (this.renderer.styledMode&&this.box?this.box.strokeWidth():this["stroke-width"]?parseInt(this["stroke-width"],10):0)%2/2}heightSetter(t){this.heightSetting=t,this.doUpdate=!0;}afterSetters(){super.afterSetters(),this.doUpdate&&(this.updateBoxSize(),this.doUpdate=!1);}onAdd(){this.text.add(this),this.attr({text:n(this.textStr,""),x:this.x||0,y:this.y||0}),this.box&&i(this.anchorX)&&this.attr({anchorX:this.anchorX,anchorY:this.anchorY});}paddingSetter(t,e){r(t)?t!==this[e]&&(this[e]=t,this.updateTextPadding()):this[e]=void 0;}rSetter(t,e){this.boxAttr(e,t);}strokeSetter(t,e){this.stroke=t,this.boxAttr(e,t);}"stroke-widthSetter"(t,e){t&&(this.needsBox=!0),this["stroke-width"]=t,this.boxAttr(e,t);}"text-alignSetter"(t){this.textAlign=t;}textSetter(t){void 0!==t&&this.text.attr({text:t}),this.updateTextPadding(),this.reAlign();}updateBoxSize(){let t;let e=this.text,o={},n=this.padding,a=this.bBox=(!r(this.widthSetting)||!r(this.heightSetting)||this.textAlign)&&i(e.textStr)?e.getBBox(void 0,0):h.emptyBBox;this.width=this.getPaddedWidth(),this.height=(this.heightSetting||a.height||0)+2*n;let l=this.renderer.fontMetrics(e);if(this.baselineOffset=n+Math.min((this.text.firstLineMetrics||l).b,a.height||1/0),this.heightSetting&&(this.baselineOffset+=(this.heightSetting-l.h)/2),this.needsBox&&!e.textPath){if(!this.box){let t=this.box=this.symbolKey?this.renderer.symbol(this.symbolKey):this.renderer.rect();t.addClass(("button"===this.className?"":"highcharts-label-box")+(this.className?" highcharts-"+this.className+"-box":"")),t.add(this);}t=this.getCrispAdjust(),o.x=t,o.y=(this.baseline?-this.baselineOffset:0)+t,o.width=Math.round(this.width),o.height=Math.round(this.height),this.box.attr(s(o,this.deferredAttr)),this.deferredAttr={};}}updateTextPadding(){let t=this.text;if(!t.textPath){this.updateBoxSize();let e=this.baseline?0:this.baselineOffset,s=n(this.paddingLeft,this.padding);i(this.widthSetting)&&this.bBox&&("center"===this.textAlign||"right"===this.textAlign)&&(s+=({center:.5,right:1})[this.textAlign]*(this.widthSetting-this.bBox.width)),(s!==t.x||e!==t.y)&&(t.attr("x",s),t.hasBoxWidthChanged&&(this.bBox=t.getBBox(!0)),void 0!==e&&t.attr("y",e)),t.x=s,t.y=e;}}widthSetter(t){this.widthSetting=r(t)?t:void 0,this.doUpdate=!0;}getPaddedWidth(){let t=this.padding,e=n(this.paddingLeft,t),i=n(this.paddingRight,t);return (this.widthSetting||this.bBox.width||0)+e+i}xSetter(t){this.x=t,this.alignFactor&&(t-=this.alignFactor*this.getPaddedWidth(),this["forceAnimate:x"]=!0),this.xSetting=Math.round(t),this.attr("translateX",this.xSetting);}ySetter(t){this.ySetting=this.y=Math.round(t),this.attr("translateY",this.ySetting);}}return h.emptyBBox={width:0,height:0,x:0,y:0},h.textProps=["color","direction","fontFamily","fontSize","fontStyle","fontWeight","lineHeight","textAlign","textDecoration","textOutline","textOverflow","whiteSpace","width"],h}),i(e,"Core/Renderer/SVG/Symbols.js",[e["Core/Utilities.js"]],function(t){let{defined:e,isNumber:i,pick:s}=t;function r(t,i,r,o,n){let a=[];if(n){let h=n.start||0,l=s(n.r,r),d=s(n.r,o||r),c=2e-4/(n.borderRadius?1:Math.max(l,1)),p=Math.abs((n.end||0)-h-2*Math.PI)<c,u=(n.end||0)-(p?c:0),g=n.innerR,f=s(n.open,p),m=Math.cos(h),x=Math.sin(h),y=Math.cos(u),b=Math.sin(u),v=s(n.longArc,u-h-Math.PI<c?0:1),S=["A",l,d,0,v,s(n.clockwise,1),t+l*y,i+d*b];S.params={start:h,end:u,cx:t,cy:i},a.push(["M",t+l*m,i+d*x],S),e(g)&&((S=["A",g,g,0,v,e(n.clockwise)?1-n.clockwise:0,t+g*m,i+g*x]).params={start:u,end:h,cx:t,cy:i},a.push(f?["M",t+g*y,i+g*b]:["L",t+g*y,i+g*b],S)),f||a.push(["Z"]);}return a}function o(t,e,i,s,r){return r&&r.r?n(t,e,i,s,r):[["M",t,e],["L",t+i,e],["L",t+i,e+s],["L",t,e+s],["Z"]]}function n(t,e,i,s,r){let o=r?.r||0;return [["M",t+o,e],["L",t+i-o,e],["A",o,o,0,0,1,t+i,e+o],["L",t+i,e+s-o],["A",o,o,0,0,1,t+i-o,e+s],["L",t+o,e+s],["A",o,o,0,0,1,t,e+s-o],["L",t,e+o],["A",o,o,0,0,1,t+o,e],["Z"]]}return {arc:r,callout:function(t,e,s,r,o){let a=Math.min(o&&o.r||0,s,r),h=a+6,l=o&&o.anchorX,d=o&&o.anchorY||0,c=n(t,e,s,r,{r:a});if(!i(l)||l<s&&l>0&&d<r&&d>0)return c;if(t+l>s-h){if(d>e+h&&d<e+r-h)c.splice(3,1,["L",t+s,d-6],["L",t+s+6,d],["L",t+s,d+6],["L",t+s,e+r-a]);else if(l<s){let i=d<e+h,o=i?e:e+r;c.splice(i?2:5,0,["L",l,d],["L",t+s-a,o]);}else c.splice(3,1,["L",t+s,r/2],["L",l,d],["L",t+s,r/2],["L",t+s,e+r-a]);}else if(t+l<h){if(d>e+h&&d<e+r-h)c.splice(7,1,["L",t,d+6],["L",t-6,d],["L",t,d-6],["L",t,e+a]);else if(l>0){let i=d<e+h,s=i?e:e+r;c.splice(i?1:6,0,["L",l,d],["L",t+a,s]);}else c.splice(7,1,["L",t,r/2],["L",l,d],["L",t,r/2],["L",t,e+a]);}else d>r&&l<s-h?c.splice(5,1,["L",l+6,e+r],["L",l,e+r+6],["L",l-6,e+r],["L",t+a,e+r]):d<0&&l>h&&c.splice(1,1,["L",l-6,e],["L",l,e-6],["L",l+6,e],["L",s-a,e]);return c},circle:function(t,e,i,s){return r(t+i/2,e+s/2,i/2,s/2,{start:.5*Math.PI,end:2.5*Math.PI,open:!1})},diamond:function(t,e,i,s){return [["M",t+i/2,e],["L",t+i,e+s/2],["L",t+i/2,e+s],["L",t,e+s/2],["Z"]]},rect:o,roundedRect:n,square:o,triangle:function(t,e,i,s){return [["M",t+i/2,e],["L",t+i,e+s],["L",t,e+s],["Z"]]},"triangle-down":function(t,e,i,s){return [["M",t,e],["L",t+i,e],["L",t+i/2,e+s],["Z"]]}}}),i(e,"Core/Renderer/SVG/TextBuilder.js",[e["Core/Renderer/HTML/AST.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e,i){let{doc:s,SVG_NS:r,win:o}=e,{attr:n,extend:a,fireEvent:h,isString:l,objectEach:d,pick:c}=i;return class{constructor(t){let e=t.styles;this.renderer=t.renderer,this.svgElement=t,this.width=t.textWidth,this.textLineHeight=e&&e.lineHeight,this.textOutline=e&&e.textOutline,this.ellipsis=!!(e&&"ellipsis"===e.textOverflow),this.noWrap=!!(e&&"nowrap"===e.whiteSpace);}buildSVG(){let e=this.svgElement,i=e.element,r=e.renderer,o=c(e.textStr,"").toString(),n=-1!==o.indexOf("<"),a=i.childNodes,h=!e.added&&r.box,d=[o,this.ellipsis,this.noWrap,this.textLineHeight,this.textOutline,e.getStyle("font-size"),this.width].join(",");if(d!==e.textCache){e.textCache=d,delete e.actualWidth;for(let t=a.length;t--;)i.removeChild(a[t]);if(n||this.ellipsis||this.width||e.textPath||-1!==o.indexOf(" ")&&(!this.noWrap||/<br.*?>/g.test(o))){if(""!==o){h&&h.appendChild(i);let s=new t(o);this.modifyTree(s.nodes),s.addToDOM(i),this.modifyDOM(),this.ellipsis&&-1!==(i.textContent||"").indexOf("…")&&e.attr("title",this.unescapeEntities(e.textStr||"",["&lt;","&gt;"])),h&&h.removeChild(i);}}else i.appendChild(s.createTextNode(this.unescapeEntities(o)));l(this.textOutline)&&e.applyTextOutline&&e.applyTextOutline(this.textOutline);}}modifyDOM(){let t;let e=this.svgElement,i=n(e.element,"x");for(e.firstLineMetrics=void 0;t=e.element.firstChild;)if(/^[\s\u200B]*$/.test(t.textContent||" "))e.element.removeChild(t);else break;[].forEach.call(e.element.querySelectorAll("tspan.highcharts-br"),(t,s)=>{t.nextSibling&&t.previousSibling&&(0===s&&1===t.previousSibling.nodeType&&(e.firstLineMetrics=e.renderer.fontMetrics(t.previousSibling)),n(t,{dy:this.getLineHeight(t.nextSibling),x:i}));});let a=this.width||0;if(!a)return;let h=(t,o)=>{let h=t.textContent||"",l=h.replace(/([^\^])-/g,"$1- ").split(" "),d=!this.noWrap&&(l.length>1||e.element.childNodes.length>1),c=this.getLineHeight(o),p=0,u=e.actualWidth;if(this.ellipsis)h&&this.truncate(t,h,void 0,0,Math.max(0,a-.8*c),(t,e)=>t.substring(0,e)+"…");else if(d){let h=[],d=[];for(;o.firstChild&&o.firstChild!==t;)d.push(o.firstChild),o.removeChild(o.firstChild);for(;l.length;)l.length&&!this.noWrap&&p>0&&(h.push(t.textContent||""),t.textContent=l.join(" ").replace(/- /g,"-")),this.truncate(t,void 0,l,0===p&&u||0,a,(t,e)=>l.slice(0,e).join(" ").replace(/- /g,"-")),u=e.actualWidth,p++;d.forEach(e=>{o.insertBefore(e,t);}),h.forEach(e=>{o.insertBefore(s.createTextNode(e),t);let a=s.createElementNS(r,"tspan");a.textContent="​",n(a,{dy:c,x:i}),o.insertBefore(a,t);});}},l=t=>{[].slice.call(t.childNodes).forEach(i=>{i.nodeType===o.Node.TEXT_NODE?h(i,t):(-1!==i.className.baseVal.indexOf("highcharts-br")&&(e.actualWidth=0),l(i));});};l(e.element);}getLineHeight(t){let e=t.nodeType===o.Node.TEXT_NODE?t.parentElement:t;return this.textLineHeight?parseInt(this.textLineHeight.toString(),10):this.renderer.fontMetrics(e||this.svgElement.element).h}modifyTree(t){let e=(i,s)=>{let{attributes:r={},children:o,style:n={},tagName:h}=i,l=this.renderer.styledMode;if("b"===h||"strong"===h?l?r.class="highcharts-strong":n.fontWeight="bold":("i"===h||"em"===h)&&(l?r.class="highcharts-emphasized":n.fontStyle="italic"),n&&n.color&&(n.fill=n.color),"br"===h){r.class="highcharts-br",i.textContent="​";let e=t[s+1];e&&e.textContent&&(e.textContent=e.textContent.replace(/^ +/gm,""));}else "a"===h&&o&&o.some(t=>"#text"===t.tagName)&&(i.children=[{children:o,tagName:"tspan"}]);"#text"!==h&&"a"!==h&&(i.tagName="tspan"),a(i,{attributes:r,style:n}),o&&o.filter(t=>"#text"!==t.tagName).forEach(e);};t.forEach(e),h(this.svgElement,"afterModifyTree",{nodes:t});}truncate(t,e,i,s,r,o){let n,a;let h=this.svgElement,{rotation:l}=h,d=[],c=i?1:0,p=(e||i||"").length,u=p,g=function(e,r){let o=r||e,n=t.parentNode;if(n&&void 0===d[o]&&n.getSubStringLength)try{d[o]=s+n.getSubStringLength(0,i?o+1:o);}catch(t){}return d[o]};if(h.rotation=0,s+(a=g(t.textContent.length))>r){for(;c<=p;)u=Math.ceil((c+p)/2),i&&(n=o(i,u)),a=g(u,n&&n.length-1),c===p?c=p+1:a>r?p=u-1:c=u;0===p?t.textContent="":e&&p===e.length-1||(t.textContent=n||o(e||i,u));}i&&i.splice(0,u),h.actualWidth=a,h.rotation=l;}unescapeEntities(t,e){return d(this.renderer.escapes,function(i,s){e&&-1!==e.indexOf(i)||(t=t.toString().replace(RegExp(i,"g"),s));}),t}}}),i(e,"Core/Renderer/SVG/SVGRenderer.js",[e["Core/Renderer/HTML/AST.js"],e["Core/Defaults.js"],e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Renderer/RendererRegistry.js"],e["Core/Renderer/SVG/SVGElement.js"],e["Core/Renderer/SVG/SVGLabel.js"],e["Core/Renderer/SVG/Symbols.js"],e["Core/Renderer/SVG/TextBuilder.js"],e["Core/Utilities.js"]],function(t,e,i,s,r,o,n,a,h,l){let d;let{defaultOptions:c}=e,{charts:p,deg2rad:u,doc:g,isFirefox:f,isMS:m,isWebKit:x,noop:y,SVG_NS:b,symbolSizes:v,win:S}=s,{addEvent:C,attr:k,createElement:M,crisp:w,css:T,defined:A,destroyObjectProperties:P,extend:L,isArray:O,isNumber:D,isObject:E,isString:I,merge:j,pick:B,pInt:R,replaceNested:z,uniqueKey:N}=l;class W{constructor(t,e,i,s,r,o,n){let a,h;let l=this.createElement("svg").attr({version:"1.1",class:"highcharts-root"}),d=l.element;n||l.css(this.getStyle(s||{})),t.appendChild(d),k(t,"dir","ltr"),-1===t.innerHTML.indexOf("xmlns")&&k(d,"xmlns",this.SVG_NS),this.box=d,this.boxWrapper=l,this.alignedObjects=[],this.url=this.getReferenceURL(),this.createElement("desc").add().element.appendChild(g.createTextNode("Created with Highcharts 11.4.8")),this.defs=this.createElement("defs").add(),this.allowHTML=o,this.forExport=r,this.styledMode=n,this.gradients={},this.cache={},this.cacheKeys=[],this.imgCount=0,this.rootFontSize=l.getStyle("font-size"),this.setSize(e,i,!1),f&&t.getBoundingClientRect&&((a=function(){T(t,{left:0,top:0}),h=t.getBoundingClientRect(),T(t,{left:Math.ceil(h.left)-h.left+"px",top:Math.ceil(h.top)-h.top+"px"});})(),this.unSubPixelFix=C(S,"resize",a));}definition(e){return new t([e]).addToDOM(this.defs.element)}getReferenceURL(){if((f||x)&&g.getElementsByTagName("base").length){if(!A(d)){let e=N(),i=new t([{tagName:"svg",attributes:{width:8,height:8},children:[{tagName:"defs",children:[{tagName:"clipPath",attributes:{id:e},children:[{tagName:"rect",attributes:{width:4,height:4}}]}]},{tagName:"rect",attributes:{id:"hitme",width:8,height:8,"clip-path":`url(#${e})`,fill:"rgba(0,0,0,0.001)"}}]}]).addToDOM(g.body);T(i,{position:"fixed",top:0,left:0,zIndex:9e5});let s=g.elementFromPoint(6,6);d="hitme"===(s&&s.id),g.body.removeChild(i);}if(d)return z(S.location.href.split("#")[0],[/<[^>]*>/g,""],[/([\('\)])/g,"\\$1"],[/ /g,"%20"])}return ""}getStyle(t){return this.style=L({fontFamily:"Helvetica, Arial, sans-serif",fontSize:"1rem"},t),this.style}setStyle(t){this.boxWrapper.css(this.getStyle(t));}isHidden(){return !this.boxWrapper.getBBox().width}destroy(){let t=this.defs;return this.box=null,this.boxWrapper=this.boxWrapper.destroy(),P(this.gradients||{}),this.gradients=null,this.defs=t.destroy(),this.unSubPixelFix&&this.unSubPixelFix(),this.alignedObjects=null,null}createElement(t){return new this.Element(this,t)}getRadialAttr(t,e){return {cx:t[0]-t[2]/2+(e.cx||0)*t[2],cy:t[1]-t[2]/2+(e.cy||0)*t[2],r:(e.r||0)*t[2]}}shadowDefinition(t){let e=[`highcharts-drop-shadow-${this.chartIndex}`,...Object.keys(t).map(e=>`${e}-${t[e]}`)].join("-").toLowerCase().replace(/[^a-z\d\-]/g,""),i=j({color:"#000000",offsetX:1,offsetY:1,opacity:.15,width:5},t);return this.defs.element.querySelector(`#${e}`)||this.definition({tagName:"filter",attributes:{id:e,filterUnits:i.filterUnits},children:this.getShadowFilterContent(i)}),e}getShadowFilterContent(t){return [{tagName:"feDropShadow",attributes:{dx:t.offsetX,dy:t.offsetY,"flood-color":t.color,"flood-opacity":Math.min(5*t.opacity,1),stdDeviation:t.width/2}}]}buildText(t){new h(t).buildSVG();}getContrast(t){let e=i.parse(t).rgba.map(t=>{let e=t/255;return e<=.03928?e/12.92:Math.pow((e+.055)/1.055,2.4)}),s=.2126*e[0]+.7152*e[1]+.0722*e[2];return 1.05/(s+.05)>(s+.05)/.05?"#FFFFFF":"#000000"}button(e,i,s,r,o={},n,a,h,l,d){let p=this.label(e,i,s,l,void 0,void 0,d,void 0,"button"),u=this.styledMode,g=arguments,f=0;o=j(c.global.buttonTheme,o),u&&(delete o.fill,delete o.stroke,delete o["stroke-width"]);let x=o.states||{},y=o.style||{};delete o.states,delete o.style;let b=[t.filterUserAttributes(o)],v=[y];return u||["hover","select","disabled"].forEach((e,i)=>{b.push(j(b[0],t.filterUserAttributes(g[i+5]||x[e]||{}))),v.push(b[i+1].style),delete b[i+1].style;}),C(p.element,m?"mouseover":"mouseenter",function(){3!==f&&p.setState(1);}),C(p.element,m?"mouseout":"mouseleave",function(){3!==f&&p.setState(f);}),p.setState=(t=0)=>{if(1!==t&&(p.state=f=t),p.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+["normal","hover","pressed","disabled"][t]),!u){p.attr(b[t]);let e=v[t];E(e)&&p.css(e);}},p.attr(b[0]),!u&&(p.css(L({cursor:"default"},y)),d&&p.text.css({pointerEvents:"none"})),p.on("touchstart",t=>t.stopPropagation()).on("click",function(t){3!==f&&r.call(p,t);})}crispLine(t,e){let[i,s]=t;return A(i[1])&&i[1]===s[1]&&(i[1]=s[1]=w(i[1],e)),A(i[2])&&i[2]===s[2]&&(i[2]=s[2]=w(i[2],e)),t}path(t){let e=this.styledMode?{}:{fill:"none"};return O(t)?e.d=t:E(t)&&L(e,t),this.createElement("path").attr(e)}circle(t,e,i){let s=E(t)?t:void 0===t?{}:{x:t,y:e,r:i},r=this.createElement("circle");return r.xSetter=r.ySetter=function(t,e,i){i.setAttribute("c"+e,t);},r.attr(s)}arc(t,e,i,s,r,o){let n;E(t)?(e=(n=t).y,i=n.r,s=n.innerR,r=n.start,o=n.end,t=n.x):n={innerR:s,start:r,end:o};let a=this.symbol("arc",t,e,i,i,n);return a.r=i,a}rect(t,e,i,s,r,o){let n=E(t)?t:void 0===t?{}:{x:t,y:e,r,width:Math.max(i||0,0),height:Math.max(s||0,0)},a=this.createElement("rect");return this.styledMode||(void 0!==o&&(n["stroke-width"]=o,L(n,a.crisp(n))),n.fill="none"),a.rSetter=function(t,e,i){a.r=t,k(i,{rx:t,ry:t});},a.rGetter=function(){return a.r||0},a.attr(n)}roundedRect(t){return this.symbol("roundedRect").attr(t)}setSize(t,e,i){this.width=t,this.height=e,this.boxWrapper.animate({width:t,height:e},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")});},duration:B(i,!0)?void 0:0}),this.alignElements();}g(t){let e=this.createElement("g");return t?e.attr({class:"highcharts-"+t}):e}image(t,e,i,s,r,o){let n={preserveAspectRatio:"none"};D(e)&&(n.x=e),D(i)&&(n.y=i),D(s)&&(n.width=s),D(r)&&(n.height=r);let a=this.createElement("image").attr(n),h=function(e){a.attr({href:t}),o.call(a,e);};if(o){a.attr({href:"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="});let e=new S.Image;C(e,"load",h),e.src=t,e.complete&&h({});}else a.attr({href:t});return a}symbol(t,e,i,s,r,o){let n,a,h,l;let d=this,c=/^url\((.*?)\)$/,u=c.test(t),f=!u&&(this.symbols[t]?t:"circle"),m=f&&this.symbols[f];if(m)"number"==typeof e&&(a=m.call(this.symbols,e||0,i||0,s||0,r||0,o)),n=this.path(a),d.styledMode||n.attr("fill","none"),L(n,{symbolName:f||void 0,x:e,y:i,width:s,height:r}),o&&L(n,o);else if(u){h=t.match(c)[1];let s=n=this.image(h);s.imgwidth=B(o&&o.width,v[h]&&v[h].width),s.imgheight=B(o&&o.height,v[h]&&v[h].height),l=t=>t.attr({width:t.width,height:t.height}),["width","height"].forEach(t=>{s[`${t}Setter`]=function(t,e){this[e]=t;let{alignByTranslate:i,element:s,width:r,height:n,imgwidth:a,imgheight:h}=this,l="width"===e?a:h,d=1;o&&"within"===o.backgroundSize&&r&&n&&a&&h?(d=Math.min(r/a,n/h),k(s,{width:Math.round(a*d),height:Math.round(h*d)})):s&&l&&s.setAttribute(e,l),!i&&a&&h&&this.translate(((r||0)-a*d)/2,((n||0)-h*d)/2);};}),A(e)&&s.attr({x:e,y:i}),s.isImg=!0,s.symbolUrl=t,A(s.imgwidth)&&A(s.imgheight)?l(s):(s.attr({width:0,height:0}),M("img",{onload:function(){let t=p[d.chartIndex];0===this.width&&(T(this,{position:"absolute",top:"-999em"}),g.body.appendChild(this)),v[h]={width:this.width,height:this.height},s.imgwidth=this.width,s.imgheight=this.height,s.element&&l(s),this.parentNode&&this.parentNode.removeChild(this),d.imgCount--,d.imgCount||!t||t.hasLoaded||t.onload();},src:h}),this.imgCount++);}return n}clipRect(t,e,i,s){return this.rect(t,e,i,s,0)}text(t,e,i,s){let r={};if(s&&(this.allowHTML||!this.forExport))return this.html(t,e,i);r.x=Math.round(e||0),i&&(r.y=Math.round(i)),A(t)&&(r.text=t);let o=this.createElement("text").attr(r);return s&&(!this.forExport||this.allowHTML)||(o.xSetter=function(t,e,i){let s=i.getElementsByTagName("tspan"),r=i.getAttribute(e);for(let i=0,o;i<s.length;i++)(o=s[i]).getAttribute(e)===r&&o.setAttribute(e,t);i.setAttribute(e,t);}),o}fontMetrics(t){let e=R(o.prototype.getStyle.call(t,"font-size")||0),i=e<24?e+3:Math.round(1.2*e),s=Math.round(.8*i);return {h:i,b:s,f:e}}rotCorr(t,e,i){let s=t;return e&&i&&(s=Math.max(s*Math.cos(e*u),4)),{x:-t/3*Math.sin(e*u),y:s}}pathToSegments(t){let e=[],i=[],s={A:8,C:7,H:2,L:3,M:3,Q:5,S:5,T:3,V:2};for(let r=0;r<t.length;r++)I(i[0])&&D(t[r])&&i.length===s[i[0].toUpperCase()]&&t.splice(r,0,i[0].replace("M","L").replace("m","l")),"string"==typeof t[r]&&(i.length&&e.push(i.slice(0)),i.length=0),i.push(t[r]);return e.push(i.slice(0)),e}label(t,e,i,s,r,o,a,h,l){return new n(this,t,e,i,s,r,o,a,h,l)}alignElements(){this.alignedObjects.forEach(t=>t.align());}}return L(W.prototype,{Element:o,SVG_NS:b,escapes:{"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"},symbols:a,draw:y}),r.registerRendererType("svg",W,!0),W}),i(e,"Core/Renderer/HTML/HTMLElement.js",[e["Core/Renderer/HTML/AST.js"],e["Core/Globals.js"],e["Core/Renderer/SVG/SVGElement.js"],e["Core/Utilities.js"]],function(t,e,i,s){let{composed:r}=e,{attr:o,css:n,createElement:a,defined:h,extend:l,pInt:d,pushUnique:c}=s;function p(t,e,s){let r=this.div?.style||s.style;i.prototype[`${e}Setter`].call(this,t,e,s),r&&(r[e]=t);}let u=(t,e)=>{if(!t.div){let s=o(t.element,"class"),r=t.css,n=a("div",s?{className:s}:void 0,{position:"absolute",left:`${t.translateX||0}px`,top:`${t.translateY||0}px`,...t.styles,display:t.display,opacity:t.opacity,visibility:t.visibility},t.parentGroup?.div||e);t.classSetter=(t,e,i)=>{i.setAttribute("class",t),n.className=t;},t.translateXSetter=t.translateYSetter=(e,i)=>{t[i]=e,n.style["translateX"===i?"left":"top"]=`${e}px`,t.doTransform=!0;},t.opacitySetter=t.visibilitySetter=p,t.css=e=>(r.call(t,e),e.cursor&&(n.style.cursor=e.cursor),e.pointerEvents&&(n.style.pointerEvents=e.pointerEvents),t),t.on=function(){return i.prototype.on.apply({element:n,onEvents:t.onEvents},arguments),t},t.div=n;}return t.div};class g extends i{static compose(t){c(r,this.compose)&&(t.prototype.html=function(t,e,i){return new g(this,"span").attr({text:t,x:Math.round(e),y:Math.round(i)})});}constructor(t,e){super(t,e),this.css({position:"absolute",...t.styledMode?{}:{fontFamily:t.style.fontFamily,fontSize:t.style.fontSize}}),this.element.style.whiteSpace="nowrap";}getSpanCorrection(t,e,i){this.xCorr=-t*i,this.yCorr=-e;}css(t){let e;let{element:i}=this,s="SPAN"===i.tagName&&t&&"width"in t,r=s&&t.width;return s&&(delete t.width,this.textWidth=d(r)||void 0,e=!0),t?.textOverflow==="ellipsis"&&(t.whiteSpace="nowrap",t.overflow="hidden"),l(this.styles,t),n(i,t),e&&this.updateTransform(),this}htmlGetBBox(){let{element:t}=this;return {x:t.offsetLeft,y:t.offsetTop,width:t.offsetWidth,height:t.offsetHeight}}updateTransform(){if(!this.added){this.alignOnAdd=!0;return}let{element:t,renderer:e,rotation:i,rotationOriginX:s,rotationOriginY:r,styles:o,textAlign:a="left",textWidth:l,translateX:d=0,translateY:c=0,x:p=0,y:u=0}=this,g={left:0,center:.5,right:1}[a],f=o.whiteSpace;if(n(t,{marginLeft:`${d}px`,marginTop:`${c}px`}),"SPAN"===t.tagName){let o=[i,a,t.innerHTML,l,this.textAlign].join(","),d=-(this.parentGroup?.padding*1)||0,c,m=!1;if(l!==this.oldTextWidth){let e=this.textPxLength?this.textPxLength:(n(t,{width:"",whiteSpace:f||"nowrap"}),t.offsetWidth),s=l||0;(s>this.oldTextWidth||e>s)&&(/[ \-]/.test(t.textContent||t.innerText)||"ellipsis"===t.style.textOverflow)&&(n(t,{width:e>s||i?l+"px":"auto",display:"block",whiteSpace:f||"normal"}),this.oldTextWidth=l,m=!0);}this.hasBoxWidthChanged=m,o!==this.cTT&&(c=e.fontMetrics(t).b,h(i)&&(i!==(this.oldRotation||0)||a!==this.oldAlign)&&this.setSpanRotation(i,d,d),this.getSpanCorrection(!h(i)&&this.textPxLength||t.offsetWidth,c,g));let{xCorr:x=0,yCorr:y=0}=this,b=(s??p)-x-p-d,v=(r??u)-y-u-d;n(t,{left:`${p+x}px`,top:`${u+y}px`,transformOrigin:`${b}px ${v}px`}),this.cTT=o,this.oldRotation=i,this.oldAlign=a;}}setSpanRotation(t,e,i){n(this.element,{transform:`rotate(${t}deg)`,transformOrigin:`${e}% ${i}px`});}add(t){let e;let i=this.renderer.box.parentNode,s=[];if(this.parentGroup=t,t&&!(e=t.div)){let r=t;for(;r;)s.push(r),r=r.parentGroup;for(let t of s.reverse())e=u(t,i);}return (e||i).appendChild(this.element),this.added=!0,this.alignOnAdd&&this.updateTransform(),this}textSetter(e){e!==this.textStr&&(delete this.bBox,delete this.oldTextWidth,t.setElementHTML(this.element,e??""),this.textStr=e,this.doTransform=!0);}alignSetter(t){this.alignValue=this.textAlign=t,this.doTransform=!0;}xSetter(t,e){this[e]=t,this.doTransform=!0;}}let f=g.prototype;return f.visibilitySetter=f.opacitySetter=p,f.ySetter=f.rotationSetter=f.rotationOriginXSetter=f.rotationOriginYSetter=f.xSetter,g}),i(e,"Core/Axis/AxisDefaults.js",[],function(){var t,e;return (e=t||(t={})).xAxis={alignTicks:!0,allowDecimals:void 0,panningEnabled:!0,zIndex:2,zoomEnabled:!0,dateTimeLabelFormats:{millisecond:{main:"%H:%M:%S.%L",range:!1},second:{main:"%H:%M:%S",range:!1},minute:{main:"%H:%M",range:!1},hour:{main:"%H:%M",range:!1},day:{main:"%e %b"},week:{main:"%e %b"},month:{main:"%b '%y"},year:{main:"%Y"}},endOnTick:!1,gridLineDashStyle:"Solid",gridZIndex:1,labels:{autoRotationLimit:80,distance:15,enabled:!0,indentation:10,overflow:"justify",reserveSpace:void 0,rotation:void 0,staggerLines:0,step:0,useHTML:!1,zIndex:7,style:{color:"#333333",cursor:"default",fontSize:"0.8em"}},maxPadding:.01,minorGridLineDashStyle:"Solid",minorTickLength:2,minorTickPosition:"outside",minorTicksPerMajor:5,minPadding:.01,offset:void 0,reversed:void 0,reversedStacks:!1,showEmpty:!0,showFirstLabel:!0,showLastLabel:!0,startOfWeek:1,startOnTick:!1,tickLength:10,tickPixelInterval:100,tickmarkPlacement:"between",tickPosition:"outside",title:{align:"middle",useHTML:!1,x:0,y:0,style:{color:"#666666",fontSize:"0.8em"}},visible:!0,minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#333333",lineWidth:1,gridLineColor:"#e6e6e6",gridLineWidth:void 0,tickColor:"#333333"},e.yAxis={reversedStacks:!0,endOnTick:!0,maxPadding:.05,minPadding:.05,tickPixelInterval:72,showLastLabel:!0,labels:{x:void 0},startOnTick:!0,title:{text:"Values"},stackLabels:{animation:{},allowOverlap:!1,enabled:!1,crop:!0,overflow:"justify",formatter:function(){let{numberFormatter:t}=this.axis.chart;return t(this.total||0,-1)},style:{color:"#000000",fontSize:"0.7em",fontWeight:"bold",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0},t}),i(e,"Core/Foundation.js",[e["Core/Utilities.js"]],function(t){var e;let{addEvent:i,isFunction:s,objectEach:r,removeEvent:o}=t;return (e||(e={})).registerEventOptions=function(t,e){t.eventOptions=t.eventOptions||{},r(e.events,function(e,r){t.eventOptions[r]!==e&&(t.eventOptions[r]&&(o(t,r,t.eventOptions[r]),delete t.eventOptions[r]),s(e)&&(t.eventOptions[r]=e,i(t,r,e,{order:0})));});},e}),i(e,"Core/Axis/Tick.js",[e["Core/Templating.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e,i){let{deg2rad:s}=e,{clamp:r,correctFloat:o,defined:n,destroyObjectProperties:a,extend:h,fireEvent:l,isNumber:d,merge:c,objectEach:p,pick:u}=i;return class{constructor(t,e,i,s,r){this.isNew=!0,this.isNewLabel=!0,this.axis=t,this.pos=e,this.type=i||"",this.parameters=r||{},this.tickmarkOffset=this.parameters.tickmarkOffset,this.options=this.parameters.options,l(this,"init"),i||s||this.addLabel();}addLabel(){let e=this,i=e.axis,s=i.options,r=i.chart,a=i.categories,c=i.logarithmic,p=i.names,g=e.pos,f=u(e.options&&e.options.labels,s.labels),m=i.tickPositions,x=g===m[0],y=g===m[m.length-1],b=(!f.step||1===f.step)&&1===i.tickInterval,v=m.info,S=e.label,C,k,M,w=this.parameters.category||(a?u(a[g],p[g],g):g);c&&d(w)&&(w=o(c.lin2log(w))),i.dateTime&&(v?C=(k=r.time.resolveDTLFormat(s.dateTimeLabelFormats[!s.grid&&v.higherRanks[g]||v.unitName])).main:d(w)&&(C=i.dateTime.getXDateFormat(w,s.dateTimeLabelFormats||{}))),e.isFirst=x,e.isLast=y;let T={axis:i,chart:r,dateTimeLabelFormat:C,isFirst:x,isLast:y,pos:g,tick:e,tickPositionInfo:v,value:w};l(this,"labelFormat",T);let A=e=>f.formatter?f.formatter.call(e,e):f.format?(e.text=i.defaultLabelFormatter.call(e),t.format(f.format,e,r)):i.defaultLabelFormatter.call(e),P=A.call(T,T),L=k&&k.list;L?e.shortenLabel=function(){for(M=0;M<L.length;M++)if(h(T,{dateTimeLabelFormat:L[M]}),S.attr({text:A.call(T,T)}),S.getBBox().width<i.getSlotWidth(e)-2*(f.padding||0))return;S.attr({text:""});}:e.shortenLabel=void 0,b&&i._addedPlotLB&&e.moveLabel(P,f),n(S)||e.movedLabel?S&&S.textStr!==P&&!b&&(!S.textWidth||f.style.width||S.styles.width||S.css({width:null}),S.attr({text:P}),S.textPxLength=S.getBBox().width):(e.label=S=e.createLabel(P,f),e.rotation=0);}createLabel(t,e,i){let s=this.axis,r=s.chart,o=n(t)&&e.enabled?r.renderer.text(t,i?.x,i?.y,e.useHTML).add(s.labelGroup):void 0;return o&&(r.styledMode||o.css(c(e.style)),o.textPxLength=o.getBBox().width),o}destroy(){a(this,this.axis);}getPosition(t,e,i,s){let n=this.axis,a=n.chart,h=s&&a.oldChartHeight||a.chartHeight,d={x:t?o(n.translate(e+i,void 0,void 0,s)+n.transB):n.left+n.offset+(n.opposite?(s&&a.oldChartWidth||a.chartWidth)-n.right-n.left:0),y:t?h-n.bottom+n.offset-(n.opposite?n.height:0):o(h-n.translate(e+i,void 0,void 0,s)-n.transB)};return d.y=r(d.y,-1e9,1e9),l(this,"afterGetPosition",{pos:d}),d}getLabelPosition(t,e,i,r,o,a,h,d){let c,p;let g=this.axis,f=g.transA,m=g.isLinked&&g.linkedParent?g.linkedParent.reversed:g.reversed,x=g.staggerLines,y=g.tickRotCorr||{x:0,y:0},b=r||g.reserveSpaceDefault?0:-g.labelOffset*("center"===g.labelAlign?.5:1),v=o.distance,S={};return c=0===g.side?i.rotation?-v:-i.getBBox().height:2===g.side?y.y+v:Math.cos(i.rotation*s)*(y.y-i.getBBox(!1,0).height/2),n(o.y)&&(c=0===g.side&&g.horiz?o.y+c:o.y),t=t+u(o.x,[0,1,0,-1][g.side]*v)+b+y.x-(a&&r?a*f*(m?-1:1):0),e=e+c-(a&&!r?a*f*(m?1:-1):0),x&&(p=h/(d||1)%x,g.opposite&&(p=x-p-1),e+=p*(g.labelOffset/x)),S.x=t,S.y=Math.round(e),l(this,"afterGetLabelPosition",{pos:S,tickmarkOffset:a,index:h}),S}getLabelSize(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0}getMarkPath(t,e,i,s,r=!1,o){return o.crispLine([["M",t,e],["L",t+(r?0:-i),e+(r?i:0)]],s)}handleOverflow(t){let e=this.axis,i=e.options.labels,r=t.x,o=e.chart.chartWidth,n=e.chart.spacing,a=u(e.labelLeft,Math.min(e.pos,n[3])),h=u(e.labelRight,Math.max(e.isRadial?0:e.pos+e.len,o-n[1])),l=this.label,d=this.rotation,c={left:0,center:.5,right:1}[e.labelAlign||l.attr("align")],p=l.getBBox().width,g=e.getSlotWidth(this),f={},m=g,x=1,y,b,v;d||"justify"!==i.overflow?d<0&&r-c*p<a?v=Math.round(r/Math.cos(d*s)-a):d>0&&r+c*p>h&&(v=Math.round((o-r)/Math.cos(d*s))):(y=r-c*p,b=r+(1-c)*p,y<a?m=t.x+m*(1-c)-a:b>h&&(m=h-t.x+m*c,x=-1),(m=Math.min(g,m))<g&&"center"===e.labelAlign&&(t.x+=x*(g-m-c*(g-Math.min(p,m)))),(p>m||e.autoRotation&&(l.styles||{}).width)&&(v=m)),v&&(this.shortenLabel?this.shortenLabel():(f.width=Math.floor(v)+"px",(i.style||{}).textOverflow||(f.textOverflow="ellipsis"),l.css(f)));}moveLabel(t,e){let i=this,s=i.label,r=i.axis,o=!1,n;s&&s.textStr===t?(i.movedLabel=s,o=!0,delete i.label):p(r.ticks,function(e){o||e.isNew||e===i||!e.label||e.label.textStr!==t||(i.movedLabel=e.label,o=!0,e.labelPos=i.movedLabel.xy,delete e.label);}),!o&&(i.labelPos||s)&&(n=i.labelPos||s.xy,i.movedLabel=i.createLabel(t,e,n),i.movedLabel&&i.movedLabel.attr({opacity:0}));}render(t,e,i){let s=this.axis,r=s.horiz,n=this.pos,a=u(this.tickmarkOffset,s.tickmarkOffset),h=this.getPosition(r,n,a,e),d=h.x,c=h.y,p=s.pos,g=p+s.len,f=r?d:c;!s.chart.polar&&this.isNew&&(o(f)<p||f>g)&&(i=0);let m=u(i,this.label&&this.label.newOpacity,1);i=u(i,1),this.isActive=!0,this.renderGridLine(e,i),this.renderMark(h,i),this.renderLabel(h,e,m,t),this.isNew=!1,l(this,"afterRender");}renderGridLine(t,e){let i=this.axis,s=i.options,r={},o=this.pos,n=this.type,a=u(this.tickmarkOffset,i.tickmarkOffset),h=i.chart.renderer,l=this.gridLine,d,c=s.gridLineWidth,p=s.gridLineColor,g=s.gridLineDashStyle;"minor"===this.type&&(c=s.minorGridLineWidth,p=s.minorGridLineColor,g=s.minorGridLineDashStyle),l||(i.chart.styledMode||(r.stroke=p,r["stroke-width"]=c||0,r.dashstyle=g),n||(r.zIndex=1),t&&(e=0),this.gridLine=l=h.path().attr(r).addClass("highcharts-"+(n?n+"-":"")+"grid-line").add(i.gridGroup)),l&&(d=i.getPlotLinePath({value:o+a,lineWidth:l.strokeWidth(),force:"pass",old:t,acrossPanes:!1}))&&l[t||this.isNew?"attr":"animate"]({d:d,opacity:e});}renderMark(t,e){let i=this.axis,s=i.options,r=i.chart.renderer,o=this.type,n=i.tickSize(o?o+"Tick":"tick"),a=t.x,h=t.y,l=u(s["minor"!==o?"tickWidth":"minorTickWidth"],!o&&i.isXAxis?1:0),d=s["minor"!==o?"tickColor":"minorTickColor"],c=this.mark,p=!c;n&&(i.opposite&&(n[0]=-n[0]),c||(this.mark=c=r.path().addClass("highcharts-"+(o?o+"-":"")+"tick").add(i.axisGroup),i.chart.styledMode||c.attr({stroke:d,"stroke-width":l})),c[p?"attr":"animate"]({d:this.getMarkPath(a,h,n[0],c.strokeWidth(),i.horiz,r),opacity:e}));}renderLabel(t,e,i,s){let r=this.axis,o=r.horiz,n=r.options,a=this.label,h=n.labels,l=h.step,c=u(this.tickmarkOffset,r.tickmarkOffset),p=t.x,g=t.y,f=!0;a&&d(p)&&(a.xy=t=this.getLabelPosition(p,g,a,o,h,c,s,l),(!this.isFirst||this.isLast||n.showFirstLabel)&&(!this.isLast||this.isFirst||n.showLastLabel)?!o||h.step||h.rotation||e||0===i||this.handleOverflow(t):f=!1,l&&s%l&&(f=!1),f&&d(t.y)?(t.opacity=i,a[this.isNewLabel?"attr":"animate"](t).show(!0),this.isNewLabel=!1):(a.hide(),this.isNewLabel=!0));}replaceMovedLabel(){let t=this.label,e=this.axis;t&&!this.isNew&&(t.animate({opacity:0},void 0,t.destroy),delete this.label),e.isDirty=!0,this.label=this.movedLabel,delete this.movedLabel;}}}),i(e,"Core/Axis/Axis.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Axis/AxisDefaults.js"],e["Core/Color/Color.js"],e["Core/Defaults.js"],e["Core/Foundation.js"],e["Core/Globals.js"],e["Core/Axis/Tick.js"],e["Core/Utilities.js"]],function(t,e,i,s,r,o,n,a){let{animObject:h}=t,{xAxis:l,yAxis:d}=e,{defaultOptions:c}=s,{registerEventOptions:p}=r,{deg2rad:u}=o,{arrayMax:g,arrayMin:f,clamp:m,correctFloat:x,defined:y,destroyObjectProperties:b,erase:v,error:S,extend:C,fireEvent:k,getClosestDistance:M,insertItem:w,isArray:T,isNumber:A,isString:P,merge:L,normalizeTickInterval:O,objectEach:D,pick:E,relativeLength:I,removeEvent:j,splat:B,syncTimeout:R}=a,z=(t,e)=>O(e,void 0,void 0,E(t.options.allowDecimals,e<.5||void 0!==t.tickAmount),!!t.tickAmount);C(c,{xAxis:l,yAxis:L(l,d)});class N{constructor(t,e,i){this.init(t,e,i);}init(t,e,i=this.coll){let s="xAxis"===i,r=this.isZAxis||(t.inverted?!s:s);this.chart=t,this.horiz=r,this.isXAxis=s,this.coll=i,k(this,"init",{userOptions:e}),this.opposite=E(e.opposite,this.opposite),this.side=E(e.side,this.side,r?this.opposite?0:2:this.opposite?1:3),this.setOptions(e);let o=this.options,n=o.labels;this.type??(this.type=o.type||"linear"),this.uniqueNames??(this.uniqueNames=o.uniqueNames??!0),k(this,"afterSetType"),this.userOptions=e,this.minPixelPadding=0,this.reversed=E(o.reversed,this.reversed),this.visible=o.visible,this.zoomEnabled=o.zoomEnabled,this.hasNames="category"===this.type||!0===o.categories,this.categories=T(o.categories)&&o.categories||(this.hasNames?[]:void 0),this.names||(this.names=[],this.names.keys={}),this.plotLinesAndBandsGroups={},this.positiveValuesOnly=!!this.logarithmic,this.isLinked=y(o.linkedTo),this.ticks={},this.labelEdge=[],this.minorTicks={},this.plotLinesAndBands=[],this.alternateBands={},this.len??(this.len=0),this.minRange=this.userMinRange=o.minRange||o.maxZoom,this.range=o.range,this.offset=o.offset||0,this.max=void 0,this.min=void 0;let a=E(o.crosshair,B(t.options.tooltip.crosshairs)[s?0:1]);this.crosshair=!0===a?{}:a,-1===t.axes.indexOf(this)&&(s?t.axes.splice(t.xAxis.length,0,this):t.axes.push(this),w(this,t[this.coll])),t.orderItems(this.coll),this.series=this.series||[],t.inverted&&!this.isZAxis&&s&&!y(this.reversed)&&(this.reversed=!0),this.labelRotation=A(n.rotation)?n.rotation:void 0,p(this,o),k(this,"afterInit");}setOptions(t){let e=this.horiz?{labels:{autoRotation:[-45],padding:4},margin:15}:{labels:{padding:1},title:{rotation:90*this.side}};this.options=L(e,c[this.coll],t),k(this,"afterSetOptions",{userOptions:t});}defaultLabelFormatter(){let t=this.axis,{numberFormatter:e}=this.chart,i=A(this.value)?this.value:NaN,s=t.chart.time,r=t.categories,o=this.dateTimeLabelFormat,n=c.lang,a=n.numericSymbols,h=n.numericSymbolMagnitude||1e3,l=t.logarithmic?Math.abs(i):t.tickInterval,d=a&&a.length,p,u;if(r)u=`${this.value}`;else if(o)u=s.dateFormat(o,i);else if(d&&a&&l>=1e3)for(;d--&&void 0===u;)l>=(p=Math.pow(h,d+1))&&10*i%p==0&&null!==a[d]&&0!==i&&(u=e(i/p,-1)+a[d]);return void 0===u&&(u=Math.abs(i)>=1e4?e(i,-1):e(i,-1,void 0,"")),u}getSeriesExtremes(){let t;let e=this;k(this,"getSeriesExtremes",null,function(){e.hasVisibleSeries=!1,e.dataMin=e.dataMax=e.threshold=void 0,e.softThreshold=!e.isXAxis,e.series.forEach(i=>{if(i.reserveSpace()){let s=i.options,r,o=s.threshold,n,a;if(e.hasVisibleSeries=!0,e.positiveValuesOnly&&0>=(o||0)&&(o=void 0),e.isXAxis)(r=i.xData)&&r.length&&(r=e.logarithmic?r.filter(t=>t>0):r,n=(t=i.getXExtremes(r)).min,a=t.max,A(n)||n instanceof Date||(r=r.filter(A),n=(t=i.getXExtremes(r)).min,a=t.max),r.length&&(e.dataMin=Math.min(E(e.dataMin,n),n),e.dataMax=Math.max(E(e.dataMax,a),a)));else {let t=i.applyExtremes();A(t.dataMin)&&(n=t.dataMin,e.dataMin=Math.min(E(e.dataMin,n),n)),A(t.dataMax)&&(a=t.dataMax,e.dataMax=Math.max(E(e.dataMax,a),a)),y(o)&&(e.threshold=o),(!s.softThreshold||e.positiveValuesOnly)&&(e.softThreshold=!1);}}});}),k(this,"afterGetSeriesExtremes");}translate(t,e,i,s,r,o){let n=this.linkedParent||this,a=s&&n.old?n.old.min:n.min;if(!A(a))return NaN;let h=n.minPixelPadding,l=(n.isOrdinal||n.brokenAxis?.hasBreaks||n.logarithmic&&r)&&n.lin2val,d=1,c=0,p=s&&n.old?n.old.transA:n.transA,u=0;return p||(p=n.transA),i&&(d*=-1,c=n.len),n.reversed&&(d*=-1,c-=d*(n.sector||n.len)),e?(u=(t=t*d+c-h)/p+a,l&&(u=n.lin2val(u))):(l&&(t=n.val2lin(t)),u=d*(t-a)*p+c+d*h+(A(o)?p*o:0),n.isRadial||(u=x(u))),u}toPixels(t,e){return this.translate(t,!1,!this.horiz,void 0,!0)+(e?0:this.pos)}toValue(t,e){return this.translate(t-(e?0:this.pos),!0,!this.horiz,void 0,!0)}getPlotLinePath(t){let e=this,i=e.chart,s=e.left,r=e.top,o=t.old,n=t.value,a=t.lineWidth,h=o&&i.oldChartHeight||i.chartHeight,l=o&&i.oldChartWidth||i.chartWidth,d=e.transB,c=t.translatedValue,p=t.force,u,g,f,x,y;function b(t,e,i){return "pass"!==p&&(t<e||t>i)&&(p?t=m(t,e,i):y=!0),t}let v={value:n,lineWidth:a,old:o,force:p,acrossPanes:t.acrossPanes,translatedValue:c};return k(this,"getPlotLinePath",v,function(t){u=f=(c=m(c=E(c,e.translate(n,void 0,void 0,o)),-1e9,1e9))+d,g=x=h-c-d,A(c)?e.horiz?(g=r,x=h-e.bottom+(e.options.isInternal?0:i.scrollablePixelsY||0),u=f=b(u,s,s+e.width)):(u=s,f=l-e.right+(i.scrollablePixelsX||0),g=x=b(g,r,r+e.height)):(y=!0,p=!1),t.path=y&&!p?void 0:i.renderer.crispLine([["M",u,g],["L",f,x]],a||1);}),v.path}getLinearTickPositions(t,e,i){let s,r,o;let n=x(Math.floor(e/t)*t),a=x(Math.ceil(i/t)*t),h=[];if(x(n+t)===n&&(o=20),this.single)return [e];for(s=n;s<=a&&(h.push(s),(s=x(s+t,o))!==r);)r=s;return h}getMinorTickInterval(){let{minorTicks:t,minorTickInterval:e}=this.options;return !0===t?E(e,"auto"):!1!==t?e:void 0}getMinorTickPositions(){let t=this.options,e=this.tickPositions,i=this.minorTickInterval,s=this.pointRangePadding||0,r=(this.min||0)-s,o=(this.max||0)+s,n=o-r,a=[],h;if(n&&n/i<this.len/3){let s=this.logarithmic;if(s)this.paddedTicks.forEach(function(t,e,r){e&&a.push.apply(a,s.getLogTickPositions(i,r[e-1],r[e],!0));});else if(this.dateTime&&"auto"===this.getMinorTickInterval())a=a.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(i),r,o,t.startOfWeek));else for(h=r+(e[0]-r)%i;h<=o&&h!==a[0];h+=i)a.push(h);}return 0!==a.length&&this.trimTicks(a),a}adjustForMinRange(){let t=this.options,e=this.logarithmic,{max:i,min:s,minRange:r}=this,o,n,a,h;this.isXAxis&&void 0===r&&!e&&(r=y(t.min)||y(t.max)||y(t.floor)||y(t.ceiling)?null:Math.min(5*(M(this.series.map(t=>(t.xIncrement?t.xData?.slice(0,2):t.xData)||[]))||0),this.dataMax-this.dataMin)),A(i)&&A(s)&&A(r)&&i-s<r&&(n=this.dataMax-this.dataMin>=r,o=(r-i+s)/2,a=[s-o,E(t.min,s-o)],n&&(a[2]=e?e.log2lin(this.dataMin):this.dataMin),h=[(s=g(a))+r,E(t.max,s+r)],n&&(h[2]=e?e.log2lin(this.dataMax):this.dataMax),(i=f(h))-s<r&&(a[0]=i-r,a[1]=E(t.min,i-r),s=g(a))),this.minRange=r,this.min=s,this.max=i;}getClosest(){let t,e;if(this.categories)e=1;else {let i=[];this.series.forEach(function(t){let s=t.closestPointRange;t.xData?.length===1?i.push(t.xData[0]):!t.noSharedTooltip&&y(s)&&t.reserveSpace()&&(e=y(e)?Math.min(e,s):s);}),i.length&&(i.sort((t,e)=>t-e),t=M([i]));}return t&&e?Math.min(t,e):t||e}nameToX(t){let e=T(this.options.categories),i=e?this.categories:this.names,s=t.options.x,r;return t.series.requireSorting=!1,y(s)||(s=this.uniqueNames&&i?e?i.indexOf(t.name):E(i.keys[t.name],-1):t.series.autoIncrement()),-1===s?!e&&i&&(r=i.length):r=s,void 0!==r?(this.names[r]=t.name,this.names.keys[t.name]=r):t.x&&(r=t.x),r}updateNames(){let t=this,e=this.names;e.length>0&&(Object.keys(e.keys).forEach(function(t){delete e.keys[t];}),e.length=0,this.minRange=this.userMinRange,(this.series||[]).forEach(e=>{e.xIncrement=null,(!e.points||e.isDirtyData)&&(t.max=Math.max(t.max,e.xData.length-1),e.processData(),e.generatePoints()),e.data.forEach(function(i,s){let r;i?.options&&void 0!==i.name&&void 0!==(r=t.nameToX(i))&&r!==i.x&&(i.x=r,e.xData[s]=r);});}));}setAxisTranslation(){let t=this,e=t.max-t.min,i=t.linkedParent,s=!!t.categories,r=t.isXAxis,o=t.axisPointRange||0,n,a=0,h=0,l,d=t.transA;(r||s||o)&&(n=t.getClosest(),i?(a=i.minPointOffset,h=i.pointRangePadding):t.series.forEach(function(e){let i=s?1:r?E(e.options.pointRange,n,0):t.axisPointRange||0,l=e.options.pointPlacement;if(o=Math.max(o,i),!t.single||s){let t=e.is("xrange")?!r:r;a=Math.max(a,t&&P(l)?0:i/2),h=Math.max(h,t&&"on"===l?0:i);}}),l=t.ordinal&&t.ordinal.slope&&n?t.ordinal.slope/n:1,t.minPointOffset=a*=l,t.pointRangePadding=h*=l,t.pointRange=Math.min(o,t.single&&s?1:e),r&&n&&(t.closestPointRange=n)),t.translationSlope=t.transA=d=t.staticScale||t.len/(e+h||1),t.transB=t.horiz?t.left:t.bottom,t.minPixelPadding=d*a,k(this,"afterSetAxisTranslation");}minFromRange(){let{max:t,min:e}=this;return A(t)&&A(e)&&t-e||void 0}setTickInterval(t){let{categories:e,chart:i,dataMax:s,dataMin:r,dateTime:o,isXAxis:n,logarithmic:a,options:h,softThreshold:l}=this,d=A(this.threshold)?this.threshold:void 0,c=this.minRange||0,{ceiling:p,floor:u,linkedTo:g,softMax:f,softMin:m}=h,b=A(g)&&i[this.coll]?.[g],v=h.tickPixelInterval,C=h.maxPadding,M=h.minPadding,w=0,T,P=A(h.tickInterval)&&h.tickInterval>=0?h.tickInterval:void 0,L,O,D,I;if(o||e||b||this.getTickAmount(),D=E(this.userMin,h.min),I=E(this.userMax,h.max),b?(this.linkedParent=b,T=b.getExtremes(),this.min=E(T.min,T.dataMin),this.max=E(T.max,T.dataMax),this.type!==b.type&&S(11,!0,i)):(l&&y(d)&&A(s)&&A(r)&&(r>=d?(L=d,M=0):s<=d&&(O=d,C=0)),this.min=E(D,L,r),this.max=E(I,O,s)),A(this.max)&&A(this.min)&&(a&&(this.positiveValuesOnly&&!t&&0>=Math.min(this.min,E(r,this.min))&&S(10,!0,i),this.min=x(a.log2lin(this.min),16),this.max=x(a.log2lin(this.max),16)),this.range&&A(r)&&(this.userMin=this.min=D=Math.max(r,this.minFromRange()||0),this.userMax=I=this.max,this.range=void 0)),k(this,"foundExtremes"),this.adjustForMinRange(),A(this.min)&&A(this.max)){if(!A(this.userMin)&&A(m)&&m<this.min&&(this.min=D=m),!A(this.userMax)&&A(f)&&f>this.max&&(this.max=I=f),e||this.axisPointRange||this.stacking?.usePercentage||b||!(w=this.max-this.min)||(!y(D)&&M&&(this.min-=w*M),y(I)||!C||(this.max+=w*C)),!A(this.userMin)&&A(u)&&(this.min=Math.max(this.min,u)),!A(this.userMax)&&A(p)&&(this.max=Math.min(this.max,p)),l&&A(r)&&A(s)){let t=d||0;!y(D)&&this.min<t&&r>=t?this.min=h.minRange?Math.min(t,this.max-c):t:!y(I)&&this.max>t&&s<=t&&(this.max=h.minRange?Math.max(t,this.min+c):t);}!i.polar&&this.min>this.max&&(y(h.min)?this.max=this.min:y(h.max)&&(this.min=this.max)),w=this.max-this.min;}if(this.min!==this.max&&A(this.min)&&A(this.max)?b&&!P&&v===b.options.tickPixelInterval?this.tickInterval=P=b.tickInterval:this.tickInterval=E(P,this.tickAmount?w/Math.max(this.tickAmount-1,1):void 0,e?1:w*v/Math.max(this.len,v)):this.tickInterval=1,n&&!t){let t=this.min!==this.old?.min||this.max!==this.old?.max;this.series.forEach(function(e){e.forceCrop=e.forceCropping?.(),e.processData(t);}),k(this,"postProcessData",{hasExtremesChanged:t});}this.setAxisTranslation(),k(this,"initialAxisTranslation"),this.pointRange&&!P&&(this.tickInterval=Math.max(this.pointRange,this.tickInterval));let j=E(h.minTickInterval,o&&!this.series.some(t=>t.noSharedTooltip)?this.closestPointRange:0);!P&&this.tickInterval<j&&(this.tickInterval=j),o||a||P||(this.tickInterval=z(this,this.tickInterval)),this.tickAmount||(this.tickInterval=this.unsquish()),this.setTickPositions();}setTickPositions(){let t=this.options,e=t.tickPositions,i=t.tickPositioner,s=this.getMinorTickInterval(),r=!this.isPanning,o=r&&t.startOnTick,n=r&&t.endOnTick,a=[],h;if(this.tickmarkOffset=this.categories&&"between"===t.tickmarkPlacement&&1===this.tickInterval?.5:0,this.single=this.min===this.max&&y(this.min)&&!this.tickAmount&&(this.min%1==0||!1!==t.allowDecimals),e)a=e.slice();else if(A(this.min)&&A(this.max)){if(!this.ordinal?.positions&&(this.max-this.min)/this.tickInterval>Math.max(2*this.len,200))a=[this.min,this.max],S(19,!1,this.chart);else if(this.dateTime)a=this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval,t.units),this.min,this.max,t.startOfWeek,this.ordinal?.positions,this.closestPointRange,!0);else if(this.logarithmic)a=this.logarithmic.getLogTickPositions(this.tickInterval,this.min,this.max);else {let t=this.tickInterval,e=t;for(;e<=2*t;)if(a=this.getLinearTickPositions(this.tickInterval,this.min,this.max),this.tickAmount&&a.length>this.tickAmount)this.tickInterval=z(this,e*=1.1);else break}a.length>this.len&&(a=[a[0],a[a.length-1]])[0]===a[1]&&(a.length=1),i&&(this.tickPositions=a,(h=i.apply(this,[this.min,this.max]))&&(a=h));}this.tickPositions=a,this.minorTickInterval="auto"===s&&this.tickInterval?this.tickInterval/t.minorTicksPerMajor:s,this.paddedTicks=a.slice(0),this.trimTicks(a,o,n),!this.isLinked&&A(this.min)&&A(this.max)&&(this.single&&a.length<2&&!this.categories&&!this.series.some(t=>t.is("heatmap")&&"between"===t.options.pointPlacement)&&(this.min-=.5,this.max+=.5),e||h||this.adjustTickAmount()),k(this,"afterSetTickPositions");}trimTicks(t,e,i){let s=t[0],r=t[t.length-1],o=!this.isOrdinal&&this.minPointOffset||0;if(k(this,"trimTicks"),!this.isLinked){if(e&&s!==-1/0)this.min=s;else for(;this.min-o>t[0];)t.shift();if(i)this.max=r;else for(;this.max+o<t[t.length-1];)t.pop();0===t.length&&y(s)&&!this.options.tickPositions&&t.push((r+s)/2);}}alignToOthers(){let t;let e=this,i=e.chart,s=[this],r=e.options,o=i.options.chart,n="yAxis"===this.coll&&o.alignThresholds,a=[];if(e.thresholdAlignment=void 0,(!1!==o.alignTicks&&r.alignTicks||n)&&!1!==r.startOnTick&&!1!==r.endOnTick&&!e.logarithmic){let r=t=>{let{horiz:e,options:i}=t;return [e?i.left:i.top,i.width,i.height,i.pane].join(",")},o=r(this);i[this.coll].forEach(function(i){let{series:n}=i;n.length&&n.some(t=>t.visible)&&i!==e&&r(i)===o&&(t=!0,s.push(i));});}if(t&&n){s.forEach(t=>{let i=t.getThresholdAlignment(e);A(i)&&a.push(i);});let t=a.length>1?a.reduce((t,e)=>t+=e,0)/a.length:void 0;s.forEach(e=>{e.thresholdAlignment=t;});}return t}getThresholdAlignment(t){if((!A(this.dataMin)||this!==t&&this.series.some(t=>t.isDirty||t.isDirtyData))&&this.getSeriesExtremes(),A(this.threshold)){let t=m((this.threshold-(this.dataMin||0))/((this.dataMax||0)-(this.dataMin||0)),0,1);return this.options.reversed&&(t=1-t),t}}getTickAmount(){let t=this.options,e=t.tickPixelInterval,i=t.tickAmount;y(t.tickInterval)||i||!(this.len<e)||this.isRadial||this.logarithmic||!t.startOnTick||!t.endOnTick||(i=2),!i&&this.alignToOthers()&&(i=Math.ceil(this.len/e)+1),i<4&&(this.finalTickAmt=i,i=5),this.tickAmount=i;}adjustTickAmount(){let t=this,{finalTickAmt:e,max:i,min:s,options:r,tickPositions:o,tickAmount:n,thresholdAlignment:a}=t,h=o?.length,l=E(t.threshold,t.softThreshold?0:null),d,c,p=t.tickInterval,u,g=()=>o.push(x(o[o.length-1]+p)),f=()=>o.unshift(x(o[0]-p));if(A(a)&&(u=a<.5?Math.ceil(a*(n-1)):Math.floor(a*(n-1)),r.reversed&&(u=n-1-u)),t.hasData()&&A(s)&&A(i)){let a=()=>{t.transA*=(h-1)/(n-1),t.min=r.startOnTick?o[0]:Math.min(s,o[0]),t.max=r.endOnTick?o[o.length-1]:Math.max(i,o[o.length-1]);};if(A(u)&&A(t.threshold)){for(;o[u]!==l||o.length!==n||o[0]>s||o[o.length-1]<i;){for(o.length=0,o.push(t.threshold);o.length<n;)void 0===o[u]||o[u]>t.threshold?f():g();if(p>8*t.tickInterval)break;p*=2;}a();}else if(h<n){for(;o.length<n;)o.length%2||s===l?g():f();a();}if(y(e)){for(c=d=o.length;c--;)(3===e&&c%2==1||e<=2&&c>0&&c<d-1)&&o.splice(c,1);t.finalTickAmt=void 0;}}}setScale(){let{coll:t,stacking:e}=this,i=!1,s=!1;this.series.forEach(t=>{i=i||t.isDirtyData||t.isDirty,s=s||t.xAxis&&t.xAxis.isDirty||!1;}),this.setAxisSize();let r=this.len!==(this.old&&this.old.len);r||i||s||this.isLinked||this.forceRedraw||this.userMin!==(this.old&&this.old.userMin)||this.userMax!==(this.old&&this.old.userMax)||this.alignToOthers()?(e&&"yAxis"===t&&e.buildStacks(),this.forceRedraw=!1,this.userMinRange||(this.minRange=void 0),this.getSeriesExtremes(),this.setTickInterval(),e&&"xAxis"===t&&e.buildStacks(),this.isDirty||(this.isDirty=r||this.min!==this.old?.min||this.max!==this.old?.max)):e&&e.cleanStacks(),i&&delete this.allExtremes,k(this,"afterSetScale");}setExtremes(t,e,i=!0,s,r){this.series.forEach(t=>{delete t.kdTree;}),k(this,"setExtremes",r=C(r,{min:t,max:e}),t=>{this.userMin=t.min,this.userMax=t.max,this.eventArgs=t,i&&this.chart.redraw(s);});}setAxisSize(){let t=this.chart,e=this.options,i=e.offsets||[0,0,0,0],s=this.horiz,r=this.width=Math.round(I(E(e.width,t.plotWidth-i[3]+i[1]),t.plotWidth)),o=this.height=Math.round(I(E(e.height,t.plotHeight-i[0]+i[2]),t.plotHeight)),n=this.top=Math.round(I(E(e.top,t.plotTop+i[0]),t.plotHeight,t.plotTop)),a=this.left=Math.round(I(E(e.left,t.plotLeft+i[3]),t.plotWidth,t.plotLeft));this.bottom=t.chartHeight-o-n,this.right=t.chartWidth-r-a,this.len=Math.max(s?r:o,0),this.pos=s?a:n;}getExtremes(){let t=this.logarithmic;return {min:t?x(t.lin2log(this.min)):this.min,max:t?x(t.lin2log(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}}getThreshold(t){let e=this.logarithmic,i=e?e.lin2log(this.min):this.min,s=e?e.lin2log(this.max):this.max;return null===t||t===-1/0?t=i:t===1/0?t=s:i>t?t=i:s<t&&(t=s),this.translate(t,0,1,0,1)}autoLabelAlign(t){let e=(E(t,0)-90*this.side+720)%360,i={align:"center"};return k(this,"autoLabelAlign",i,function(t){e>15&&e<165?t.align="right":e>195&&e<345&&(t.align="left");}),i.align}tickSize(t){let e=this.options,i=E(e["tick"===t?"tickWidth":"minorTickWidth"],"tick"===t&&this.isXAxis&&!this.categories?1:0),s=e["tick"===t?"tickLength":"minorTickLength"],r;i&&s&&("inside"===e[t+"Position"]&&(s=-s),r=[s,i]);let o={tickSize:r};return k(this,"afterTickSize",o),o.tickSize}labelMetrics(){let t=this.chart.renderer,e=this.ticks,i=e[Object.keys(e)[0]]||{};return this.chart.renderer.fontMetrics(i.label||i.movedLabel||t.box)}unsquish(){let t=this.options.labels,e=t.padding||0,i=this.horiz,s=this.tickInterval,r=this.len/(((this.categories?1:0)+this.max-this.min)/s),o=t.rotation,n=x(.8*this.labelMetrics().h),a=Math.max(this.max-this.min,0),h=function(t){let i=(t+2*e)/(r||1);return (i=i>1?Math.ceil(i):1)*s>a&&t!==1/0&&r!==1/0&&a&&(i=Math.ceil(a/s)),x(i*s)},l=s,d,c=Number.MAX_VALUE,p;if(i){if(!t.staggerLines&&(A(o)?p=[o]:r<t.autoRotationLimit&&(p=t.autoRotation)),p){let t,e;for(let i of p)(i===o||i&&i>=-90&&i<=90)&&(e=(t=h(Math.abs(n/Math.sin(u*i))))+Math.abs(i/360))<c&&(c=e,d=i,l=t);}}else l=h(.75*n);return this.autoRotation=p,this.labelRotation=E(d,A(o)?o:0),t.step?s:l}getSlotWidth(t){let e=this.chart,i=this.horiz,s=this.options.labels,r=Math.max(this.tickPositions.length-(this.categories?0:1),1),o=e.margin[3];if(t&&A(t.slotWidth))return t.slotWidth;if(i&&s.step<2)return s.rotation?0:(this.staggerLines||1)*this.len/r;if(!i){let t=s.style.width;if(void 0!==t)return parseInt(String(t),10);if(o)return o-e.spacing[3]}return .33*e.chartWidth}renderUnsquish(){let t=this.chart,e=t.renderer,i=this.tickPositions,s=this.ticks,r=this.options.labels,o=r.style,n=this.horiz,a=this.getSlotWidth(),h=Math.max(1,Math.round(a-(n?2*(r.padding||0):r.distance||0))),l={},d=this.labelMetrics(),c=o.textOverflow,p,u,g=0,f,m;if(P(r.rotation)||(l.rotation=r.rotation||0),i.forEach(function(t){let e=s[t];e.movedLabel&&e.replaceMovedLabel(),e&&e.label&&e.label.textPxLength>g&&(g=e.label.textPxLength);}),this.maxLabelLength=g,this.autoRotation)g>h&&g>d.h?l.rotation=this.labelRotation:this.labelRotation=0;else if(a&&(p=h,!c))for(u="clip",m=i.length;!n&&m--;)(f=s[i[m]].label)&&("ellipsis"===f.styles.textOverflow?f.css({textOverflow:"clip"}):f.textPxLength>a&&f.css({width:a+"px"}),f.getBBox().height>this.len/i.length-(d.h-d.f)&&(f.specificTextOverflow="ellipsis"));l.rotation&&(p=g>.5*t.chartHeight?.33*t.chartHeight:g,c||(u="ellipsis")),this.labelAlign=r.align||this.autoLabelAlign(this.labelRotation),this.labelAlign&&(l.align=this.labelAlign),i.forEach(function(t){let e=s[t],i=e&&e.label,r=o.width,n={};i&&(i.attr(l),e.shortenLabel?e.shortenLabel():p&&!r&&"nowrap"!==o.whiteSpace&&(p<i.textPxLength||"SPAN"===i.element.tagName)?(n.width=p+"px",c||(n.textOverflow=i.specificTextOverflow||u),i.css(n)):!i.styles.width||n.width||r||i.css({width:null}),delete i.specificTextOverflow,e.rotation=l.rotation);},this),this.tickRotCorr=e.rotCorr(d.b,this.labelRotation||0,0!==this.side);}hasData(){return this.series.some(function(t){return t.hasData()})||this.options.showEmpty&&y(this.min)&&y(this.max)}addTitle(t){let e;let i=this.chart.renderer,s=this.horiz,r=this.opposite,o=this.options.title,n=this.chart.styledMode;this.axisTitle||((e=o.textAlign)||(e=(s?{low:"left",middle:"center",high:"right"}:{low:r?"right":"left",middle:"center",high:r?"left":"right"})[o.align]),this.axisTitle=i.text(o.text||"",0,0,o.useHTML).attr({zIndex:7,rotation:o.rotation||0,align:e}).addClass("highcharts-axis-title"),n||this.axisTitle.css(L(o.style)),this.axisTitle.add(this.axisGroup),this.axisTitle.isNew=!0),n||o.style.width||this.isRadial||this.axisTitle.css({width:this.len+"px"}),this.axisTitle[t?"show":"hide"](t);}generateTick(t){let e=this.ticks;e[t]?e[t].addLabel():e[t]=new n(this,t);}createGroups(){let{axisParent:t,chart:e,coll:i,options:s}=this,r=e.renderer,o=(e,o,n)=>r.g(e).attr({zIndex:n}).addClass(`highcharts-${i.toLowerCase()}${o} `+(this.isRadial?`highcharts-radial-axis${o} `:"")+(s.className||"")).add(t);this.axisGroup||(this.gridGroup=o("grid","-grid",s.gridZIndex),this.axisGroup=o("axis","",s.zIndex),this.labelGroup=o("axis-labels","-labels",s.labels.zIndex));}getOffset(){let t=this,{chart:e,horiz:i,options:s,side:r,ticks:o,tickPositions:n,coll:a}=t,h=e.inverted&&!t.isZAxis?[1,0,3,2][r]:r,l=t.hasData(),d=s.title,c=s.labels,p=A(s.crossing),u=e.axisOffset,g=e.clipOffset,f=[-1,1,1,-1][r],m,x=0,b,v=0,S=0,C,M;if(t.showAxis=m=l||s.showEmpty,t.staggerLines=t.horiz&&c.staggerLines||void 0,t.createGroups(),l||t.isLinked?(n.forEach(function(e){t.generateTick(e);}),t.renderUnsquish(),t.reserveSpaceDefault=0===r||2===r||({1:"left",3:"right"})[r]===t.labelAlign,E(c.reserveSpace,!p&&null,"center"===t.labelAlign||null,t.reserveSpaceDefault)&&n.forEach(function(t){S=Math.max(o[t].getLabelSize(),S);}),t.staggerLines&&(S*=t.staggerLines),t.labelOffset=S*(t.opposite?-1:1)):D(o,function(t,e){t.destroy(),delete o[e];}),d?.text&&!1!==d.enabled&&(t.addTitle(m),m&&!p&&!1!==d.reserveSpace&&(t.titleOffset=x=t.axisTitle.getBBox()[i?"height":"width"],v=y(b=d.offset)?0:E(d.margin,i?5:10))),t.renderLine(),t.offset=f*E(s.offset,u[r]?u[r]+(s.margin||0):0),t.tickRotCorr=t.tickRotCorr||{x:0,y:0},M=0===r?-t.labelMetrics().h:2===r?t.tickRotCorr.y:0,C=Math.abs(S)+v,S&&(C-=M,C+=f*(i?E(c.y,t.tickRotCorr.y+f*c.distance):E(c.x,f*c.distance))),t.axisTitleMargin=E(b,C),t.getMaxLabelDimensions&&(t.maxLabelDimensions=t.getMaxLabelDimensions(o,n)),"colorAxis"!==a&&g){let e=this.tickSize("tick");u[r]=Math.max(u[r],(t.axisTitleMargin||0)+x+f*t.offset,C,n&&n.length&&e?e[0]+f*t.offset:0);let i=!t.axisLine||s.offset?0:t.axisLine.strokeWidth()/2;g[h]=Math.max(g[h],i);}k(this,"afterGetOffset");}getLinePath(t){let e=this.chart,i=this.opposite,s=this.offset,r=this.horiz,o=this.left+(i?this.width:0)+s,n=e.chartHeight-this.bottom-(i?this.height:0)+s;return i&&(t*=-1),e.renderer.crispLine([["M",r?this.left:o,r?n:this.top],["L",r?e.chartWidth-this.right:o,r?n:e.chartHeight-this.bottom]],t)}renderLine(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),this.chart.styledMode||this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7}));}getTitlePosition(t){let e=this.horiz,i=this.left,s=this.top,r=this.len,o=this.options.title,n=e?i:s,a=this.opposite,h=this.offset,l=o.x,d=o.y,c=this.chart.renderer.fontMetrics(t),p=t?Math.max(t.getBBox(!1,0).height-c.h-1,0):0,u={low:n+(e?0:r),middle:n+r/2,high:n+(e?r:0)}[o.align],g=(e?s+this.height:i)+(e?1:-1)*(a?-1:1)*(this.axisTitleMargin||0)+[-p,p,c.f,-p][this.side],f={x:e?u+l:g+(a?this.width:0)+h+l,y:e?g+d-(a?this.height:0)+h:u+d};return k(this,"afterGetTitlePosition",{titlePosition:f}),f}renderMinorTick(t,e){let i=this.minorTicks;i[t]||(i[t]=new n(this,t,"minor")),e&&i[t].isNew&&i[t].render(null,!0),i[t].render(null,!1,1);}renderTick(t,e,i){let s=this.isLinked,r=this.ticks;(!s||t>=this.min&&t<=this.max||this.grid&&this.grid.isColumn)&&(r[t]||(r[t]=new n(this,t)),i&&r[t].isNew&&r[t].render(e,!0,-1),r[t].render(e));}render(){let t,e;let i=this,s=i.chart,r=i.logarithmic,a=s.renderer,l=i.options,d=i.isLinked,c=i.tickPositions,p=i.axisTitle,u=i.ticks,g=i.minorTicks,f=i.alternateBands,m=l.stackLabels,x=l.alternateGridColor,y=l.crossing,b=i.tickmarkOffset,v=i.axisLine,S=i.showAxis,C=h(a.globalAnimation);if(i.labelEdge.length=0,i.overlap=!1,[u,g,f].forEach(function(t){D(t,function(t){t.isActive=!1;});}),A(y)){let t=this.isXAxis?s.yAxis[0]:s.xAxis[0],e=[1,-1,-1,1][this.side];if(t){let s=t.toPixels(y,!0);i.horiz&&(s=t.len-s),i.offset=e*s;}}if(i.hasData()||d){let a=i.chart.hasRendered&&i.old&&A(i.old.min);i.minorTickInterval&&!i.categories&&i.getMinorTickPositions().forEach(function(t){i.renderMinorTick(t,a);}),c.length&&(c.forEach(function(t,e){i.renderTick(t,e,a);}),b&&(0===i.min||i.single)&&(u[-1]||(u[-1]=new n(i,-1,null,!0)),u[-1].render(-1))),x&&c.forEach(function(n,a){e=void 0!==c[a+1]?c[a+1]+b:i.max-b,a%2==0&&n<i.max&&e<=i.max+(s.polar?-b:b)&&(f[n]||(f[n]=new o.PlotLineOrBand(i,{})),t=n+b,f[n].options={from:r?r.lin2log(t):t,to:r?r.lin2log(e):e,color:x,className:"highcharts-alternate-grid"},f[n].render(),f[n].isActive=!0);}),i._addedPlotLB||(i._addedPlotLB=!0,(l.plotLines||[]).concat(l.plotBands||[]).forEach(function(t){i.addPlotBandOrLine(t);}));}[u,g,f].forEach(function(t){let e=[],i=C.duration;D(t,function(t,i){t.isActive||(t.render(i,!1,0),t.isActive=!1,e.push(i));}),R(function(){let i=e.length;for(;i--;)t[e[i]]&&!t[e[i]].isActive&&(t[e[i]].destroy(),delete t[e[i]]);},t!==f&&s.hasRendered&&i?i:0);}),v&&(v[v.isPlaced?"animate":"attr"]({d:this.getLinePath(v.strokeWidth())}),v.isPlaced=!0,v[S?"show":"hide"](S)),p&&S&&(p[p.isNew?"attr":"animate"](i.getTitlePosition(p)),p.isNew=!1),m&&m.enabled&&i.stacking&&i.stacking.renderStackTotals(),i.old={len:i.len,max:i.max,min:i.min,transA:i.transA,userMax:i.userMax,userMin:i.userMin},i.isDirty=!1,k(this,"afterRender");}redraw(){this.visible&&(this.render(),this.plotLinesAndBands.forEach(function(t){t.render();})),this.series.forEach(function(t){t.isDirty=!0;});}getKeepProps(){return this.keepProps||N.keepProps}destroy(t){let e=this,i=e.plotLinesAndBands,s=this.eventOptions;if(k(this,"destroy",{keepEvents:t}),t||j(e),[e.ticks,e.minorTicks,e.alternateBands].forEach(function(t){b(t);}),i){let t=i.length;for(;t--;)i[t].destroy();}for(let t in ["axisLine","axisTitle","axisGroup","gridGroup","labelGroup","cross","scrollbar"].forEach(function(t){e[t]&&(e[t]=e[t].destroy());}),e.plotLinesAndBandsGroups)e.plotLinesAndBandsGroups[t]=e.plotLinesAndBandsGroups[t].destroy();D(e,function(t,i){-1===e.getKeepProps().indexOf(i)&&delete e[i];}),this.eventOptions=s;}drawCrosshair(t,e){let s=this.crosshair,r=E(s&&s.snap,!0),o=this.chart,n,a,h,l=this.cross,d;if(k(this,"drawCrosshair",{e:t,point:e}),t||(t=this.cross&&this.cross.e),s&&!1!==(y(e)||!r)){if(r?y(e)&&(a=E("colorAxis"!==this.coll?e.crosshairPos:null,this.isXAxis?e.plotX:this.len-e.plotY)):a=t&&(this.horiz?t.chartX-this.pos:this.len-t.chartY+this.pos),y(a)&&(d={value:e&&(this.isXAxis?e.x:E(e.stackY,e.y)),translatedValue:a},o.polar&&C(d,{isCrosshair:!0,chartX:t&&t.chartX,chartY:t&&t.chartY,point:e}),n=this.getPlotLinePath(d)||null),!y(n)){this.hideCrosshair();return}h=this.categories&&!this.isRadial,l||(this.cross=l=o.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(h?"category ":"thin ")+(s.className||"")).attr({zIndex:E(s.zIndex,2)}).add(),!o.styledMode&&(l.attr({stroke:s.color||(h?i.parse("#ccd3ff").setOpacity(.25).get():"#cccccc"),"stroke-width":E(s.width,1)}).css({"pointer-events":"none"}),s.dashStyle&&l.attr({dashstyle:s.dashStyle}))),l.show().attr({d:n}),h&&!s.width&&l.attr({"stroke-width":this.transA}),this.cross.e=t;}else this.hideCrosshair();k(this,"afterDrawCrosshair",{e:t,point:e});}hideCrosshair(){this.cross&&this.cross.hide(),k(this,"afterHideCrosshair");}update(t,e){let i=this.chart;t=L(this.userOptions,t),this.destroy(!0),this.init(i,t),i.isDirtyBox=!0,E(e,!0)&&i.redraw();}remove(t){let e=this.chart,i=this.coll,s=this.series,r=s.length;for(;r--;)s[r]&&s[r].remove(!1);v(e.axes,this),v(e[i]||[],this),e.orderItems(i),this.destroy(),e.isDirtyBox=!0,E(t,!0)&&e.redraw();}setTitle(t,e){this.update({title:t},e);}setCategories(t,e){this.update({categories:t},e);}}return N.keepProps=["coll","extKey","hcEvents","len","names","series","userMax","userMin"],N}),i(e,"Core/Axis/DateTimeAxis.js",[e["Core/Utilities.js"]],function(t){var e;let{addEvent:i,getMagnitude:s,normalizeTickInterval:r,timeUnits:o}=t;return function(t){function e(){return this.chart.time.getTimeTicks.apply(this.chart.time,arguments)}function n(){if("datetime"!==this.type){this.dateTime=void 0;return}this.dateTime||(this.dateTime=new a(this));}t.compose=function(t){return t.keepProps.includes("dateTime")||(t.keepProps.push("dateTime"),t.prototype.getTimeTicks=e,i(t,"afterSetType",n)),t};class a{constructor(t){this.axis=t;}normalizeTimeTickInterval(t,e){let i=e||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]],n=i[i.length-1],a=o[n[0]],h=n[1],l;for(l=0;l<i.length&&(a=o[(n=i[l])[0]],h=n[1],!i[l+1]||!(t<=(a*h[h.length-1]+o[i[l+1][0]])/2));l++);a===o.year&&t<5*a&&(h=[1,2,5]);let d=r(t/a,h,"year"===n[0]?Math.max(s(t/a),1):1);return {unitRange:a,count:d,unitName:n[0]}}getXDateFormat(t,e){let{axis:i}=this,s=i.chart.time;return i.closestPointRange?s.getDateFormat(i.closestPointRange,t,i.options.startOfWeek,e)||s.resolveDTLFormat(e.year).main:s.resolveDTLFormat(e.day).main}}t.Additions=a;}(e||(e={})),e}),i(e,"Core/Axis/LogarithmicAxis.js",[e["Core/Utilities.js"]],function(t){var e;let{addEvent:i,normalizeTickInterval:s,pick:r}=t;return function(t){function e(){"logarithmic"!==this.type?this.logarithmic=void 0:this.logarithmic??(this.logarithmic=new n(this));}function o(){let t=this.logarithmic;t&&(this.lin2val=function(e){return t.lin2log(e)},this.val2lin=function(e){return t.log2lin(e)});}t.compose=function(t){return t.keepProps.includes("logarithmic")||(t.keepProps.push("logarithmic"),i(t,"afterSetType",e),i(t,"afterInit",o)),t};class n{constructor(t){this.axis=t;}getLogTickPositions(t,e,i,o){let n=this.axis,a=n.len,h=n.options,l=[];if(o||(this.minorAutoInterval=void 0),t>=.5)t=Math.round(t),l=n.getLinearTickPositions(t,e,i);else if(t>=.08){let s,r,n,a,h,d,c;let p=Math.floor(e);for(s=t>.3?[1,2,4]:t>.15?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9],r=p;r<i+1&&!c;r++)for(n=0,a=s.length;n<a&&!c;n++)(h=this.log2lin(this.lin2log(r)*s[n]))>e&&(!o||d<=i)&&void 0!==d&&l.push(d),d>i&&(c=!0),d=h;}else {let d=this.lin2log(e),c=this.lin2log(i),p=o?n.getMinorTickInterval():h.tickInterval,u=h.tickPixelInterval/(o?5:1),g=o?a/n.tickPositions.length:a;t=s(t=r("auto"===p?null:p,this.minorAutoInterval,(c-d)*u/(g||1))),l=n.getLinearTickPositions(t,d,c).map(this.log2lin),o||(this.minorAutoInterval=t/5);}return o||(n.tickInterval=t),l}lin2log(t){return Math.pow(10,t)}log2lin(t){return Math.log(t)/Math.LN10}}t.Additions=n;}(e||(e={})),e}),i(e,"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js",[e["Core/Utilities.js"]],function(t){var e;let{erase:i,extend:s,isNumber:r}=t;return function(t){let e;function o(t){return this.addPlotBandOrLine(t,"plotBands")}function n(t,i){let s=this.userOptions,r=new e(this,t);if(this.visible&&(r=r.render()),r){if(this._addedPlotLB||(this._addedPlotLB=!0,(s.plotLines||[]).concat(s.plotBands||[]).forEach(t=>{this.addPlotBandOrLine(t);})),i){let e=s[i]||[];e.push(t),s[i]=e;}this.plotLinesAndBands.push(r);}return r}function a(t){return this.addPlotBandOrLine(t,"plotLines")}function h(t,e,i){i=i||this.options;let s=this.getPlotLinePath({value:e,force:!0,acrossPanes:i.acrossPanes}),o=[],n=this.horiz,a=!r(this.min)||!r(this.max)||t<this.min&&e<this.min||t>this.max&&e>this.max,h=this.getPlotLinePath({value:t,force:!0,acrossPanes:i.acrossPanes}),l,d=1,c;if(h&&s)for(a&&(c=h.toString()===s.toString(),d=0),l=0;l<h.length;l+=2){let t=h[l],e=h[l+1],i=s[l],r=s[l+1];("M"===t[0]||"L"===t[0])&&("M"===e[0]||"L"===e[0])&&("M"===i[0]||"L"===i[0])&&("M"===r[0]||"L"===r[0])&&(n&&i[1]===t[1]?(i[1]+=d,r[1]+=d):n||i[2]!==t[2]||(i[2]+=d,r[2]+=d),o.push(["M",t[1],t[2]],["L",e[1],e[2]],["L",r[1],r[2]],["L",i[1],i[2]],["Z"])),o.isFlat=c;}return o}function l(t){this.removePlotBandOrLine(t);}function d(t){let e=this.plotLinesAndBands,s=this.options,r=this.userOptions;if(e){let o=e.length;for(;o--;)e[o].id===t&&e[o].destroy();[s.plotLines||[],r.plotLines||[],s.plotBands||[],r.plotBands||[]].forEach(function(e){for(o=e.length;o--;)(e[o]||{}).id===t&&i(e,e[o]);});}}function c(t){this.removePlotBandOrLine(t);}t.compose=function(t,i){let r=i.prototype;return r.addPlotBand||(e=t,s(r,{addPlotBand:o,addPlotLine:a,addPlotBandOrLine:n,getPlotBandPath:h,removePlotBand:l,removePlotLine:c,removePlotBandOrLine:d})),i};}(e||(e={})),e}),i(e,"Core/Axis/PlotLineOrBand/PlotLineOrBand.js",[e["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"],e["Core/Utilities.js"]],function(t,e){let{addEvent:i,arrayMax:s,arrayMin:r,defined:o,destroyObjectProperties:n,erase:a,fireEvent:h,merge:l,objectEach:d,pick:c}=e;class p{static compose(e,s){return i(e,"afterInit",function(){this.labelCollectors.push(()=>{let t=[];for(let e of this.axes)for(let{label:i,options:s}of e.plotLinesAndBands)i&&!s?.label?.allowOverlap&&t.push(i);return t});}),t.compose(p,s)}constructor(t,e){this.axis=t,this.options=e,this.id=e.id;}render(){h(this,"render");let{axis:t,options:e}=this,{horiz:i,logarithmic:s}=t,{color:r,events:n,zIndex:a=0}=e,p={},u=t.chart.renderer,g=e.to,f=e.from,m=e.value,x=e.borderWidth,y=e.label,{label:b,svgElem:v}=this,S=[],C,k=o(f)&&o(g),M=o(m),w=!v,T={class:"highcharts-plot-"+(k?"band ":"line ")+(e.className||"")},A=k?"bands":"lines";if(!t.chart.styledMode&&(M?(T.stroke=r||"#999999",T["stroke-width"]=c(e.width,1),e.dashStyle&&(T.dashstyle=e.dashStyle)):k&&(T.fill=r||"#e6e9ff",x&&(T.stroke=e.borderColor,T["stroke-width"]=x))),p.zIndex=a,A+="-"+a,(C=t.plotLinesAndBandsGroups[A])||(t.plotLinesAndBandsGroups[A]=C=u.g("plot-"+A).attr(p).add()),v||(this.svgElem=v=u.path().attr(T).add(C)),o(m))S=t.getPlotLinePath({value:s?.log2lin(m)??m,lineWidth:v.strokeWidth(),acrossPanes:e.acrossPanes});else {if(!(o(f)&&o(g)))return;S=t.getPlotBandPath(s?.log2lin(f)??f,s?.log2lin(g)??g,e);}return !this.eventsAdded&&n&&(d(n,(t,e)=>{v?.on(e,t=>{n[e].apply(this,[t]);});}),this.eventsAdded=!0),(w||!v.d)&&S?.length?v.attr({d:S}):v&&(S?(v.show(),v.animate({d:S})):v.d&&(v.hide(),b&&(this.label=b=b.destroy()))),y&&(o(y.text)||o(y.formatter))&&S?.length&&t.width>0&&t.height>0&&!S.isFlat?(y=l({align:i&&k?"center":void 0,x:i?!k&&4:10,verticalAlign:!i&&k?"middle":void 0,y:i?k?16:10:k?6:-4,rotation:i&&!k?90:0,...k?{inside:!0}:{}},y),this.renderLabel(y,S,k,a)):b&&b.hide(),this}renderLabel(t,e,i,n){let a=this.axis,h=a.chart.renderer,d=t.inside,c=this.label;c||(this.label=c=h.text(this.getLabelText(t),0,0,t.useHTML).attr({align:t.textAlign||t.align,rotation:t.rotation,class:"highcharts-plot-"+(i?"band":"line")+"-label "+(t.className||""),zIndex:n}),a.chart.styledMode||c.css(l({fontSize:"0.8em",textOverflow:i&&!d?"":"ellipsis"},t.style)),c.add());let p=e.xBounds||[e[0][1],e[1][1],i?e[2][1]:e[0][1]],u=e.yBounds||[e[0][2],e[1][2],i?e[2][2]:e[0][2]],g=r(p),f=r(u),m=s(p)-g;c.align(t,!1,{x:g,y:f,width:m,height:s(u)-f}),(!c.alignValue||"left"===c.alignValue||o(d))&&c.css({width:(t.style?.width||(i&&d?m:90===c.rotation?a.height-(c.alignAttr.y-a.top):(t.clip?a.width:a.chart.chartWidth)-(c.alignAttr.x-a.left)))+"px"}),c.show(!0);}getLabelText(t){return o(t.formatter)?t.formatter.call(this):t.text}destroy(){a(this.axis.plotLinesAndBands,this),delete this.axis,n(this);}}return p}),i(e,"Core/Tooltip.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Templating.js"],e["Core/Globals.js"],e["Core/Renderer/RendererUtilities.js"],e["Core/Renderer/RendererRegistry.js"],e["Core/Utilities.js"]],function(t,e,i,s,r,o){var n;let{animObject:a}=t,{format:h}=e,{composed:l,doc:d,isSafari:c}=i,{distribute:p}=s,{addEvent:u,clamp:g,css:f,discardElement:m,extend:x,fireEvent:y,isArray:b,isNumber:v,isString:S,merge:C,pick:k,pushUnique:M,splat:w,syncTimeout:T}=o;class A{constructor(t,e,i){this.allowShared=!0,this.crosshairs=[],this.distance=0,this.isHidden=!0,this.isSticky=!1,this.options={},this.outside=!1,this.chart=t,this.init(t,e),this.pointer=i;}bodyFormatter(t){return t.map(function(t){let e=t.series.tooltipOptions;return (e[(t.point.formatPrefix||"point")+"Formatter"]||t.point.tooltipFormatter).call(t.point,e[(t.point.formatPrefix||"point")+"Format"]||"")})}cleanSplit(t){this.chart.series.forEach(function(e){let i=e&&e.tt;i&&(!i.isActive||t?e.tt=i.destroy():i.isActive=!1);});}defaultFormatter(t){let e;let i=this.points||w(this);return (e=(e=[t.tooltipFooterHeaderFormatter(i[0])]).concat(t.bodyFormatter(i))).push(t.tooltipFooterHeaderFormatter(i[0],!0)),e}destroy(){this.label&&(this.label=this.label.destroy()),this.split&&(this.cleanSplit(!0),this.tt&&(this.tt=this.tt.destroy())),this.renderer&&(this.renderer=this.renderer.destroy(),m(this.container)),o.clearTimeout(this.hideTimer);}getAnchor(t,e){let i;let{chart:s,pointer:r}=this,o=s.inverted,n=s.plotTop,a=s.plotLeft;if((t=w(t))[0].series&&t[0].series.yAxis&&!t[0].series.yAxis.options.reversedStacks&&(t=t.slice().reverse()),this.followPointer&&e)void 0===e.chartX&&(e=r.normalize(e)),i=[e.chartX-a,e.chartY-n];else if(t[0].tooltipPos)i=t[0].tooltipPos;else {let s=0,r=0;t.forEach(function(t){let e=t.pos(!0);e&&(s+=e[0],r+=e[1]);}),s/=t.length,r/=t.length,this.shared&&t.length>1&&e&&(o?s=e.chartX:r=e.chartY),i=[s-a,r-n];}return i.map(Math.round)}getClassName(t,e,i){let s=this.options,r=t.series,o=r.options;return [s.className,"highcharts-label",i&&"highcharts-tooltip-header",e?"highcharts-tooltip-box":"highcharts-tooltip",!i&&"highcharts-color-"+k(t.colorIndex,r.colorIndex),o&&o.className].filter(S).join(" ")}getLabel({anchorX:t,anchorY:e}={anchorX:0,anchorY:0}){let s=this,o=this.chart.styledMode,n=this.options,a=this.split&&this.allowShared,h=this.container,l=this.chart.renderer;if(this.label){let t=!this.label.hasClass("highcharts-label");(!a&&t||a&&!t)&&this.destroy();}if(!this.label){if(this.outside){let t=this.chart.options.chart.style,e=r.getRendererType();this.container=h=i.doc.createElement("div"),h.className="highcharts-tooltip-container",f(h,{position:"absolute",top:"1px",pointerEvents:"none",zIndex:Math.max(this.options.style.zIndex||0,(t&&t.zIndex||0)+3)}),this.renderer=l=new e(h,0,0,t,void 0,void 0,l.styledMode);}if(a?this.label=l.g("tooltip"):(this.label=l.label("",t,e,n.shape,void 0,void 0,n.useHTML,void 0,"tooltip").attr({padding:n.padding,r:n.borderRadius}),o||this.label.attr({fill:n.backgroundColor,"stroke-width":n.borderWidth||0}).css(n.style).css({pointerEvents:n.style.pointerEvents||(this.shouldStickOnContact()?"auto":"none")})),s.outside){let t=this.label;[t.xSetter,t.ySetter].forEach((e,i)=>{t[i?"ySetter":"xSetter"]=r=>{e.call(t,s.distance),t[i?"y":"x"]=r,h&&(h.style[i?"top":"left"]=`${r}px`);};});}this.label.attr({zIndex:8}).shadow(n.shadow).add();}return h&&!h.parentElement&&i.doc.body.appendChild(h),this.label}getPlayingField(){let{body:t,documentElement:e}=d,{chart:i,distance:s,outside:r}=this;return {width:r?Math.max(t.scrollWidth,e.scrollWidth,t.offsetWidth,e.offsetWidth,e.clientWidth)-2*s:i.chartWidth,height:r?Math.max(t.scrollHeight,e.scrollHeight,t.offsetHeight,e.offsetHeight,e.clientHeight):i.chartHeight}}getPosition(t,e,i){let{distance:s,chart:r,outside:o,pointer:n}=this,{inverted:a,plotLeft:h,plotTop:l,polar:d}=r,{plotX:c=0,plotY:p=0}=i,u={},g=a&&i.h||0,{height:f,width:m}=this.getPlayingField(),x=n.getChartPosition(),y=t=>t*x.scaleX,b=t=>t*x.scaleY,v=i=>{let n="x"===i;return [i,n?m:f,n?t:e].concat(o?[n?y(t):b(e),n?x.left-s+y(c+h):x.top-s+b(p+l),0,n?m:f]:[n?t:e,n?c+h:p+l,n?h:l,n?h+r.plotWidth:l+r.plotHeight])},S=v("y"),C=v("x"),M,w=!!i.negative;!d&&r.hoverSeries?.yAxis?.reversed&&(w=!w);let T=!this.followPointer&&k(i.ttBelow,!d&&!a===w),A=function(t,e,i,r,n,a,h){let l=o?"y"===t?b(s):y(s):s,d=(i-r)/2,c=r<n-s,p=n+s+r<e,f=n-l-i+d,m=n+l-d;if(T&&p)u[t]=m;else if(!T&&c)u[t]=f;else if(c)u[t]=Math.min(h-r,f-g<0?f:f-g);else {if(!p)return !1;u[t]=Math.max(a,m+g+i>e?m:m+g);}},P=function(t,e,i,r,o){if(o<s||o>e-s)return !1;o<i/2?u[t]=1:o>e-r/2?u[t]=e-r-2:u[t]=o-i/2;},L=function(t){[S,C]=[C,S],M=t;},O=()=>{!1!==A.apply(0,S)?!1!==P.apply(0,C)||M||(L(!0),O()):M?u.x=u.y=0:(L(!0),O());};return (a&&!d||this.len>1)&&L(),O(),u}hide(t){let e=this;o.clearTimeout(this.hideTimer),t=k(t,this.options.hideDelay),this.isHidden||(this.hideTimer=T(function(){let i=e.getLabel();e.getLabel().animate({opacity:0},{duration:t?150:t,complete:()=>{i.hide(),e.container&&e.container.remove();}}),e.isHidden=!0;},t));}init(t,e){this.chart=t,this.options=e,this.crosshairs=[],this.isHidden=!0,this.split=e.split&&!t.inverted&&!t.polar,this.shared=e.shared||this.split,this.outside=k(e.outside,!!(t.scrollablePixelsX||t.scrollablePixelsY));}shouldStickOnContact(t){return !!(!this.followPointer&&this.options.stickOnContact&&(!t||this.pointer.inClass(t.target,"highcharts-tooltip")))}move(t,e,i,s){let r=this,o=a(!r.isHidden&&r.options.animation),n=r.followPointer||(r.len||0)>1,h={x:t,y:e};n||(h.anchorX=i,h.anchorY=s),o.step=()=>r.drawTracker(),r.getLabel().animate(h,o);}refresh(t,e){let{chart:i,options:s,pointer:r,shared:n}=this,a=w(t),l=a[0],d=[],c=s.format,p=s.formatter||this.defaultFormatter,u=i.styledMode,f={},m=this.allowShared;if(!s.enabled||!l.series)return;o.clearTimeout(this.hideTimer),this.allowShared=!(!b(t)&&t.series&&t.series.noSharedTooltip),m=m&&!this.allowShared,this.followPointer=!this.split&&l.series.tooltipOptions.followPointer;let x=this.getAnchor(t,e),v=x[0],C=x[1];n&&this.allowShared?(r.applyInactiveState(a),a.forEach(function(t){t.setState("hover"),d.push(t.getLabelConfig());}),(f=l.getLabelConfig()).points=d):f=l.getLabelConfig(),this.len=d.length;let M=S(c)?h(c,f,i):p.call(f,this),T=l.series;if(this.distance=k(T.tooltipOptions.distance,16),!1===M)this.hide();else {if(this.split&&this.allowShared)this.renderSplit(M,a);else {let t=v,o=C;if(e&&r.isDirectTouch&&(t=e.chartX-i.plotLeft,o=e.chartY-i.plotTop),i.polar||!1===T.options.clip||a.some(e=>r.isDirectTouch||e.series.shouldShowTooltip(t,o))){let t=this.getLabel(m&&this.tt||{});(!s.style.width||u)&&t.css({width:(this.outside?this.getPlayingField():i.spacingBox).width+"px"}),t.attr({class:this.getClassName(l),text:M&&M.join?M.join(""):M}),this.outside&&t.attr({x:g(t.x||0,0,this.getPlayingField().width-(t.width||0))}),u||t.attr({stroke:s.borderColor||l.color||T.color||"#666666"}),this.updatePosition({plotX:v,plotY:C,negative:l.negative,ttBelow:l.ttBelow,h:x[2]||0});}else {this.hide();return}}this.isHidden&&this.label&&this.label.attr({opacity:1}).show(),this.isHidden=!1;}y(this,"refresh");}renderSplit(t,e){let i=this,{chart:s,chart:{chartWidth:r,chartHeight:o,plotHeight:n,plotLeft:a,plotTop:h,scrollablePixelsY:l=0,scrollablePixelsX:u,styledMode:f},distance:m,options:y,options:{positioner:b},pointer:v}=i,{scrollLeft:C=0,scrollTop:M=0}=s.scrollablePlotArea?.scrollingContainer||{},w=i.outside&&"number"!=typeof u?d.documentElement.getBoundingClientRect():{left:C,right:C+r,top:M,bottom:M+o},T=i.getLabel(),A=this.renderer||s.renderer,P=!!(s.xAxis[0]&&s.xAxis[0].opposite),{left:L,top:O}=v.getChartPosition(),D=h+M,E=0,I=n-l;function j(t,e,s,r,o=!0){let n,a;return s?(n=P?0:I,a=g(t-r/2,w.left,w.right-r-(i.outside?L:0))):(n=e-D,a=g(a=o?t-r-m:t+m,o?a:w.left,w.right)),{x:a,y:n}}S(t)&&(t=[!1,t]);let B=t.slice(0,e.length+1).reduce(function(t,s,r){if(!1!==s&&""!==s){let o=e[r-1]||{isHeader:!0,plotX:e[0].plotX,plotY:n,series:{}},l=o.isHeader,d=l?i:o.series,c=d.tt=function(t,e,s){let r=t,{isHeader:o,series:n}=e;if(!r){let t={padding:y.padding,r:y.borderRadius};f||(t.fill=y.backgroundColor,t["stroke-width"]=y.borderWidth??1),r=A.label("",0,0,y[o?"headerShape":"shape"],void 0,void 0,y.useHTML).addClass(i.getClassName(e,!0,o)).attr(t).add(T);}return r.isActive=!0,r.attr({text:s}),f||r.css(y.style).attr({stroke:y.borderColor||e.color||n.color||"#333333"}),r}(d.tt,o,s.toString()),p=c.getBBox(),u=p.width+c.strokeWidth();l&&(E=p.height,I+=E,P&&(D-=E));let{anchorX:x,anchorY:v}=function(t){let e,i;let{isHeader:s,plotX:r=0,plotY:o=0,series:l}=t;if(s)e=Math.max(a+r,a),i=h+n/2;else {let{xAxis:t,yAxis:s}=l;e=t.pos+g(r,-m,t.len+m),l.shouldShowTooltip(0,s.pos-h+o,{ignoreX:!0})&&(i=s.pos+o);}return {anchorX:e=g(e,w.left-m,w.right+m),anchorY:i}}(o);if("number"==typeof v){let e=p.height+1,s=b?b.call(i,u,e,o):j(x,v,l,u);t.push({align:b?0:void 0,anchorX:x,anchorY:v,boxWidth:u,point:o,rank:k(s.rank,l?1:0),size:e,target:s.y,tt:c,x:s.x});}else c.isActive=!1;}return t},[]);!b&&B.some(t=>{let{outside:e}=i,s=(e?L:0)+t.anchorX;return s<w.left&&s+t.boxWidth<w.right||s<L-w.left+t.boxWidth&&w.right-s>s})&&(B=B.map(t=>{let{x:e,y:i}=j(t.anchorX,t.anchorY,t.point.isHeader,t.boxWidth,!1);return x(t,{target:i,x:e})})),i.cleanSplit(),p(B,I);let R={left:L,right:L};B.forEach(function(t){let{x:e,boxWidth:s,isHeader:r}=t;!r&&(i.outside&&L+e<R.left&&(R.left=L+e),!r&&i.outside&&R.left+s>R.right&&(R.right=L+e));}),B.forEach(function(t){let{x:e,anchorX:s,anchorY:r,pos:o,point:{isHeader:n}}=t,a={visibility:void 0===o?"hidden":"inherit",x:e,y:(o||0)+D,anchorX:s,anchorY:r};if(i.outside&&e<s){let t=L-R.left;t>0&&(n||(a.x=e+t,a.anchorX=s+t),n&&(a.x=(R.right-R.left)/2,a.anchorX=s+t));}t.tt.attr(a);});let{container:z,outside:N,renderer:W}=i;if(N&&z&&W){let{width:t,height:e,x:i,y:s}=T.getBBox();W.setSize(t+i,e+s,!1),z.style.left=R.left+"px",z.style.top=O+"px";}c&&T.attr({opacity:1===T.opacity?.999:1});}drawTracker(){if(!this.shouldStickOnContact()){this.tracker&&(this.tracker=this.tracker.destroy());return}let t=this.chart,e=this.label,i=this.shared?t.hoverPoints:t.hoverPoint;if(!e||!i)return;let s={x:0,y:0,width:0,height:0},r=this.getAnchor(i),o=e.getBBox();r[0]+=t.plotLeft-(e.translateX||0),r[1]+=t.plotTop-(e.translateY||0),s.x=Math.min(0,r[0]),s.y=Math.min(0,r[1]),s.width=r[0]<0?Math.max(Math.abs(r[0]),o.width-r[0]):Math.max(Math.abs(r[0]),o.width),s.height=r[1]<0?Math.max(Math.abs(r[1]),o.height-Math.abs(r[1])):Math.max(Math.abs(r[1]),o.height),this.tracker?this.tracker.attr(s):(this.tracker=e.renderer.rect(s).addClass("highcharts-tracker").add(e),t.styledMode||this.tracker.attr({fill:"rgba(0,0,0,0)"}));}styledModeFormat(t){return t.replace('style="font-size: 0.8em"','class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g,'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"')}tooltipFooterHeaderFormatter(t,e){let i=t.series,s=i.tooltipOptions,r=i.xAxis,o=r&&r.dateTime,n={isFooter:e,labelConfig:t},a=s.xDateFormat,l=s[e?"footerFormat":"headerFormat"];return y(this,"headerFormatter",n,function(e){o&&!a&&v(t.key)&&(a=o.getXDateFormat(t.key,s.dateTimeLabelFormats)),o&&a&&(t.point&&t.point.tooltipDateKeys||["key"]).forEach(function(t){l=l.replace("{point."+t+"}","{point."+t+":"+a+"}");}),i.chart.styledMode&&(l=this.styledModeFormat(l)),e.text=h(l,{point:t,series:i},this.chart);}),n.text}update(t){this.destroy(),this.init(this.chart,C(!0,this.options,t));}updatePosition(t){let{chart:e,container:i,distance:s,options:r,pointer:o,renderer:n}=this,{height:a=0,width:h=0}=this.getLabel(),{left:l,top:d,scaleX:c,scaleY:p}=o.getChartPosition(),u=(r.positioner||this.getPosition).call(this,h,a,t),g=(t.plotX||0)+e.plotLeft,m=(t.plotY||0)+e.plotTop,x;n&&i&&(r.positioner&&(u.x+=l-s,u.y+=d-s),x=(r.borderWidth||0)+2*s+2,n.setSize(h+x,a+x,!1),(1!==c||1!==p)&&(f(i,{transform:`scale(${c}, ${p})`}),g*=c,m*=p),g+=l-u.x,m+=d-u.y),this.move(Math.round(u.x),Math.round(u.y||0),g,m);}}return (n=A||(A={})).compose=function(t){M(l,"Core.Tooltip")&&u(t,"afterInit",function(){let t=this.chart;t.options.tooltip&&(t.tooltip=new n(t,t.options.tooltip,this));});},A}),i(e,"Core/Series/Point.js",[e["Core/Renderer/HTML/AST.js"],e["Core/Animation/AnimationUtilities.js"],e["Core/Defaults.js"],e["Core/Templating.js"],e["Core/Utilities.js"]],function(t,e,i,s,r){let{animObject:o}=e,{defaultOptions:n}=i,{format:a}=s,{addEvent:h,crisp:l,erase:d,extend:c,fireEvent:p,getNestedProperty:u,isArray:g,isFunction:f,isNumber:m,isObject:x,merge:y,pick:b,syncTimeout:v,removeEvent:S,uniqueKey:C}=r;class k{animateBeforeDestroy(){let t=this,e={x:t.startXPos,opacity:0},i=t.getGraphicalProps();i.singular.forEach(function(i){t[i]=t[i].animate("dataLabel"===i?{x:t[i].startXPos,y:t[i].startYPos,opacity:0}:e);}),i.plural.forEach(function(e){t[e].forEach(function(e){e.element&&e.animate(c({x:t.startXPos},e.startYPos?{x:e.startXPos,y:e.startYPos}:{}));});});}applyOptions(t,e){let i=this.series,s=i.options.pointValKey||i.pointValKey;return c(this,t=k.prototype.optionsToObject.call(this,t)),this.options=this.options?c(this.options,t):t,t.group&&delete this.group,t.dataLabels&&delete this.dataLabels,s&&(this.y=k.prototype.getNestedProperty.call(this,s)),this.selected&&(this.state="select"),"name"in this&&void 0===e&&i.xAxis&&i.xAxis.hasNames&&(this.x=i.xAxis.nameToX(this)),void 0===this.x&&i?this.x=e??i.autoIncrement():m(t.x)&&i.options.relativeXValue&&(this.x=i.autoIncrement(t.x)),this.isNull=this.isValid&&!this.isValid(),this.formatPrefix=this.isNull?"null":"point",this}destroy(){if(!this.destroyed){let t=this,e=t.series,i=e.chart,s=e.options.dataSorting,r=i.hoverPoints,n=o(t.series.chart.renderer.globalAnimation),a=()=>{for(let e in (t.graphic||t.graphics||t.dataLabel||t.dataLabels)&&(S(t),t.destroyElements()),t)delete t[e];};t.legendItem&&i.legend.destroyItem(t),r&&(t.setState(),d(r,t),r.length||(i.hoverPoints=null)),t===i.hoverPoint&&t.onMouseOut(),s&&s.enabled?(this.animateBeforeDestroy(),v(a,n.duration)):a(),i.pointCount--;}this.destroyed=!0;}destroyElements(t){let e=this,i=e.getGraphicalProps(t);i.singular.forEach(function(t){e[t]=e[t].destroy();}),i.plural.forEach(function(t){e[t].forEach(function(t){t&&t.element&&t.destroy();}),delete e[t];});}firePointEvent(t,e,i){let s=this,r=this.series.options;s.manageEvent(t),"click"===t&&r.allowPointSelect&&(i=function(t){!s.destroyed&&s.select&&s.select(null,t.ctrlKey||t.metaKey||t.shiftKey);}),p(s,t,e,i);}getClassName(){return "highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":"")+(void 0!==this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?" "+this.zone.className.replace("highcharts-negative",""):"")}getGraphicalProps(t){let e,i;let s=this,r=[],o={singular:[],plural:[]};for((t=t||{graphic:1,dataLabel:1}).graphic&&r.push("graphic","connector"),t.dataLabel&&r.push("dataLabel","dataLabelPath","dataLabelUpper"),i=r.length;i--;)s[e=r[i]]&&o.singular.push(e);return ["graphic","dataLabel"].forEach(function(e){let i=e+"s";t[e]&&s[i]&&o.plural.push(i);}),o}getLabelConfig(){return {x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}}getNestedProperty(t){return t?0===t.indexOf("custom.")?u(t,this.options):this[t]:void 0}getZone(){let t=this.series,e=t.zones,i=t.zoneAxis||"y",s,r=0;for(s=e[0];this[i]>=s.value;)s=e[++r];return this.nonZonedColor||(this.nonZonedColor=this.color),s&&s.color&&!this.options.color?this.color=s.color:this.color=this.nonZonedColor,s}hasNewShapeType(){return (this.graphic&&(this.graphic.symbolName||this.graphic.element.nodeName))!==this.shapeType}constructor(t,e,i){this.formatPrefix="point",this.visible=!0,this.series=t,this.applyOptions(e,i),this.id??(this.id=C()),this.resolveColor(),t.chart.pointCount++,p(this,"afterInit");}isValid(){return (m(this.x)||this.x instanceof Date)&&m(this.y)}optionsToObject(t){let e=this.series,i=e.options.keys,s=i||e.pointArrayMap||["y"],r=s.length,o={},n,a=0,h=0;if(m(t)||null===t)o[s[0]]=t;else if(g(t))for(!i&&t.length>r&&("string"==(n=typeof t[0])?o.name=t[0]:"number"===n&&(o.x=t[0]),a++);h<r;)i&&void 0===t[a]||(s[h].indexOf(".")>0?k.prototype.setNestedProperty(o,t[a],s[h]):o[s[h]]=t[a]),a++,h++;else "object"==typeof t&&(o=t,t.dataLabels&&(e.hasDataLabels=()=>!0),t.marker&&(e._hasPointMarkers=!0));return o}pos(t,e=this.plotY){if(!this.destroyed){let{plotX:i,series:s}=this,{chart:r,xAxis:o,yAxis:n}=s,a=0,h=0;if(m(i)&&m(e))return t&&(a=o?o.pos:r.plotLeft,h=n?n.pos:r.plotTop),r.inverted&&o&&n?[n.len-e+h,o.len-i+a]:[i+a,e+h]}}resolveColor(){let t=this.series,e=t.chart.options.chart,i=t.chart.styledMode,s,r,o=e.colorCount,n;delete this.nonZonedColor,t.options.colorByPoint?(i||(s=(r=t.options.colors||t.chart.options.colors)[t.colorCounter],o=r.length),n=t.colorCounter,t.colorCounter++,t.colorCounter===o&&(t.colorCounter=0)):(i||(s=t.color),n=t.colorIndex),this.colorIndex=b(this.options.colorIndex,n),this.color=b(this.options.color,s);}setNestedProperty(t,e,i){return i.split(".").reduce(function(t,i,s,r){let o=r.length-1===s;return t[i]=o?e:x(t[i],!0)?t[i]:{},t[i]},t),t}shouldDraw(){return !this.isNull}tooltipFormatter(t){let e=this.series,i=e.tooltipOptions,s=b(i.valueDecimals,""),r=i.valuePrefix||"",o=i.valueSuffix||"";return e.chart.styledMode&&(t=e.chart.tooltip.styledModeFormat(t)),(e.pointArrayMap||["y"]).forEach(function(e){e="{point."+e,(r||o)&&(t=t.replace(RegExp(e+"}","g"),r+e+"}"+o)),t=t.replace(RegExp(e+"}","g"),e+":,."+s+"f}");}),a(t,{point:this,series:this.series},e.chart)}update(t,e,i,s){let r;let o=this,n=o.series,a=o.graphic,h=n.chart,l=n.options;function d(){o.applyOptions(t);let s=a&&o.hasMockGraphic,d=null===o.y?!s:s;a&&d&&(o.graphic=a.destroy(),delete o.hasMockGraphic),x(t,!0)&&(a&&a.element&&t&&t.marker&&void 0!==t.marker.symbol&&(o.graphic=a.destroy()),t?.dataLabels&&o.dataLabel&&(o.dataLabel=o.dataLabel.destroy())),r=o.index,n.updateParallelArrays(o,r),l.data[r]=x(l.data[r],!0)||x(t,!0)?o.options:b(t,l.data[r]),n.isDirty=n.isDirtyData=!0,!n.fixedBox&&n.hasCartesianSeries&&(h.isDirtyBox=!0),"point"===l.legendType&&(h.isDirtyLegend=!0),e&&h.redraw(i);}e=b(e,!0),!1===s?d():o.firePointEvent("update",{options:t},d);}remove(t,e){this.series.removePoint(this.series.data.indexOf(this),t,e);}select(t,e){let i=this,s=i.series,r=s.chart;t=b(t,!i.selected),this.selectedStaging=t,i.firePointEvent(t?"select":"unselect",{accumulate:e},function(){i.selected=i.options.selected=t,s.options.data[s.data.indexOf(i)]=i.options,i.setState(t&&"select"),e||r.getSelectedPoints().forEach(function(t){let e=t.series;t.selected&&t!==i&&(t.selected=t.options.selected=!1,e.options.data[e.data.indexOf(t)]=t.options,t.setState(r.hoverPoints&&e.options.inactiveOtherPoints?"inactive":""),t.firePointEvent("unselect"));});}),delete this.selectedStaging;}onMouseOver(t){let{inverted:e,pointer:i}=this.series.chart;i&&(t=t?i.normalize(t):i.getChartCoordinatesFromPoint(this,e),i.runPointActions(t,this));}onMouseOut(){let t=this.series.chart;this.firePointEvent("mouseOut"),this.series.options.inactiveOtherPoints||(t.hoverPoints||[]).forEach(function(t){t.setState();}),t.hoverPoints=t.hoverPoint=null;}manageEvent(t){let e=y(this.series.options.point,this.options),i=e.events?.[t];f(i)&&(!this.hcEvents?.[t]||this.hcEvents?.[t]?.map(t=>t.fn).indexOf(i)===-1)?(this.importedUserEvent?.(),this.importedUserEvent=h(this,t,i)):this.importedUserEvent&&!i&&this.hcEvents?.[t]&&(S(this,t),delete this.hcEvents[t],Object.keys(this.hcEvents)||delete this.importedUserEvent);}setState(e,i){let s=this.series,r=this.state,o=s.options.states[e||"normal"]||{},a=n.plotOptions[s.type].marker&&s.options.marker,h=a&&!1===a.enabled,l=a&&a.states&&a.states[e||"normal"]||{},d=!1===l.enabled,u=this.marker||{},g=s.chart,f=a&&s.markerAttribs,x=s.halo,y,v,S,C=s.stateMarkerGraphic,k;if((e=e||"")===this.state&&!i||this.selected&&"select"!==e||!1===o.enabled||e&&(d||h&&!1===l.enabled)||e&&u.states&&u.states[e]&&!1===u.states[e].enabled)return;if(this.state=e,f&&(y=s.markerAttribs(this,e)),this.graphic&&!this.hasMockGraphic){if(r&&this.graphic.removeClass("highcharts-point-"+r),e&&this.graphic.addClass("highcharts-point-"+e),!g.styledMode){v=s.pointAttribs(this,e),S=b(g.options.chart.animation,o.animation);let t=v.opacity;s.options.inactiveOtherPoints&&m(t)&&(this.dataLabels||[]).forEach(function(e){e&&!e.hasClass("highcharts-data-label-hidden")&&(e.animate({opacity:t},S),e.connector&&e.connector.animate({opacity:t},S));}),this.graphic.animate(v,S);}y&&this.graphic.animate(y,b(g.options.chart.animation,l.animation,a.animation)),C&&C.hide();}else e&&l&&(k=u.symbol||s.symbol,C&&C.currentSymbol!==k&&(C=C.destroy()),y&&(C?C[i?"animate":"attr"]({x:y.x,y:y.y}):k&&(s.stateMarkerGraphic=C=g.renderer.symbol(k,y.x,y.y,y.width,y.height).add(s.markerGroup),C.currentSymbol=k)),!g.styledMode&&C&&"inactive"!==this.state&&C.attr(s.pointAttribs(this,e))),C&&(C[e&&this.isInside?"show":"hide"](),C.element.point=this,C.addClass(this.getClassName(),!0));let M=o.halo,w=this.graphic||C,T=w&&w.visibility||"inherit";M&&M.size&&w&&"hidden"!==T&&!this.isCluster?(x||(s.halo=x=g.renderer.path().add(w.parentGroup)),x.show()[i?"animate":"attr"]({d:this.haloPath(M.size)}),x.attr({class:"highcharts-halo highcharts-color-"+b(this.colorIndex,s.colorIndex)+(this.className?" "+this.className:""),visibility:T,zIndex:-1}),x.point=this,g.styledMode||x.attr(c({fill:this.color||s.color,"fill-opacity":M.opacity},t.filterUserAttributes(M.attributes||{})))):x?.point?.haloPath&&!x.point.destroyed&&x.animate({d:x.point.haloPath(0)},null,x.hide),p(this,"afterSetState",{state:e});}haloPath(t){let e=this.pos();return e?this.series.chart.renderer.symbols.circle(l(e[0],1)-t,e[1]-t,2*t,2*t):[]}}return k}),i(e,"Core/Pointer.js",[e["Core/Color/Color.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e,i){var s;let{parse:r}=t,{charts:o,composed:n,isTouchDevice:a}=e,{addEvent:h,attr:l,css:d,extend:c,find:p,fireEvent:u,isNumber:g,isObject:f,objectEach:m,offset:x,pick:y,pushUnique:b,splat:v}=i;class S{applyInactiveState(t){let e=[],i;(t||[]).forEach(function(t){i=t.series,e.push(i),i.linkedParent&&e.push(i.linkedParent),i.linkedSeries&&(e=e.concat(i.linkedSeries)),i.navigatorSeries&&e.push(i.navigatorSeries);}),this.chart.series.forEach(function(t){-1===e.indexOf(t)?t.setState("inactive",!0):t.options.inactiveOtherPoints&&t.setAllPointsToState("inactive");});}destroy(){let t=this;this.eventsToUnbind.forEach(t=>t()),this.eventsToUnbind=[],!e.chartCount&&(S.unbindDocumentMouseUp&&S.unbindDocumentMouseUp.forEach(t=>t()),S.unbindDocumentTouchEnd&&(S.unbindDocumentTouchEnd=S.unbindDocumentTouchEnd())),clearInterval(t.tooltipTimeout),m(t,function(e,i){t[i]=void 0;});}getSelectionMarkerAttrs(t,e){let i={args:{chartX:t,chartY:e},attrs:{},shapeType:"rect"};return u(this,"getSelectionMarkerAttrs",i,i=>{let s;let{chart:r,zoomHor:o,zoomVert:n}=this,{mouseDownX:a=0,mouseDownY:h=0}=r,l=i.attrs;l.x=r.plotLeft,l.y=r.plotTop,l.width=o?1:r.plotWidth,l.height=n?1:r.plotHeight,o&&(s=t-a,l.width=Math.max(1,Math.abs(s)),l.x=(s>0?0:s)+a),n&&(s=e-h,l.height=Math.max(1,Math.abs(s)),l.y=(s>0?0:s)+h);}),i}drag(t){let{chart:e}=this,{mouseDownX:i=0,mouseDownY:s=0}=e,{panning:o,panKey:n,selectionMarkerFill:a}=e.options.chart,h=e.plotLeft,l=e.plotTop,d=e.plotWidth,c=e.plotHeight,p=f(o)?o.enabled:o,u=n&&t[`${n}Key`],g=t.chartX,m=t.chartY,x,y=this.selectionMarker;if((!y||!y.touch)&&(g<h?g=h:g>h+d&&(g=h+d),m<l?m=l:m>l+c&&(m=l+c),this.hasDragged=Math.sqrt(Math.pow(i-g,2)+Math.pow(s-m,2)),this.hasDragged>10)){x=e.isInsidePlot(i-h,s-l,{visiblePlotOnly:!0});let{shapeType:n,attrs:d}=this.getSelectionMarkerAttrs(g,m);(e.hasCartesianSeries||e.mapView)&&this.hasZoom&&x&&!u&&!y&&(this.selectionMarker=y=e.renderer[n](),y.attr({class:"highcharts-selection-marker",zIndex:7}).add(),e.styledMode||y.attr({fill:a||r("#334eff").setOpacity(.25).get()})),y&&y.attr(d),x&&!y&&p&&e.pan(t,o);}}dragStart(t){let e=this.chart;e.mouseIsDown=t.type,e.cancelClick=!1,e.mouseDownX=t.chartX,e.mouseDownY=t.chartY;}getSelectionBox(t){let e={args:{marker:t},result:t.getBBox()};return u(this,"getSelectionBox",e),e.result}drop(t){let e;let{chart:i,selectionMarker:s}=this;for(let t of i.axes)t.isPanning&&(t.isPanning=!1,(t.options.startOnTick||t.options.endOnTick||t.series.some(t=>t.boosted))&&(t.forceRedraw=!0,t.setExtremes(t.userMin,t.userMax,!1),e=!0));if(e&&i.redraw(),s&&t){if(this.hasDragged){let e=this.getSelectionBox(s);i.transform({axes:i.axes.filter(t=>t.zoomEnabled&&("xAxis"===t.coll&&this.zoomX||"yAxis"===t.coll&&this.zoomY)),selection:{originalEvent:t,xAxis:[],yAxis:[],...e},from:e});}g(i.index)&&(this.selectionMarker=s.destroy());}i&&g(i.index)&&(d(i.container,{cursor:i._cursor}),i.cancelClick=this.hasDragged>10,i.mouseIsDown=!1,this.hasDragged=0,this.pinchDown=[]);}findNearestKDPoint(t,e,i){let s;return t.forEach(function(t){let r=!(t.noSharedTooltip&&e)&&0>t.options.findNearestPointBy.indexOf("y"),o=t.searchPoint(i,r);f(o,!0)&&o.series&&(!f(s,!0)||function(t,i){let s=t.distX-i.distX,r=t.dist-i.dist,o=i.series.group?.zIndex-t.series.group?.zIndex;return 0!==s&&e?s:0!==r?r:0!==o?o:t.series.index>i.series.index?-1:1}(s,o)>0)&&(s=o);}),s}getChartCoordinatesFromPoint(t,e){let{xAxis:i,yAxis:s}=t.series,r=t.shapeArgs;if(i&&s){let o=t.clientX??t.plotX??0,n=t.plotY||0;return t.isNode&&r&&g(r.x)&&g(r.y)&&(o=r.x,n=r.y),e?{chartX:s.len+s.pos-n,chartY:i.len+i.pos-o}:{chartX:o+i.pos,chartY:n+s.pos}}if(r&&r.x&&r.y)return {chartX:r.x,chartY:r.y}}getChartPosition(){if(this.chartPosition)return this.chartPosition;let{container:t}=this.chart,e=x(t);this.chartPosition={left:e.left,top:e.top,scaleX:1,scaleY:1};let{offsetHeight:i,offsetWidth:s}=t;return s>2&&i>2&&(this.chartPosition.scaleX=e.width/s,this.chartPosition.scaleY=e.height/i),this.chartPosition}getCoordinates(t){let e={xAxis:[],yAxis:[]};for(let i of this.chart.axes)e[i.isXAxis?"xAxis":"yAxis"].push({axis:i,value:i.toValue(t[i.horiz?"chartX":"chartY"])});return e}getHoverData(t,e,i,s,r,o){let n=[],a=function(t){return t.visible&&!(!r&&t.directTouch)&&y(t.options.enableMouseTracking,!0)},h=e,l,d={chartX:o?o.chartX:void 0,chartY:o?o.chartY:void 0,shared:r};u(this,"beforeGetHoverData",d),l=h&&!h.stickyTracking?[h]:i.filter(t=>t.stickyTracking&&(d.filter||a)(t));let c=s&&t||!o?t:this.findNearestKDPoint(l,r,o);return h=c&&c.series,c&&(r&&!h.noSharedTooltip?(l=i.filter(function(t){return d.filter?d.filter(t):a(t)&&!t.noSharedTooltip})).forEach(function(t){let e=p(t.points,function(t){return t.x===c.x&&!t.isNull});f(e)&&(t.boosted&&t.boost&&(e=t.boost.getPoint(e)),n.push(e));}):n.push(c)),u(this,"afterGetHoverData",d={hoverPoint:c}),{hoverPoint:d.hoverPoint,hoverSeries:h,hoverPoints:n}}getPointFromEvent(t){let e=t.target,i;for(;e&&!i;)i=e.point,e=e.parentNode;return i}onTrackerMouseOut(t){let e=this.chart,i=t.relatedTarget,s=e.hoverSeries;this.isDirectTouch=!1,!s||!i||s.stickyTracking||this.inClass(i,"highcharts-tooltip")||this.inClass(i,"highcharts-series-"+s.index)&&this.inClass(i,"highcharts-tracker")||s.onMouseOut();}inClass(t,e){let i=t,s;for(;i;){if(s=l(i,"class")){if(-1!==s.indexOf(e))return !0;if(-1!==s.indexOf("highcharts-container"))return !1}i=i.parentElement;}}constructor(t,e){this.hasDragged=0,this.pointerCaptureEventsToUnbind=[],this.eventsToUnbind=[],this.options=e,this.chart=t,this.runChartClick=!!e.chart.events?.click,this.pinchDown=[],this.setDOMEvents(),u(this,"afterInit");}normalize(t,e){let i=t.touches,s=i?i.length?i.item(0):y(i.changedTouches,t.changedTouches)[0]:t;e||(e=this.getChartPosition());let r=s.pageX-e.left,o=s.pageY-e.top;return c(t,{chartX:Math.round(r/=e.scaleX),chartY:Math.round(o/=e.scaleY)})}onContainerClick(t){let e=this.chart,i=e.hoverPoint,s=this.normalize(t),r=e.plotLeft,o=e.plotTop;!e.cancelClick&&(i&&this.inClass(s.target,"highcharts-tracker")?(u(i.series,"click",c(s,{point:i})),e.hoverPoint&&i.firePointEvent("click",s)):(c(s,this.getCoordinates(s)),e.isInsidePlot(s.chartX-r,s.chartY-o,{visiblePlotOnly:!0})&&u(e,"click",s)));}onContainerMouseDown(t){let i=(1&(t.buttons||t.button))==1;t=this.normalize(t),e.isFirefox&&0!==t.button&&this.onContainerMouseMove(t),(void 0===t.button||i)&&(this.zoomOption(t),i&&t.preventDefault?.(),this.dragStart(t));}onContainerMouseLeave(t){let{pointer:e}=o[y(S.hoverChartIndex,-1)]||{};t=this.normalize(t),this.onContainerMouseMove(t),e&&!this.inClass(t.relatedTarget,"highcharts-tooltip")&&(e.reset(),e.chartPosition=void 0);}onContainerMouseEnter(){delete this.chartPosition;}onContainerMouseMove(t){let e=this.chart,i=e.tooltip,s=this.normalize(t);this.setHoverChartIndex(t),("mousedown"===e.mouseIsDown||this.touchSelect(s))&&this.drag(s),!e.openMenu&&(this.inClass(s.target,"highcharts-tracker")||e.isInsidePlot(s.chartX-e.plotLeft,s.chartY-e.plotTop,{visiblePlotOnly:!0}))&&!(i&&i.shouldStickOnContact(s))&&(this.inClass(s.target,"highcharts-no-tooltip")?this.reset(!1,0):this.runPointActions(s));}onDocumentTouchEnd(t){this.onDocumentMouseUp(t);}onContainerTouchMove(t){this.touchSelect(t)?this.onContainerMouseMove(t):this.touch(t);}onContainerTouchStart(t){this.touchSelect(t)?this.onContainerMouseDown(t):(this.zoomOption(t),this.touch(t,!0));}onDocumentMouseMove(t){let e=this.chart,i=e.tooltip,s=this.chartPosition,r=this.normalize(t,s);!s||e.isInsidePlot(r.chartX-e.plotLeft,r.chartY-e.plotTop,{visiblePlotOnly:!0})||i&&i.shouldStickOnContact(r)||r.target!==e.container.ownerDocument&&this.inClass(r.target,"highcharts-tracker")||this.reset();}onDocumentMouseUp(t){o[y(S.hoverChartIndex,-1)]?.pointer?.drop(t);}pinch(t){let e=this,{chart:i,hasZoom:s,lastTouches:r}=e,o=[].map.call(t.touches||[],t=>e.normalize(t)),n=o.length,a=1===n&&(e.inClass(t.target,"highcharts-tracker")&&i.runTrackerClick||e.runChartClick),h=i.tooltip,l=1===n&&y(h?.options.followTouchMove,!0);n>1?e.initiated=!0:l&&(e.initiated=!1),s&&e.initiated&&!a&&!1!==t.cancelable&&t.preventDefault(),"touchstart"===t.type?(e.pinchDown=o,e.res=!0,i.mouseDownX=t.chartX):l?this.runPointActions(e.normalize(t)):r&&(u(i,"touchpan",{originalEvent:t,touches:o},()=>{let e=t=>{let e=t[0],i=t[1]||e;return {x:e.chartX,y:e.chartY,width:i.chartX-e.chartX,height:i.chartY-e.chartY}};i.transform({axes:i.axes.filter(t=>t.zoomEnabled&&(this.zoomHor&&t.horiz||this.zoomVert&&!t.horiz)),to:e(o),from:e(r),trigger:t.type});}),e.res&&(e.res=!1,this.reset(!1,0))),e.lastTouches=o;}reset(t,e){let i=this.chart,s=i.hoverSeries,r=i.hoverPoint,o=i.hoverPoints,n=i.tooltip,a=n&&n.shared?o:r;t&&a&&v(a).forEach(function(e){e.series.isCartesian&&void 0===e.plotX&&(t=!1);}),t?n&&a&&v(a).length&&(n.refresh(a),n.shared&&o?o.forEach(function(t){t.setState(t.state,!0),t.series.isCartesian&&(t.series.xAxis.crosshair&&t.series.xAxis.drawCrosshair(null,t),t.series.yAxis.crosshair&&t.series.yAxis.drawCrosshair(null,t));}):r&&(r.setState(r.state,!0),i.axes.forEach(function(t){t.crosshair&&r.series[t.coll]===t&&t.drawCrosshair(null,r);}))):(r&&r.onMouseOut(),o&&o.forEach(function(t){t.setState();}),s&&s.onMouseOut(),n&&n.hide(e),this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove()),i.axes.forEach(function(t){t.hideCrosshair();}),i.hoverPoints=i.hoverPoint=void 0);}runPointActions(t,e,i){let s=this.chart,r=s.series,n=s.tooltip&&s.tooltip.options.enabled?s.tooltip:void 0,a=!!n&&n.shared,l=e||s.hoverPoint,d=l&&l.series||s.hoverSeries,c=(!t||"touchmove"!==t.type)&&(!!e||d&&d.directTouch&&this.isDirectTouch),u=this.getHoverData(l,d,r,c,a,t);l=u.hoverPoint,d=u.hoverSeries;let g=u.hoverPoints,f=d&&d.tooltipOptions.followPointer&&!d.tooltipOptions.split,m=a&&d&&!d.noSharedTooltip;if(l&&(i||l!==s.hoverPoint||n&&n.isHidden)){if((s.hoverPoints||[]).forEach(function(t){-1===g.indexOf(t)&&t.setState();}),s.hoverSeries!==d&&d.onMouseOver(),this.applyInactiveState(g),(g||[]).forEach(function(t){t.setState("hover");}),s.hoverPoint&&s.hoverPoint.firePointEvent("mouseOut"),!l.series)return;s.hoverPoints=g,s.hoverPoint=l,l.firePointEvent("mouseOver",void 0,()=>{n&&l&&n.refresh(m?g:l,t);});}else if(f&&n&&!n.isHidden){let e=n.getAnchor([{}],t);s.isInsidePlot(e[0],e[1],{visiblePlotOnly:!0})&&n.updatePosition({plotX:e[0],plotY:e[1]});}this.unDocMouseMove||(this.unDocMouseMove=h(s.container.ownerDocument,"mousemove",t=>o[S.hoverChartIndex??-1]?.pointer?.onDocumentMouseMove(t)),this.eventsToUnbind.push(this.unDocMouseMove)),s.axes.forEach(function(e){let i;let r=y((e.crosshair||{}).snap,!0);!r||(i=s.hoverPoint)&&i.series[e.coll]===e||(i=p(g,t=>t.series&&t.series[e.coll]===e)),i||!r?e.drawCrosshair(t,i):e.hideCrosshair();});}setDOMEvents(){let t=this.chart.container,e=t.ownerDocument;t.onmousedown=this.onContainerMouseDown.bind(this),t.onmousemove=this.onContainerMouseMove.bind(this),t.onclick=this.onContainerClick.bind(this),this.eventsToUnbind.push(h(t,"mouseenter",this.onContainerMouseEnter.bind(this)),h(t,"mouseleave",this.onContainerMouseLeave.bind(this))),S.unbindDocumentMouseUp||(S.unbindDocumentMouseUp=[]),S.unbindDocumentMouseUp.push(h(e,"mouseup",this.onDocumentMouseUp.bind(this)));let i=this.chart.renderTo.parentElement;for(;i&&"BODY"!==i.tagName;)this.eventsToUnbind.push(h(i,"scroll",()=>{delete this.chartPosition;})),i=i.parentElement;this.eventsToUnbind.push(h(t,"touchstart",this.onContainerTouchStart.bind(this),{passive:!1}),h(t,"touchmove",this.onContainerTouchMove.bind(this),{passive:!1})),S.unbindDocumentTouchEnd||(S.unbindDocumentTouchEnd=h(e,"touchend",this.onDocumentTouchEnd.bind(this),{passive:!1})),this.setPointerCapture(),h(this.chart,"redraw",this.setPointerCapture.bind(this));}setPointerCapture(){if(!a)return;let t=this.pointerCaptureEventsToUnbind,e=this.chart,i=e.container,s=y(e.options.tooltip?.followTouchMove,!0)&&e.series.some(t=>t.options.findNearestPointBy.indexOf("y")>-1);!this.hasPointerCapture&&s?(t.push(h(i,"pointerdown",t=>{t.target?.hasPointerCapture(t.pointerId)&&t.target?.releasePointerCapture(t.pointerId);}),h(i,"pointermove",t=>{e.pointer?.getPointFromEvent(t)?.onMouseOver(t);})),e.styledMode||d(i,{"touch-action":"none"}),i.className+=" highcharts-no-touch-action",this.hasPointerCapture=!0):this.hasPointerCapture&&!s&&(t.forEach(t=>t()),t.length=0,e.styledMode||d(i,{"touch-action":y(e.options.chart.style?.["touch-action"],"manipulation")}),i.className=i.className.replace(" highcharts-no-touch-action",""),this.hasPointerCapture=!1);}setHoverChartIndex(t){let i=this.chart,s=e.charts[y(S.hoverChartIndex,-1)];if(s&&s!==i){let e={relatedTarget:i.container};t&&!t?.relatedTarget&&(t={...e,...t}),s.pointer?.onContainerMouseLeave(t||e);}s&&s.mouseIsDown||(S.hoverChartIndex=i.index);}touch(t,e){let i;let{chart:s,pinchDown:r=[]}=this;this.setHoverChartIndex(),1===(t=this.normalize(t)).touches.length?s.isInsidePlot(t.chartX-s.plotLeft,t.chartY-s.plotTop,{visiblePlotOnly:!0})&&!s.openMenu?(e&&this.runPointActions(t),"touchmove"===t.type&&(i=!!r[0]&&Math.pow(r[0].chartX-t.chartX,2)+Math.pow(r[0].chartY-t.chartY,2)>=16),y(i,!0)&&this.pinch(t)):e&&this.reset():2===t.touches.length&&this.pinch(t);}touchSelect(t){return !!(this.chart.zooming.singleTouch&&t.touches&&1===t.touches.length)}zoomOption(t){let e=this.chart,i=e.inverted,s=e.zooming.type||"",r,o;/touch/.test(t.type)&&(s=y(e.zooming.pinchType,s)),this.zoomX=r=/x/.test(s),this.zoomY=o=/y/.test(s),this.zoomHor=r&&!i||o&&i,this.zoomVert=o&&!i||r&&i,this.hasZoom=r||o;}}return (s=S||(S={})).compose=function(t){b(n,"Core.Pointer")&&h(t,"beforeRender",function(){this.pointer=new s(this,this.options);});},S}),i(e,"Core/Legend/LegendSymbol.js",[e["Core/Utilities.js"]],function(t){var e;let{extend:i,merge:s,pick:r}=t;return function(t){function e(t,e,o){let n=this.legendItem=this.legendItem||{},{chart:a,options:h}=this,{baseline:l=0,symbolWidth:d,symbolHeight:c}=t,p=this.symbol||"circle",u=c/2,g=a.renderer,f=n.group,m=l-Math.round((t.fontMetrics?.b||c)*(o?.4:.3)),x={},y,b=h.marker,v=0;if(a.styledMode||(x["stroke-width"]=Math.min(h.lineWidth||0,24),h.dashStyle?x.dashstyle=h.dashStyle:"square"===h.linecap||(x["stroke-linecap"]="round")),n.line=g.path().addClass("highcharts-graph").attr(x).add(f),o&&(n.area=g.path().addClass("highcharts-area").add(f)),x["stroke-linecap"]&&(v=Math.min(n.line.strokeWidth(),d)/2),d){let t=[["M",v,m],["L",d-v,m]];n.line.attr({d:t}),n.area?.attr({d:[...t,["L",d-v,l],["L",v,l]]});}if(b&&!1!==b.enabled&&d){let t=Math.min(r(b.radius,u),u);0===p.indexOf("url")&&(b=s(b,{width:c,height:c}),t=0),n.symbol=y=g.symbol(p,d/2-t,m-t,2*t,2*t,i({context:"legend"},b)).addClass("highcharts-point").add(f),y.isMarker=!0;}}t.areaMarker=function(t,i){e.call(this,t,i,!0);},t.lineMarker=e,t.rectangle=function(t,e){let i=e.legendItem||{},s=t.options,o=t.symbolHeight,n=s.squareSymbol,a=n?o:t.symbolWidth;i.symbol=this.chart.renderer.rect(n?(t.symbolWidth-o)/2:0,t.baseline-o+1,a,o,r(t.options.symbolRadius,o/2)).addClass("highcharts-point").attr({zIndex:3}).add(i.group);};}(e||(e={})),e}),i(e,"Core/Series/SeriesDefaults.js",[],function(){return {lineWidth:2,allowPointSelect:!1,crisp:!0,showCheckbox:!1,animation:{duration:1e3},enableMouseTracking:!0,events:{},marker:{enabledThreshold:2,lineColor:"#ffffff",lineWidth:0,radius:4,states:{normal:{animation:!0},hover:{animation:{duration:150},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{animation:{},align:"center",borderWidth:0,defer:!0,formatter:function(){let{numberFormatter:t}=this.series.chart;return "number"!=typeof this.y?"":t(this.y,-1)},padding:5,style:{fontSize:"0.7em",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",x:0,y:0},cropThreshold:300,opacity:1,pointRange:0,softThreshold:!0,states:{normal:{animation:!0},hover:{animation:{duration:150},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{animation:{duration:0}},inactive:{animation:{duration:150},opacity:.2}},stickyTracking:!0,turboThreshold:1e3,findNearestPointBy:"x"}}),i(e,"Core/Series/SeriesRegistry.js",[e["Core/Globals.js"],e["Core/Defaults.js"],e["Core/Series/Point.js"],e["Core/Utilities.js"]],function(t,e,i,s){var r;let{defaultOptions:o}=e,{extend:n,extendClass:a,merge:h}=s;return function(e){function s(t,s){let r=o.plotOptions||{},n=s.defaultOptions,a=s.prototype;return a.type=t,a.pointClass||(a.pointClass=i),!e.seriesTypes[t]&&(n&&(r[t]=n),e.seriesTypes[t]=s,!0)}e.seriesTypes=t.seriesTypes,e.registerSeriesType=s,e.seriesType=function(t,r,l,d,c){let p=o.plotOptions||{};if(r=r||"",p[t]=h(p[r],l),delete e.seriesTypes[t],s(t,a(e.seriesTypes[r]||function(){},d)),e.seriesTypes[t].prototype.type=t,c){class s extends i{}n(s.prototype,c),e.seriesTypes[t].prototype.pointClass=s;}return e.seriesTypes[t]};}(r||(r={})),r}),i(e,"Core/Series/Series.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Defaults.js"],e["Core/Foundation.js"],e["Core/Globals.js"],e["Core/Legend/LegendSymbol.js"],e["Core/Series/Point.js"],e["Core/Series/SeriesDefaults.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Renderer/SVG/SVGElement.js"],e["Core/Utilities.js"]],function(t,e,i,s,r,o,n,a,h,l){let{animObject:d,setAnimation:c}=t,{defaultOptions:p}=e,{registerEventOptions:u}=i,{svg:g,win:f}=s,{seriesTypes:m}=a,{arrayMax:x,arrayMin:y,clamp:b,correctFloat:v,crisp:S,defined:C,destroyObjectProperties:k,diffObjects:M,erase:w,error:T,extend:A,find:P,fireEvent:L,getClosestDistance:O,getNestedProperty:D,insertItem:E,isArray:I,isNumber:j,isString:B,merge:R,objectEach:z,pick:N,removeEvent:W,splat:G,syncTimeout:H}=l;class X{constructor(){this.zoneAxis="y";}init(t,e){let i;L(this,"init",{options:e});let s=this,r=t.series;this.eventsToUnbind=[],s.chart=t,s.options=s.setOptions(e);let o=s.options,n=!1!==o.visible;s.linkedSeries=[],s.bindAxes(),A(s,{name:o.name,state:"",visible:n,selected:!0===o.selected}),u(this,o);let a=o.events;(a&&a.click||o.point&&o.point.events&&o.point.events.click||o.allowPointSelect)&&(t.runTrackerClick=!0),s.getColor(),s.getSymbol(),s.parallelArrays.forEach(function(t){s[t+"Data"]||(s[t+"Data"]=[]);}),s.isCartesian&&(t.hasCartesianSeries=!0),r.length&&(i=r[r.length-1]),s._i=N(i&&i._i,-1)+1,s.opacity=s.options.opacity,t.orderItems("series",E(this,r)),o.dataSorting&&o.dataSorting.enabled?s.setDataSortingOptions():s.points||s.data||s.setData(o.data,!1),L(this,"afterInit");}is(t){return m[t]&&this instanceof m[t]}bindAxes(){let t;let e=this,i=e.options,s=e.chart;L(this,"bindAxes",null,function(){(e.axisTypes||[]).forEach(function(r){(s[r]||[]).forEach(function(s){t=s.options,(N(i[r],0)===s.index||void 0!==i[r]&&i[r]===t.id)&&(E(e,s.series),e[r]=s,s.isDirty=!0);}),e[r]||e.optionalAxis===r||T(18,!0,s);});}),L(this,"afterBindAxes");}updateParallelArrays(t,e,i){let s=t.series,r=j(e)?function(i){let r="y"===i&&s.toYData?s.toYData(t):t[i];s[i+"Data"][e]=r;}:function(t){Array.prototype[e].apply(s[t+"Data"],i);};s.parallelArrays.forEach(r);}hasData(){return this.visible&&void 0!==this.dataMax&&void 0!==this.dataMin||this.visible&&this.yData&&this.yData.length>0}hasMarkerChanged(t,e){let i=t.marker,s=e.marker||{};return i&&(s.enabled&&!i.enabled||s.symbol!==i.symbol||s.height!==i.height||s.width!==i.width)}autoIncrement(t){let e=this.options,i=e.pointIntervalUnit,s=e.relativeXValue,r=this.chart.time,o=this.xIncrement,n,a;return (o=N(o,e.pointStart,0),this.pointInterval=a=N(this.pointInterval,e.pointInterval,1),s&&j(t)&&(a*=t),i&&(n=new r.Date(o),"day"===i?r.set("Date",n,r.get("Date",n)+a):"month"===i?r.set("Month",n,r.get("Month",n)+a):"year"===i&&r.set("FullYear",n,r.get("FullYear",n)+a),a=n.getTime()-o),s&&j(t))?o+a:(this.xIncrement=o+a,o)}setDataSortingOptions(){let t=this.options;A(this,{requireSorting:!1,sorted:!1,enabledDataSorting:!0,allowDG:!1}),C(t.pointRange)||(t.pointRange=1);}setOptions(t){let e;let i=this.chart,s=i.options.plotOptions,r=i.userOptions||{},o=R(t),n=i.styledMode,a={plotOptions:s,userOptions:o};L(this,"setOptions",a);let h=a.plotOptions[this.type],l=r.plotOptions||{},d=l.series||{},c=p.plotOptions[this.type]||{},u=l[this.type]||{};this.userOptions=a.userOptions;let g=R(h,s.series,u,o);this.tooltipOptions=R(p.tooltip,p.plotOptions.series?.tooltip,c?.tooltip,i.userOptions.tooltip,l.series?.tooltip,u.tooltip,o.tooltip),this.stickyTracking=N(o.stickyTracking,u.stickyTracking,d.stickyTracking,!!this.tooltipOptions.shared&&!this.noSharedTooltip||g.stickyTracking),null===h.marker&&delete g.marker,this.zoneAxis=g.zoneAxis||"y";let f=this.zones=(g.zones||[]).map(t=>({...t}));return (g.negativeColor||g.negativeFillColor)&&!g.zones&&(e={value:g[this.zoneAxis+"Threshold"]||g.threshold||0,className:"highcharts-negative"},n||(e.color=g.negativeColor,e.fillColor=g.negativeFillColor),f.push(e)),f.length&&C(f[f.length-1].value)&&f.push(n?{}:{color:this.color,fillColor:this.fillColor}),L(this,"afterSetOptions",{options:g}),g}getName(){return N(this.options.name,"Series "+(this.index+1))}getCyclic(t,e,i){let s,r;let o=this.chart,n=`${t}Index`,a=`${t}Counter`,h=i?.length||o.options.chart.colorCount;!e&&(C(r=N("color"===t?this.options.colorIndex:void 0,this[n]))?s=r:(o.series.length||(o[a]=0),s=o[a]%h,o[a]+=1),i&&(e=i[s])),void 0!==s&&(this[n]=s),this[t]=e;}getColor(){this.chart.styledMode?this.getCyclic("color"):this.options.colorByPoint?this.color="#cccccc":this.getCyclic("color",this.options.color||p.plotOptions[this.type].color,this.chart.options.colors);}getPointsCollection(){return (this.hasGroupedData?this.points:this.data)||[]}getSymbol(){let t=this.options.marker;this.getCyclic("symbol",t.symbol,this.chart.options.symbols);}findPointIndex(t,e){let i,s,r;let n=t.id,a=t.x,h=this.points,l=this.options.dataSorting;if(n){let t=this.chart.get(n);t instanceof o&&(i=t);}else if(this.linkedParent||this.enabledDataSorting||this.options.relativeXValue){let e=e=>!e.touched&&e.index===t.index;if(l&&l.matchByName?e=e=>!e.touched&&e.name===t.name:this.options.relativeXValue&&(e=e=>!e.touched&&e.options.x===t.x),!(i=P(h,e)))return}return i&&void 0!==(r=i&&i.index)&&(s=!0),void 0===r&&j(a)&&(r=this.xData.indexOf(a,e)),-1!==r&&void 0!==r&&this.cropped&&(r=r>=this.cropStart?r-this.cropStart:r),!s&&j(r)&&h[r]&&h[r].touched&&(r=void 0),r}updateData(t,e){let i=this.options,s=i.dataSorting,r=this.points,o=[],n=this.requireSorting,a=t.length===r.length,h,l,d,c,p=!0;if(this.xIncrement=null,t.forEach(function(t,e){let l;let d=C(t)&&this.pointClass.prototype.optionsToObject.call({series:this},t)||{},p=d.x;d.id||j(p)?(-1===(l=this.findPointIndex(d,c))||void 0===l?o.push(t):r[l]&&t!==i.data[l]?(r[l].update(t,!1,null,!1),r[l].touched=!0,n&&(c=l+1)):r[l]&&(r[l].touched=!0),(!a||e!==l||s&&s.enabled||this.hasDerivedData)&&(h=!0)):o.push(t);},this),h)for(l=r.length;l--;)(d=r[l])&&!d.touched&&d.remove&&d.remove(!1,e);else !a||s&&s.enabled?p=!1:(t.forEach(function(t,e){t===r[e].y||r[e].destroyed||r[e].update(t,!1,null,!1);}),o.length=0);return r.forEach(function(t){t&&(t.touched=!1);}),!!p&&(o.forEach(function(t){this.addPoint(t,!1,null,null,!1);},this),null===this.xIncrement&&this.xData&&this.xData.length&&(this.xIncrement=x(this.xData),this.autoIncrement()),!0)}setData(t,e=!0,i,s){let r=this,o=r.points,n=o&&o.length||0,a=r.options,h=r.chart,l=a.dataSorting,d=r.xAxis,c=a.turboThreshold,p=this.xData,u=this.yData,g=r.pointArrayMap,f=g&&g.length,m=a.keys,x,y,b,v=0,S=1,C;h.options.chart.allowMutatingData||(a.data&&delete r.options.data,r.userOptions.data&&delete r.userOptions.data,C=R(!0,t));let k=(t=C||t||[]).length;if(l&&l.enabled&&(t=this.sortData(t)),h.options.chart.allowMutatingData&&!1!==s&&k&&n&&!r.cropped&&!r.hasGroupedData&&r.visible&&!r.boosted&&(b=this.updateData(t,i)),!b){r.xIncrement=null,r.colorCounter=0,this.parallelArrays.forEach(function(t){r[t+"Data"].length=0;});let e=c&&k>c;if(e){let i=r.getFirstValidPoint(t),s=r.getFirstValidPoint(t,k-1,-1),o=t=>!!(I(t)&&(m||j(t[0])));if(j(i)&&j(s))for(x=0;x<k;x++)p[x]=this.autoIncrement(),u[x]=t[x];else if(o(i)&&o(s)){if(f){if(i.length===f)for(x=0;x<k;x++)p[x]=this.autoIncrement(),u[x]=t[x];else for(x=0;x<k;x++)y=t[x],p[x]=y[0],u[x]=y.slice(1,f+1);}else if(m&&(v=m.indexOf("x"),S=m.indexOf("y"),v=v>=0?v:0,S=S>=0?S:1),1===i.length&&(S=0),v===S)for(x=0;x<k;x++)p[x]=this.autoIncrement(),u[x]=t[x][S];else for(x=0;x<k;x++)y=t[x],p[x]=y[v],u[x]=y[S];}else e=!1;}if(!e)for(x=0;x<k;x++)y={series:r},r.pointClass.prototype.applyOptions.apply(y,[t[x]]),r.updateParallelArrays(y,x);for(u&&B(u[0])&&T(14,!0,h),r.data=[],r.options.data=r.userOptions.data=t,x=n;x--;)o[x]?.destroy();d&&(d.minRange=d.userMinRange),r.isDirty=h.isDirtyBox=!0,r.isDirtyData=!!o,i=!1;}"point"===a.legendType&&(this.processData(),this.generatePoints()),e&&h.redraw(i);}sortData(t){let e=this,i=e.options.dataSorting.sortKey||"y",s=function(t,e){return C(e)&&t.pointClass.prototype.optionsToObject.call({series:t},e)||{}};return t.forEach(function(i,r){t[r]=s(e,i),t[r].index=r;},this),t.concat().sort((t,e)=>{let s=D(i,t),r=D(i,e);return r<s?-1:r>s?1:0}).forEach(function(t,e){t.x=e;},this),e.linkedSeries&&e.linkedSeries.forEach(function(e){let i=e.options,r=i.data;i.dataSorting&&i.dataSorting.enabled||!r||(r.forEach(function(i,o){r[o]=s(e,i),t[o]&&(r[o].x=t[o].x,r[o].index=o);}),e.setData(r,!1));}),t}getProcessedData(t){let e=this,i=e.xAxis,s=e.options.cropThreshold,r=i?.logarithmic,o=e.isCartesian,n,a,h=0,l,d,c,p=e.xData,u=e.yData,g=!1,f=p.length;i&&(d=(l=i.getExtremes()).min,c=l.max,g=!!(i.categories&&!i.names.length)),o&&e.sorted&&!t&&(!s||f>s||e.forceCrop)&&(p[f-1]<d||p[0]>c?(p=[],u=[]):e.yData&&(p[0]<d||p[f-1]>c)&&(p=(n=this.cropData(e.xData,e.yData,d,c)).xData,u=n.yData,h=n.start,a=!0));let m=O([r?p.map(r.log2lin):p],()=>e.requireSorting&&!g&&T(15,!1,e.chart));return {xData:p,yData:u,cropped:a,cropStart:h,closestPointRange:m}}processData(t){let e=this.xAxis;if(this.isCartesian&&!this.isDirty&&!e.isDirty&&!this.yAxis.isDirty&&!t)return !1;let i=this.getProcessedData();this.cropped=i.cropped,this.cropStart=i.cropStart,this.processedXData=i.xData,this.processedYData=i.yData,this.closestPointRange=this.basePointRange=i.closestPointRange,L(this,"afterProcessData");}cropData(t,e,i,s){let r=t.length,o,n,a=0,h=r;for(o=0;o<r;o++)if(t[o]>=i){a=Math.max(0,o-1);break}for(n=o;n<r;n++)if(t[n]>s){h=n+1;break}return {xData:t.slice(a,h),yData:e.slice(a,h),start:a,end:h}}generatePoints(){let t=this.options,e=this.processedData||t.data,i=this.processedXData,s=this.processedYData,r=this.pointClass,o=i.length,n=this.cropStart||0,a=this.hasGroupedData,h=t.keys,l=[],d=t.dataGrouping&&t.dataGrouping.groupAll?n:0,c,p,u,g,f=this.data;if(!f&&!a){let t=[];t.length=e.length,f=this.data=t;}for(h&&a&&(this.options.keys=!1),g=0;g<o;g++)p=n+g,a?((u=new r(this,[i[g]].concat(G(s[g])))).dataGroup=this.groupMap[d+g],u.dataGroup.options&&(u.options=u.dataGroup.options,A(u,u.dataGroup.options),delete u.dataLabels)):(u=f[p])||void 0===e[p]||(f[p]=u=new r(this,e[p],i[g])),u&&(u.index=a?d+g:p,l[g]=u);if(this.options.keys=h,f&&(o!==(c=f.length)||a))for(g=0;g<c;g++)g!==n||a||(g+=o),f[g]&&(f[g].destroyElements(),f[g].plotX=void 0);this.data=f,this.points=l,L(this,"afterGeneratePoints");}getXExtremes(t){return {min:y(t),max:x(t)}}getExtremes(t,e){let i=this.xAxis,s=this.yAxis,r=[],o=this.requireSorting&&!this.is("column")?1:0,n=!!s&&s.positiveValuesOnly,a=e||this.getExtremesFromAll||this.options.getExtremesFromAll,{processedXData:h,processedYData:l}=this,d,c,p,u,g,f,m,b=0,v=0,S=0;if(this.cropped&&a){let t=this.getProcessedData(!0);h=t.xData,l=t.yData;}let C=(t=t||this.stackedYData||l||[]).length,k=h||this.xData;for(i&&(b=(d=i.getExtremes()).min,v=d.max),f=0;f<C;f++)if(u=k[f],c=(j(g=t[f])||I(g))&&((j(g)?g>0:g.length)||!n),p=e||this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||!i||(k[f+o]||u)>=b&&(k[f-o]||u)<=v,c&&p){if(m=g.length)for(;m--;)j(g[m])&&(r[S++]=g[m]);else r[S++]=g;}let M={activeYData:r,dataMin:y(r),dataMax:x(r)};return L(this,"afterGetExtremes",{dataExtremes:M}),M}applyExtremes(){let t=this.getExtremes();return this.dataMin=t.dataMin,this.dataMax=t.dataMax,t}getFirstValidPoint(t,e=0,i=1){let s=t.length,r=e;for(;r>=0&&r<s;){if(C(t[r]))return t[r];r+=i;}}translate(){this.processedXData||this.processData(),this.generatePoints();let t=this.options,e=t.stacking,i=this.xAxis,s=i.categories,r=this.enabledDataSorting,o=this.yAxis,n=this.points,a=n.length,h=this.pointPlacementToXValue(),l=!!h,d=t.threshold,c=t.startFromThreshold?d:0,p,u,g,f,m=Number.MAX_VALUE;function x(t){return b(t,-1e9,1e9)}for(p=0;p<a;p++){let t;let a=n[p],y=a.x,b,S,k=a.y,M=a.low,w=e&&o.stacking?.stacks[(this.negStacks&&k<(c?0:d)?"-":"")+this.stackKey];u=i.translate(y,!1,!1,!1,!0,h),a.plotX=j(u)?v(x(u)):void 0,e&&this.visible&&w&&w[y]&&(f=this.getStackIndicator(f,y,this.index),!a.isNull&&f.key&&(S=(b=w[y]).points[f.key]),b&&I(S)&&(M=S[0],k=S[1],M===c&&f.key===w[y].base&&(M=N(j(d)?d:o.min)),o.positiveValuesOnly&&C(M)&&M<=0&&(M=void 0),a.total=a.stackTotal=N(b.total),a.percentage=C(a.y)&&b.total?a.y/b.total*100:void 0,a.stackY=k,this.irregularWidths||b.setOffset(this.pointXOffset||0,this.barW||0,void 0,void 0,void 0,this.xAxis))),a.yBottom=C(M)?x(o.translate(M,!1,!0,!1,!0)):void 0,this.dataModify&&(k=this.dataModify.modifyValue(k,p)),j(k)&&void 0!==a.plotX&&(t=j(t=o.translate(k,!1,!0,!1,!0))?x(t):void 0),a.plotY=t,a.isInside=this.isPointInside(a),a.clientX=l?v(i.translate(y,!1,!1,!1,!0,h)):u,a.negative=(a.y||0)<(d||0),a.category=N(s&&s[a.x],a.x),a.isNull||!1===a.visible||(void 0!==g&&(m=Math.min(m,Math.abs(u-g))),g=u),a.zone=this.zones.length?a.getZone():void 0,!a.graphic&&this.group&&r&&(a.isNew=!0);}this.closestPointRangePx=m,L(this,"afterTranslate");}getValidPoints(t,e,i){let s=this.chart;return (t||this.points||[]).filter(function(t){let{plotX:r,plotY:o}=t;return !!((i||!t.isNull&&j(o))&&(!e||s.isInsidePlot(r,o,{inverted:s.inverted})))&&!1!==t.visible})}getClipBox(){let{chart:t,xAxis:e,yAxis:i}=this,{x:s,y:r,width:o,height:n}=R(t.clipBox);return e&&e.len!==t.plotSizeX&&(o=e.len),i&&i.len!==t.plotSizeY&&(n=i.len),t.inverted&&!this.invertible&&([o,n]=[n,o]),{x:s,y:r,width:o,height:n}}getSharedClipKey(){return this.sharedClipKey=(this.options.xAxis||0)+","+(this.options.yAxis||0),this.sharedClipKey}setClip(){let{chart:t,group:e,markerGroup:i}=this,s=t.sharedClips,r=t.renderer,o=this.getClipBox(),n=this.getSharedClipKey(),a=s[n];a?a.animate(o):s[n]=a=r.clipRect(o),e&&e.clip(!1===this.options.clip?void 0:a),i&&i.clip();}animate(t){let{chart:e,group:i,markerGroup:s}=this,r=e.inverted,o=d(this.options.animation),n=[this.getSharedClipKey(),o.duration,o.easing,o.defer].join(","),a=e.sharedClips[n],h=e.sharedClips[n+"m"];if(t&&i){let t=this.getClipBox();if(a)a.attr("height",t.height);else {t.width=0,r&&(t.x=e.plotHeight),a=e.renderer.clipRect(t),e.sharedClips[n]=a;let i={x:-99,y:-99,width:r?e.plotWidth+199:99,height:r?99:e.plotHeight+199};h=e.renderer.clipRect(i),e.sharedClips[n+"m"]=h;}i.clip(a),s?.clip(h);}else if(a&&!a.hasClass("highcharts-animating")){let t=this.getClipBox(),i=o.step;(s?.element.childNodes.length||e.series.length>1)&&(o.step=function(t,e){i&&i.apply(e,arguments),"width"===e.prop&&h?.element&&h.attr(r?"height":"width",t+99);}),a.addClass("highcharts-animating").animate(t,o);}}afterAnimate(){this.setClip(),z(this.chart.sharedClips,(t,e,i)=>{t&&!this.chart.container.querySelector(`[clip-path="url(#${t.id})"]`)&&(t.destroy(),delete i[e]);}),this.finishedAnimating=!0,L(this,"afterAnimate");}drawPoints(t=this.points){let e,i,s,r,o,n,a;let h=this.chart,l=h.styledMode,{colorAxis:d,options:c}=this,p=c.marker,u=this[this.specialGroup||"markerGroup"],g=this.xAxis,f=N(p.enabled,!g||!!g.isRadial||null,this.closestPointRangePx>=p.enabledThreshold*p.radius);if(!1!==p.enabled||this._hasPointMarkers)for(e=0;e<t.length;e++)if(r=(s=(i=t[e]).graphic)?"animate":"attr",o=i.marker||{},n=!!i.marker,(f&&void 0===o.enabled||o.enabled)&&!i.isNull&&!1!==i.visible){let t=N(o.symbol,this.symbol,"rect");a=this.markerAttribs(i,i.selected&&"select"),this.enabledDataSorting&&(i.startXPos=g.reversed?-(a.width||0):g.width);let e=!1!==i.isInside;if(!s&&e&&((a.width||0)>0||i.hasImage)&&(i.graphic=s=h.renderer.symbol(t,a.x,a.y,a.width,a.height,n?o:p).add(u),this.enabledDataSorting&&h.hasRendered&&(s.attr({x:i.startXPos}),r="animate")),s&&"animate"===r&&s[e?"show":"hide"](e).animate(a),s){let t=this.pointAttribs(i,l||!i.selected?void 0:"select");l?d&&s.css({fill:t.fill}):s[r](t);}s&&s.addClass(i.getClassName(),!0);}else s&&(i.graphic=s.destroy());}markerAttribs(t,e){let i=this.options,s=i.marker,r=t.marker||{},o=r.symbol||s.symbol,n={},a,h,l=N(r.radius,s&&s.radius);e&&(a=s.states[e],l=N((h=r.states&&r.states[e])&&h.radius,a&&a.radius,l&&l+(a&&a.radiusPlus||0))),t.hasImage=o&&0===o.indexOf("url"),t.hasImage&&(l=0);let d=t.pos();return j(l)&&d&&(i.crisp&&(d[0]=S(d[0],t.hasImage?0:"rect"===o?s?.lineWidth||0:1)),n.x=d[0]-l,n.y=d[1]-l),l&&(n.width=n.height=2*l),n}pointAttribs(t,e){let i=this.options.marker,s=t&&t.options,r=s&&s.marker||{},o=s&&s.color,n=t&&t.color,a=t&&t.zone&&t.zone.color,h,l,d=this.color,c,p,u=N(r.lineWidth,i.lineWidth),g=1;return d=o||a||n||d,c=r.fillColor||i.fillColor||d,p=r.lineColor||i.lineColor||d,e=e||"normal",h=i.states[e]||{},u=N((l=r.states&&r.states[e]||{}).lineWidth,h.lineWidth,u+N(l.lineWidthPlus,h.lineWidthPlus,0)),c=l.fillColor||h.fillColor||c,{stroke:p=l.lineColor||h.lineColor||p,"stroke-width":u,fill:c,opacity:g=N(l.opacity,h.opacity,g)}}destroy(t){let e,i,s;let r=this,o=r.chart,n=/AppleWebKit\/533/.test(f.navigator.userAgent),a=r.data||[];for(L(r,"destroy",{keepEventsForUpdate:t}),this.removeEvents(t),(r.axisTypes||[]).forEach(function(t){(s=r[t])&&s.series&&(w(s.series,r),s.isDirty=s.forceRedraw=!0);}),r.legendItem&&r.chart.legend.destroyItem(r),e=a.length;e--;)(i=a[e])&&i.destroy&&i.destroy();for(let t of r.zones)k(t,void 0,!0);l.clearTimeout(r.animationTimeout),z(r,function(t,e){t instanceof h&&!t.survive&&t[n&&"group"===e?"hide":"destroy"]();}),o.hoverSeries===r&&(o.hoverSeries=void 0),w(o.series,r),o.orderItems("series"),z(r,function(e,i){t&&"hcEvents"===i||delete r[i];});}applyZones(){let{area:t,chart:e,graph:i,zones:s,points:r,xAxis:o,yAxis:n,zoneAxis:a}=this,{inverted:h,renderer:l}=e,d=this[`${a}Axis`],{isXAxis:c,len:p=0}=d||{},u=(i?.strokeWidth()||0)/2+1,g=(t,e=0,i=0)=>{h&&(i=p-i);let{translated:s=0,lineClip:r}=t,o=i-s;r?.push(["L",e,Math.abs(o)<u?i-u*(o<=0?-1:1):s]);};if(s.length&&(i||t)&&d&&j(d.min)){let e=d.getExtremes().max,u=t=>{t.forEach((e,i)=>{("M"===e[0]||"L"===e[0])&&(t[i]=[e[0],c?p-e[1]:e[1],c?e[2]:p-e[2]]);});};if(s.forEach(t=>{t.lineClip=[],t.translated=b(d.toPixels(N(t.value,e),!0)||0,0,p);}),i&&!this.showLine&&i.hide(),t&&t.hide(),"y"===a&&r.length<o.len)for(let t of r){let{plotX:e,plotY:i,zone:r}=t,o=r&&s[s.indexOf(r)-1];r&&g(r,e,i),o&&g(o,e,i);}let f=[],m=d.toPixels(d.getExtremes().min,!0);s.forEach(e=>{let s=e.lineClip||[],r=Math.round(e.translated||0);o.reversed&&s.reverse();let{clip:a,simpleClip:d}=e,p=0,g=0,x=o.len,y=n.len;c?(p=r,x=m):(g=r,y=m);let b=[["M",p,g],["L",x,g],["L",x,y],["L",p,y],["Z"]],v=[b[0],...s,b[1],b[2],...f,b[3],b[4]];f=s.reverse(),m=r,h&&(u(v),t&&u(b)),a?(a.animate({d:v}),d?.animate({d:b})):(a=e.clip=l.path(v),t&&(d=e.simpleClip=l.path(b))),i&&e.graph?.clip(a),t&&e.area?.clip(d);});}else this.visible&&(i&&i.show(),t&&t.show());}plotGroup(t,e,i,s,r){let o=this[t],n=!o,a={visibility:i,zIndex:s||.1};return C(this.opacity)&&!this.chart.styledMode&&"inactive"!==this.state&&(a.opacity=this.opacity),o||(this[t]=o=this.chart.renderer.g().add(r)),o.addClass("highcharts-"+e+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(C(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":"")+(this.options.className||"")+(o.hasClass("highcharts-tracker")?" highcharts-tracker":""),!0),o.attr(a)[n?"attr":"animate"](this.getPlotBox(e)),o}getPlotBox(t){let e=this.xAxis,i=this.yAxis,s=this.chart,r=s.inverted&&!s.polar&&e&&this.invertible&&"series"===t;return s.inverted&&(e=i,i=this.xAxis),{translateX:e?e.left:s.plotLeft,translateY:i?i.top:s.plotTop,rotation:r?90:0,rotationOriginX:r?(e.len-i.len)/2:0,rotationOriginY:r?(e.len+i.len)/2:0,scaleX:r?-1:1,scaleY:1}}removeEvents(t){let{eventsToUnbind:e}=this;t||W(this),e.length&&(e.forEach(t=>{t();}),e.length=0);}render(){let t=this,{chart:e,options:i,hasRendered:s}=t,r=d(i.animation),o=t.visible?"inherit":"hidden",n=i.zIndex,a=e.seriesGroup,h=t.finishedAnimating?0:r.duration;L(this,"render"),t.plotGroup("group","series",o,n,a),t.markerGroup=t.plotGroup("markerGroup","markers",o,n,a),!1!==i.clip&&t.setClip(),h&&t.animate?.(!0),t.drawGraph&&(t.drawGraph(),t.applyZones()),t.visible&&t.drawPoints(),t.drawDataLabels?.(),t.redrawPoints?.(),i.enableMouseTracking&&t.drawTracker?.(),h&&t.animate?.(),s||(h&&r.defer&&(h+=r.defer),t.animationTimeout=H(()=>{t.afterAnimate();},h||0)),t.isDirty=!1,t.hasRendered=!0,L(t,"afterRender");}redraw(){let t=this.isDirty||this.isDirtyData;this.translate(),this.render(),t&&delete this.kdTree;}reserveSpace(){return this.visible||!this.chart.options.chart.ignoreHiddenSeries}searchPoint(t,e){let{xAxis:i,yAxis:s}=this,r=this.chart.inverted;return this.searchKDTree({clientX:r?i.len-t.chartY+i.pos:t.chartX-i.pos,plotY:r?s.len-t.chartX+s.pos:t.chartY-s.pos},e,t)}buildKDTree(t){this.buildingKdTree=!0;let e=this,i=e.options.findNearestPointBy.indexOf("y")>-1?2:1;delete e.kdTree,H(function(){e.kdTree=function t(i,s,r){let o,n;let a=i?.length;if(a)return o=e.kdAxisArray[s%r],i.sort((t,e)=>(t[o]||0)-(e[o]||0)),{point:i[n=Math.floor(a/2)],left:t(i.slice(0,n),s+1,r),right:t(i.slice(n+1),s+1,r)}}(e.getValidPoints(void 0,!e.directTouch),i,i),e.buildingKdTree=!1;},e.options.kdNow||t?.type==="touchstart"?0:1);}searchKDTree(t,e,i){let s=this,[r,o]=this.kdAxisArray,n=e?"distX":"dist",a=(s.options.findNearestPointBy||"").indexOf("y")>-1?2:1,h=!!s.isBubble;if(this.kdTree||this.buildingKdTree||this.buildKDTree(i),this.kdTree)return function t(e,i,a,l){let d=i.point,c=s.kdAxisArray[a%l],p,u,g=d;!function(t,e){let i=t[r],s=e[r],n=C(i)&&C(s)?i-s:null,a=t[o],l=e[o],d=C(a)&&C(l)?a-l:0,c=h&&e.marker?.radius||0;e.dist=Math.sqrt((n&&n*n||0)+d*d)-c,e.distX=C(n)?Math.abs(n)-c:Number.MAX_VALUE;}(e,d);let f=(e[c]||0)-(d[c]||0)+(h&&d.marker?.radius||0),m=f<0?"left":"right",x=f<0?"right":"left";return i[m]&&(g=(p=t(e,i[m],a+1,l))[n]<g[n]?p:d),i[x]&&Math.sqrt(f*f)<g[n]&&(g=(u=t(e,i[x],a+1,l))[n]<g[n]?u:g),g}(t,this.kdTree,a,a)}pointPlacementToXValue(){let{options:t,xAxis:e}=this,i=t.pointPlacement;return "between"===i&&(i=e.reversed?-.5:.5),j(i)?i*(t.pointRange||e.pointRange):0}isPointInside(t){let{chart:e,xAxis:i,yAxis:s}=this,{plotX:r=-1,plotY:o=-1}=t;return o>=0&&o<=(s?s.len:e.plotHeight)&&r>=0&&r<=(i?i.len:e.plotWidth)}drawTracker(){let t=this,e=t.options,i=e.trackByArea,s=[].concat((i?t.areaPath:t.graphPath)||[]),r=t.chart,o=r.pointer,n=r.renderer,a=r.options.tooltip?.snap||0,h=()=>{e.enableMouseTracking&&r.hoverSeries!==t&&t.onMouseOver();},l="rgba(192,192,192,"+(g?1e-4:.002)+")",d=t.tracker;d?d.attr({d:s}):t.graph&&(t.tracker=d=n.path(s).attr({visibility:t.visible?"inherit":"hidden",zIndex:2}).addClass(i?"highcharts-tracker-area":"highcharts-tracker-line").add(t.group),r.styledMode||d.attr({"stroke-linecap":"round","stroke-linejoin":"round",stroke:l,fill:i?l:"none","stroke-width":t.graph.strokeWidth()+(i?0:2*a)}),[t.tracker,t.markerGroup,t.dataLabelsGroup].forEach(t=>{t&&(t.addClass("highcharts-tracker").on("mouseover",h).on("mouseout",t=>{o?.onTrackerMouseOut(t);}),e.cursor&&!r.styledMode&&t.css({cursor:e.cursor}),t.on("touchstart",h));})),L(this,"afterDrawTracker");}addPoint(t,e,i,s,r){let o,n;let a=this.options,h=this.data,l=this.chart,d=this.xAxis,c=d&&d.hasNames&&d.names,p=a.data,u=this.xData;e=N(e,!0);let g={series:this};this.pointClass.prototype.applyOptions.apply(g,[t]);let f=g.x;if(n=u.length,this.requireSorting&&f<u[n-1])for(o=!0;n&&u[n-1]>f;)n--;this.updateParallelArrays(g,"splice",[n,0,0]),this.updateParallelArrays(g,n),c&&g.name&&(c[f]=g.name),p.splice(n,0,t),(o||this.processedData)&&(this.data.splice(n,0,null),this.processData()),"point"===a.legendType&&this.generatePoints(),i&&(h[0]&&h[0].remove?h[0].remove(!1):(h.shift(),this.updateParallelArrays(g,"shift"),p.shift())),!1!==r&&L(this,"addPoint",{point:g}),this.isDirty=!0,this.isDirtyData=!0,e&&l.redraw(s);}removePoint(t,e,i){let s=this,r=s.data,o=r[t],n=s.points,a=s.chart,h=function(){n&&n.length===r.length&&n.splice(t,1),r.splice(t,1),s.options.data.splice(t,1),s.updateParallelArrays(o||{series:s},"splice",[t,1]),o&&o.destroy(),s.isDirty=!0,s.isDirtyData=!0,e&&a.redraw();};c(i,a),e=N(e,!0),o?o.firePointEvent("remove",null,h):h();}remove(t,e,i,s){let r=this,o=r.chart;function n(){r.destroy(s),o.isDirtyLegend=o.isDirtyBox=!0,o.linkSeries(s),N(t,!0)&&o.redraw(e);}!1!==i?L(r,"remove",null,n):n();}update(t,e){L(this,"update",{options:t=M(t,this.userOptions)});let i=this,s=i.chart,r=i.userOptions,o=i.initialType||i.type,n=s.options.plotOptions,a=m[o].prototype,h=i.finishedAnimating&&{animation:!1},l={},d,c,p=["colorIndex","eventOptions","navigatorSeries","symbolIndex","baseSeries"],u=t.type||r.type||s.options.chart.type,g=!(this.hasDerivedData||u&&u!==this.type||void 0!==t.pointStart||void 0!==t.pointInterval||void 0!==t.relativeXValue||t.joinBy||t.mapData||["dataGrouping","pointStart","pointInterval","pointIntervalUnit","keys"].some(t=>i.hasOptionChanged(t)));u=u||o,g&&(p.push("data","isDirtyData","isDirtyCanvas","points","processedData","processedXData","processedYData","xIncrement","cropped","_hasPointMarkers","hasDataLabels","nodes","layout","level","mapMap","mapData","minY","maxY","minX","maxX","transformGroups"),!1!==t.visible&&p.push("area","graph"),i.parallelArrays.forEach(function(t){p.push(t+"Data");}),t.data&&(t.dataSorting&&A(i.options.dataSorting,t.dataSorting),this.setData(t.data,!1))),t=R(r,{index:void 0===r.index?i.index:r.index,pointStart:n?.series?.pointStart??r.pointStart??i.xData?.[0]},!g&&{data:i.options.data},t,h),g&&t.data&&(t.data=i.options.data),(p=["group","markerGroup","dataLabelsGroup","transformGroup"].concat(p)).forEach(function(t){p[t]=i[t],delete i[t];});let f=!1;if(m[u]){if(f=u!==i.type,i.remove(!1,!1,!1,!0),f){if(s.propFromSeries(),Object.setPrototypeOf)Object.setPrototypeOf(i,m[u].prototype);else {let t=Object.hasOwnProperty.call(i,"hcEvents")&&i.hcEvents;for(c in a)i[c]=void 0;A(i,m[u].prototype),t?i.hcEvents=t:delete i.hcEvents;}}}else T(17,!0,s,{missingModuleFor:u});if(p.forEach(function(t){i[t]=p[t];}),i.init(s,t),g&&this.points)for(let t of(!1===(d=i.options).visible?(l.graphic=1,l.dataLabel=1):(this.hasMarkerChanged(d,r)&&(l.graphic=1),i.hasDataLabels?.()||(l.dataLabel=1)),this.points))t&&t.series&&(t.resolveColor(),Object.keys(l).length&&t.destroyElements(l),!1===d.showInLegend&&t.legendItem&&s.legend.destroyItem(t));i.initialType=o,s.linkSeries(),s.setSortedData(),f&&i.linkedSeries.length&&(i.isDirtyData=!0),L(this,"afterUpdate"),N(e,!0)&&s.redraw(!!g&&void 0);}setName(t){this.name=this.options.name=this.userOptions.name=t,this.chart.isDirtyLegend=!0;}hasOptionChanged(t){let e=this.chart,i=this.options[t],s=e.options.plotOptions,r=this.userOptions[t],o=N(s?.[this.type]?.[t],s?.series?.[t]);return r&&!C(o)?i!==r:i!==N(o,i)}onMouseOver(){let t=this.chart,e=t.hoverSeries,i=t.pointer;i?.setHoverChartIndex(),e&&e!==this&&e.onMouseOut(),this.options.events.mouseOver&&L(this,"mouseOver"),this.setState("hover"),t.hoverSeries=this;}onMouseOut(){let t=this.options,e=this.chart,i=e.tooltip,s=e.hoverPoint;e.hoverSeries=null,s&&s.onMouseOut(),this&&t.events.mouseOut&&L(this,"mouseOut"),i&&!this.stickyTracking&&(!i.shared||this.noSharedTooltip)&&i.hide(),e.series.forEach(function(t){t.setState("",!0);});}setState(t,e){let i=this,s=i.options,r=i.graph,o=s.inactiveOtherPoints,n=s.states,a=N(n[t||"normal"]&&n[t||"normal"].animation,i.chart.options.chart.animation),h=s.lineWidth,l=s.opacity;if(t=t||"",i.state!==t&&([i.group,i.markerGroup,i.dataLabelsGroup].forEach(function(e){e&&(i.state&&e.removeClass("highcharts-series-"+i.state),t&&e.addClass("highcharts-series-"+t));}),i.state=t,!i.chart.styledMode)){if(n[t]&&!1===n[t].enabled)return;if(t&&(h=n[t].lineWidth||h+(n[t].lineWidthPlus||0),l=N(n[t].opacity,l)),r&&!r.dashstyle&&j(h))for(let t of [r,...this.zones.map(t=>t.graph)])t?.animate({"stroke-width":h},a);o||[i.group,i.markerGroup,i.dataLabelsGroup,i.labelBySeries].forEach(function(t){t&&t.animate({opacity:l},a);});}e&&o&&i.points&&i.setAllPointsToState(t||void 0);}setAllPointsToState(t){this.points.forEach(function(e){e.setState&&e.setState(t);});}setVisible(t,e){let i=this,s=i.chart,r=s.options.chart.ignoreHiddenSeries,o=i.visible;i.visible=t=i.options.visible=i.userOptions.visible=void 0===t?!o:t;let n=t?"show":"hide";["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(t=>{i[t]?.[n]();}),(s.hoverSeries===i||s.hoverPoint?.series===i)&&i.onMouseOut(),i.legendItem&&s.legend.colorizeItem(i,t),i.isDirty=!0,i.options.stacking&&s.series.forEach(t=>{t.options.stacking&&t.visible&&(t.isDirty=!0);}),i.linkedSeries.forEach(e=>{e.setVisible(t,!1);}),r&&(s.isDirtyBox=!0),L(i,n),!1!==e&&s.redraw();}show(){this.setVisible(!0);}hide(){this.setVisible(!1);}select(t){this.selected=t=this.options.selected=void 0===t?!this.selected:t,this.checkbox&&(this.checkbox.checked=t),L(this,t?"select":"unselect");}shouldShowTooltip(t,e,i={}){return i.series=this,i.visiblePlotOnly=!0,this.chart.isInsidePlot(t,e,i)}drawLegendSymbol(t,e){r[this.options.legendSymbol||"rectangle"]?.call(this,t,e);}}return X.defaultOptions=n,X.types=a.seriesTypes,X.registerType=a.registerSeriesType,A(X.prototype,{axisTypes:["xAxis","yAxis"],coll:"series",colorCounter:0,directTouch:!1,invertible:!0,isCartesian:!0,kdAxisArray:["clientX","plotY"],parallelArrays:["x","y"],pointClass:o,requireSorting:!0,sorted:!0}),a.series=X,X}),i(e,"Core/Legend/Legend.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Foundation.js"],e["Core/Globals.js"],e["Core/Series/Series.js"],e["Core/Series/Point.js"],e["Core/Renderer/RendererUtilities.js"],e["Core/Templating.js"],e["Core/Utilities.js"]],function(t,e,i,s,r,o,n,a){var h;let{animObject:l,setAnimation:d}=t,{registerEventOptions:c}=e,{composed:p,marginNames:u}=i,{distribute:g}=o,{format:f}=n,{addEvent:m,createElement:x,css:y,defined:b,discardElement:v,find:S,fireEvent:C,isNumber:k,merge:M,pick:w,pushUnique:T,relativeLength:A,stableSort:P,syncTimeout:L}=a;class O{constructor(t,e){this.allItems=[],this.initialItemY=0,this.itemHeight=0,this.itemMarginBottom=0,this.itemMarginTop=0,this.itemX=0,this.itemY=0,this.lastItemY=0,this.lastLineHeight=0,this.legendHeight=0,this.legendWidth=0,this.maxItemWidth=0,this.maxLegendWidth=0,this.offsetWidth=0,this.padding=0,this.pages=[],this.symbolHeight=0,this.symbolWidth=0,this.titleHeight=0,this.totalItemWidth=0,this.widthOption=0,this.chart=t,this.setOptions(e),e.enabled&&(this.render(),c(this,e),m(this.chart,"endResize",function(){this.legend.positionCheckboxes();})),m(this.chart,"render",()=>{this.options.enabled&&this.proximate&&(this.proximatePositions(),this.positionItems());});}setOptions(t){let e=w(t.padding,8);this.options=t,this.chart.styledMode||(this.itemStyle=t.itemStyle,this.itemHiddenStyle=M(this.itemStyle,t.itemHiddenStyle)),this.itemMarginTop=t.itemMarginTop,this.itemMarginBottom=t.itemMarginBottom,this.padding=e,this.initialItemY=e-5,this.symbolWidth=w(t.symbolWidth,16),this.pages=[],this.proximate="proximate"===t.layout&&!this.chart.inverted,this.baseline=void 0;}update(t,e){let i=this.chart;this.setOptions(M(!0,this.options,t)),"events"in this.options&&c(this,this.options),this.destroy(),i.isDirtyLegend=i.isDirtyBox=!0,w(e,!0)&&i.redraw(),C(this,"afterUpdate",{redraw:e});}colorizeItem(t,e){let{area:i,group:s,label:r,line:o,symbol:n}=t.legendItem||{};if(s?.[e?"removeClass":"addClass"]("highcharts-legend-item-hidden"),!this.chart.styledMode){let{itemHiddenStyle:s={}}=this,a=s.color,{fillColor:h,fillOpacity:l,lineColor:d,marker:c}=t.options,p=t=>(!e&&(t.fill&&(t.fill=a),t.stroke&&(t.stroke=a)),t);r?.css(M(e?this.itemStyle:s)),o?.attr(p({stroke:d||t.color})),n&&n.attr(p(c&&n.isMarker?t.pointAttribs():{fill:t.color})),i?.attr(p({fill:h||t.color,"fill-opacity":h?1:l??.75}));}C(this,"afterColorizeItem",{item:t,visible:e});}positionItems(){this.allItems.forEach(this.positionItem,this),this.chart.isResizing||this.positionCheckboxes();}positionItem(t){let{group:e,x:i=0,y:s=0}=t.legendItem||{},r=this.options,o=r.symbolPadding,n=!r.rtl,a=t.checkbox;if(e&&e.element){let r={translateX:n?i:this.legendWidth-i-2*o-4,translateY:s};e[b(e.translateY)?"animate":"attr"](r,void 0,()=>{C(this,"afterPositionItem",{item:t});});}a&&(a.x=i,a.y=s);}destroyItem(t){let e=t.checkbox,i=t.legendItem||{};for(let t of ["group","label","line","symbol"])i[t]&&(i[t]=i[t].destroy());e&&v(e),t.legendItem=void 0;}destroy(){for(let t of this.getAllItems())this.destroyItem(t);for(let t of ["clipRect","up","down","pager","nav","box","title","group"])this[t]&&(this[t]=this[t].destroy());this.display=null;}positionCheckboxes(){let t;let e=this.group&&this.group.alignAttr,i=this.clipHeight||this.legendHeight,s=this.titleHeight;e&&(t=e.translateY,this.allItems.forEach(function(r){let o;let n=r.checkbox;n&&(o=t+s+n.y+(this.scrollOffset||0)+3,y(n,{left:e.translateX+r.checkboxOffset+n.x-20+"px",top:o+"px",display:this.proximate||o>t-6&&o<t+i-6?"":"none"}));},this));}renderTitle(){let t=this.options,e=this.padding,i=t.title,s,r=0;i.text&&(this.title||(this.title=this.chart.renderer.label(i.text,e-3,e-4,void 0,void 0,void 0,t.useHTML,void 0,"legend-title").attr({zIndex:1}),this.chart.styledMode||this.title.css(i.style),this.title.add(this.group)),i.width||this.title.css({width:this.maxLegendWidth+"px"}),r=(s=this.title.getBBox()).height,this.offsetWidth=s.width,this.contentGroup.attr({translateY:r})),this.titleHeight=r;}setText(t){let e=this.options;t.legendItem.label.attr({text:e.labelFormat?f(e.labelFormat,t,this.chart):e.labelFormatter.call(t)});}renderItem(t){let e=t.legendItem=t.legendItem||{},i=this.chart,s=i.renderer,r=this.options,o="horizontal"===r.layout,n=this.symbolWidth,a=r.symbolPadding||0,h=this.itemStyle,l=this.itemHiddenStyle,d=o?w(r.itemDistance,20):0,c=!r.rtl,p=!t.series,u=!p&&t.series.drawLegendSymbol?t.series:t,g=u.options,f=!!this.createCheckboxForItem&&g&&g.showCheckbox,m=r.useHTML,x=t.options.className,y=e.label,b=n+a+d+(f?20:0);!y&&(e.group=s.g("legend-item").addClass("highcharts-"+u.type+"-series highcharts-color-"+t.colorIndex+(x?" "+x:"")+(p?" highcharts-series-"+t.index:"")).attr({zIndex:1}).add(this.scrollGroup),e.label=y=s.text("",c?n+a:-a,this.baseline||0,m),i.styledMode||y.css(M(t.visible?h:l)),y.attr({align:c?"left":"right",zIndex:2}).add(e.group),!this.baseline&&(this.fontMetrics=s.fontMetrics(y),this.baseline=this.fontMetrics.f+3+this.itemMarginTop,y.attr("y",this.baseline),this.symbolHeight=w(r.symbolHeight,this.fontMetrics.f),r.squareSymbol&&(this.symbolWidth=w(r.symbolWidth,Math.max(this.symbolHeight,16)),b=this.symbolWidth+a+d+(f?20:0),c&&y.attr("x",this.symbolWidth+a))),u.drawLegendSymbol(this,t),this.setItemEvents&&this.setItemEvents(t,y,m)),f&&!t.checkbox&&this.createCheckboxForItem&&this.createCheckboxForItem(t),this.colorizeItem(t,t.visible),(i.styledMode||!h.width)&&y.css({width:(r.itemWidth||this.widthOption||i.spacingBox.width)-b+"px"}),this.setText(t);let v=y.getBBox(),S=this.fontMetrics&&this.fontMetrics.h||0;t.itemWidth=t.checkboxOffset=r.itemWidth||e.labelWidth||v.width+b,this.maxItemWidth=Math.max(this.maxItemWidth,t.itemWidth),this.totalItemWidth+=t.itemWidth,this.itemHeight=t.itemHeight=Math.round(e.labelHeight||(v.height>1.5*S?v.height:S));}layoutItem(t){let e=this.options,i=this.padding,s="horizontal"===e.layout,r=t.itemHeight,o=this.itemMarginBottom,n=this.itemMarginTop,a=s?w(e.itemDistance,20):0,h=this.maxLegendWidth,l=e.alignColumns&&this.totalItemWidth>h?this.maxItemWidth:t.itemWidth,d=t.legendItem||{};s&&this.itemX-i+l>h&&(this.itemX=i,this.lastLineHeight&&(this.itemY+=n+this.lastLineHeight+o),this.lastLineHeight=0),this.lastItemY=n+this.itemY+o,this.lastLineHeight=Math.max(r,this.lastLineHeight),d.x=this.itemX,d.y=this.itemY,s?this.itemX+=l:(this.itemY+=n+r+o,this.lastLineHeight=r),this.offsetWidth=this.widthOption||Math.max((s?this.itemX-i-(t.checkbox?0:a):l)+i,this.offsetWidth);}getAllItems(){let t=[];return this.chart.series.forEach(function(e){let i=e&&e.options;e&&w(i.showInLegend,!b(i.linkedTo)&&void 0,!0)&&(t=t.concat((e.legendItem||{}).labels||("point"===i.legendType?e.data:e)));}),C(this,"afterGetAllItems",{allItems:t}),t}getAlignment(){let t=this.options;return this.proximate?t.align.charAt(0)+"tv":t.floating?"":t.align.charAt(0)+t.verticalAlign.charAt(0)+t.layout.charAt(0)}adjustMargins(t,e){let i=this.chart,s=this.options,r=this.getAlignment();r&&[/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/].forEach(function(o,n){o.test(r)&&!b(t[n])&&(i[u[n]]=Math.max(i[u[n]],i.legend[(n+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][n]*s[n%2?"x":"y"]+w(s.margin,12)+e[n]+(i.titleOffset[n]||0)));});}proximatePositions(){let t;let e=this.chart,i=[],s="left"===this.options.align;for(let r of(this.allItems.forEach(function(t){let r,o,n=s,a,h;t.yAxis&&(t.xAxis.options.reversed&&(n=!n),t.points&&(r=S(n?t.points:t.points.slice(0).reverse(),function(t){return k(t.plotY)})),o=this.itemMarginTop+t.legendItem.label.getBBox().height+this.itemMarginBottom,h=t.yAxis.top-e.plotTop,a=t.visible?(r?r.plotY:t.yAxis.height)+(h-.3*o):h+t.yAxis.height,i.push({target:a,size:o,item:t}));},this),g(i,e.plotHeight)))t=r.item.legendItem||{},k(r.pos)&&(t.y=e.plotTop-e.spacing[0]+r.pos);}render(){let t=this.chart,e=t.renderer,i=this.options,s=this.padding,r=this.getAllItems(),o,n,a,h=this.group,l,d=this.box;this.itemX=s,this.itemY=this.initialItemY,this.offsetWidth=0,this.lastItemY=0,this.widthOption=A(i.width,t.spacingBox.width-s),l=t.spacingBox.width-2*s-i.x,["rm","lm"].indexOf(this.getAlignment().substring(0,2))>-1&&(l/=2),this.maxLegendWidth=this.widthOption||l,h||(this.group=h=e.g("legend").addClass(i.className||"").attr({zIndex:7}).add(),this.contentGroup=e.g().attr({zIndex:1}).add(h),this.scrollGroup=e.g().add(this.contentGroup)),this.renderTitle(),P(r,(t,e)=>(t.options&&t.options.legendIndex||0)-(e.options&&e.options.legendIndex||0)),i.reversed&&r.reverse(),this.allItems=r,this.display=o=!!r.length,this.lastLineHeight=0,this.maxItemWidth=0,this.totalItemWidth=0,this.itemHeight=0,r.forEach(this.renderItem,this),r.forEach(this.layoutItem,this),n=(this.widthOption||this.offsetWidth)+s,a=this.lastItemY+this.lastLineHeight+this.titleHeight,a=this.handleOverflow(a)+s,d||(this.box=d=e.rect().addClass("highcharts-legend-box").attr({r:i.borderRadius}).add(h)),t.styledMode||d.attr({stroke:i.borderColor,"stroke-width":i.borderWidth||0,fill:i.backgroundColor||"none"}).shadow(i.shadow),n>0&&a>0&&d[d.placed?"animate":"attr"](d.crisp.call({},{x:0,y:0,width:n,height:a},d.strokeWidth())),h[o?"show":"hide"](),t.styledMode&&"none"===h.getStyle("display")&&(n=a=0),this.legendWidth=n,this.legendHeight=a,o&&this.align(),this.proximate||this.positionItems(),C(this,"afterRender");}align(t=this.chart.spacingBox){let e=this.chart,i=this.options,s=t.y;/(lth|ct|rth)/.test(this.getAlignment())&&e.titleOffset[0]>0?s+=e.titleOffset[0]:/(lbh|cb|rbh)/.test(this.getAlignment())&&e.titleOffset[2]>0&&(s-=e.titleOffset[2]),s!==t.y&&(t=M(t,{y:s})),e.hasRendered||(this.group.placed=!1),this.group.align(M(i,{width:this.legendWidth,height:this.legendHeight,verticalAlign:this.proximate?"top":i.verticalAlign}),!0,t);}handleOverflow(t){let e=this,i=this.chart,s=i.renderer,r=this.options,o=r.y,n="top"===r.verticalAlign,a=this.padding,h=r.maxHeight,l=r.navigation,d=w(l.animation,!0),c=l.arrowSize||12,p=this.pages,u=this.allItems,g=function(t){"number"==typeof t?S.attr({height:t}):S&&(e.clipRect=S.destroy(),e.contentGroup.clip()),e.contentGroup.div&&(e.contentGroup.div.style.clip=t?"rect("+a+"px,9999px,"+(a+t)+"px,0)":"auto");},f=function(t){return e[t]=s.circle(0,0,1.3*c).translate(c/2,c/2).add(v),i.styledMode||e[t].attr("fill","rgba(0,0,0,0.0001)"),e[t]},m,x,y,b=i.spacingBox.height+(n?-o:o)-a,v=this.nav,S=this.clipRect;return "horizontal"!==r.layout||"middle"===r.verticalAlign||r.floating||(b/=2),h&&(b=Math.min(b,h)),p.length=0,t&&b>0&&t>b&&!1!==l.enabled?(this.clipHeight=m=Math.max(b-20-this.titleHeight-a,0),this.currentPage=w(this.currentPage,1),this.fullHeight=t,u.forEach((t,e)=>{let i=(y=t.legendItem||{}).y||0,s=Math.round(y.label.getBBox().height),r=p.length;(!r||i-p[r-1]>m&&(x||i)!==p[r-1])&&(p.push(x||i),r++),y.pageIx=r-1,x&&((u[e-1].legendItem||{}).pageIx=r-1),e===u.length-1&&i+s-p[r-1]>m&&i>p[r-1]&&(p.push(i),y.pageIx=r),i!==x&&(x=i);}),S||(S=e.clipRect=s.clipRect(0,a-2,9999,0),e.contentGroup.clip(S)),g(m),v||(this.nav=v=s.g().attr({zIndex:1}).add(this.group),this.up=s.symbol("triangle",0,0,c,c).add(v),f("upTracker").on("click",function(){e.scroll(-1,d);}),this.pager=s.text("",15,10).addClass("highcharts-legend-navigation"),!i.styledMode&&l.style&&this.pager.css(l.style),this.pager.add(v),this.down=s.symbol("triangle-down",0,0,c,c).add(v),f("downTracker").on("click",function(){e.scroll(1,d);})),e.scroll(0),t=b):v&&(g(),this.nav=v.destroy(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0),t}scroll(t,e){let i=this.chart,s=this.pages,r=s.length,o=this.clipHeight,n=this.options.navigation,a=this.pager,h=this.padding,c=this.currentPage+t;c>r&&(c=r),c>0&&(void 0!==e&&d(e,i),this.nav.attr({translateX:h,translateY:o+this.padding+7+this.titleHeight,visibility:"inherit"}),[this.up,this.upTracker].forEach(function(t){t.attr({class:1===c?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"});}),a.attr({text:c+"/"+r}),[this.down,this.downTracker].forEach(function(t){t.attr({x:18+this.pager.getBBox().width,class:c===r?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"});},this),i.styledMode||(this.up.attr({fill:1===c?n.inactiveColor:n.activeColor}),this.upTracker.css({cursor:1===c?"default":"pointer"}),this.down.attr({fill:c===r?n.inactiveColor:n.activeColor}),this.downTracker.css({cursor:c===r?"default":"pointer"})),this.scrollOffset=-s[c-1]+this.initialItemY,this.scrollGroup.animate({translateY:this.scrollOffset}),this.currentPage=c,this.positionCheckboxes(),L(()=>{C(this,"afterScroll",{currentPage:c});},l(w(e,i.renderer.globalAnimation,!0)).duration));}setItemEvents(t,e,i){let o=this,n=t.legendItem||{},a=o.chart.renderer.boxWrapper,h=t instanceof r,l=t instanceof s,d="highcharts-legend-"+(h?"point":"series")+"-active",c=o.chart.styledMode,p=i?[e,n.symbol]:[n.group],u=e=>{o.allItems.forEach(i=>{t!==i&&[i].concat(i.linkedSeries||[]).forEach(t=>{t.setState(e,!h);});});};for(let i of p)i&&i.on("mouseover",function(){t.visible&&u("inactive"),t.setState("hover"),t.visible&&a.addClass(d),c||e.css(o.options.itemHoverStyle);}).on("mouseout",function(){o.chart.styledMode||e.css(M(t.visible?o.itemStyle:o.itemHiddenStyle)),u(""),a.removeClass(d),t.setState();}).on("click",function(e){let i=function(){t.setVisible&&t.setVisible(),u(t.visible?"inactive":"");};a.removeClass(d),C(o,"itemClick",{browserEvent:e,legendItem:t},i),h?t.firePointEvent("legendItemClick",{browserEvent:e}):l&&C(t,"legendItemClick",{browserEvent:e});});}createCheckboxForItem(t){t.checkbox=x("input",{type:"checkbox",className:"highcharts-legend-checkbox",checked:t.selected,defaultChecked:t.selected},this.options.itemCheckboxStyle,this.chart.container),m(t.checkbox,"click",function(e){let i=e.target;C(t.series||t,"checkboxClick",{checked:i.checked,item:t},function(){t.select();});});}}return (h=O||(O={})).compose=function(t){T(p,"Core.Legend")&&m(t,"beforeMargins",function(){this.legend=new h(this,this.options.legend);});},O}),i(e,"Core/Chart/Chart.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Axis/Axis.js"],e["Core/Defaults.js"],e["Core/Templating.js"],e["Core/Foundation.js"],e["Core/Globals.js"],e["Core/Renderer/RendererRegistry.js"],e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Renderer/SVG/SVGRenderer.js"],e["Core/Time.js"],e["Core/Utilities.js"],e["Core/Renderer/HTML/AST.js"],e["Core/Axis/Tick.js"]],function(t,e,i,s,r,o,n,a,h,l,d,c,p,u){let{animate:g,animObject:f,setAnimation:m}=t,{defaultOptions:x,defaultTime:y}=i,{numberFormat:b}=s,{registerEventOptions:v}=r,{charts:S,doc:C,marginNames:k,svg:M,win:w}=o,{seriesTypes:T}=h,{addEvent:A,attr:P,createElement:L,css:O,defined:D,diffObjects:E,discardElement:I,erase:j,error:B,extend:R,find:z,fireEvent:N,getStyle:W,isArray:G,isNumber:H,isObject:X,isString:F,merge:Y,objectEach:U,pick:V,pInt:$,relativeLength:Z,removeEvent:_,splat:q,syncTimeout:K,uniqueKey:J}=c;class Q{static chart(t,e,i){return new Q(t,e,i)}constructor(t,e,i){this.sharedClips={};let s=[...arguments];(F(t)||t.nodeName)&&(this.renderTo=s.shift()),this.init(s[0],s[1]);}setZoomOptions(){let t=this.options.chart,e=t.zooming;this.zooming={...e,type:V(t.zoomType,e.type),key:V(t.zoomKey,e.key),pinchType:V(t.pinchType,e.pinchType),singleTouch:V(t.zoomBySingleTouch,e.singleTouch,!1),resetButton:Y(e.resetButton,t.resetZoomButton)};}init(t,e){N(this,"init",{args:arguments},function(){let i=Y(x,t),s=i.chart;this.userOptions=R({},t),this.margin=[],this.spacing=[],this.labelCollectors=[],this.callback=e,this.isResizing=0,this.options=i,this.axes=[],this.series=[],this.time=t.time&&Object.keys(t.time).length?new d(t.time):o.time,this.numberFormatter=s.numberFormatter||b,this.styledMode=s.styledMode,this.hasCartesianSeries=s.showAxes,this.index=S.length,S.push(this),o.chartCount++,v(this,s),this.xAxis=[],this.yAxis=[],this.pointCount=this.colorCounter=this.symbolCounter=0,this.setZoomOptions(),N(this,"afterInit"),this.firstRender();});}initSeries(t){let e=this.options.chart,i=t.type||e.type,s=T[i];s||B(17,!0,this,{missingModuleFor:i});let r=new s;return "function"==typeof r.init&&r.init(this,t),r}setSortedData(){this.getSeriesOrderByLinks().forEach(function(t){t.points||t.data||!t.enabledDataSorting||t.setData(t.options.data,!1);});}getSeriesOrderByLinks(){return this.series.concat().sort(function(t,e){return t.linkedSeries.length||e.linkedSeries.length?e.linkedSeries.length-t.linkedSeries.length:0})}orderItems(t,e=0){let i=this[t],s=this.options[t]=q(this.options[t]).slice(),r=this.userOptions[t]=this.userOptions[t]?q(this.userOptions[t]).slice():[];if(this.hasRendered&&(s.splice(e),r.splice(e)),i)for(let t=e,o=i.length;t<o;++t){let e=i[t];e&&(e.index=t,e instanceof a&&(e.name=e.getName()),e.options.isInternal||(s[t]=e.options,r[t]=e.userOptions));}}isInsidePlot(t,e,i={}){let{inverted:s,plotBox:r,plotLeft:o,plotTop:n,scrollablePlotBox:a}=this,{scrollLeft:h=0,scrollTop:l=0}=i.visiblePlotOnly&&this.scrollablePlotArea?.scrollingContainer||{},d=i.series,c=i.visiblePlotOnly&&a||r,p=i.inverted?e:t,u=i.inverted?t:e,g={x:p,y:u,isInsidePlot:!0,options:i};if(!i.ignoreX){let t=d&&(s&&!this.polar?d.yAxis:d.xAxis)||{pos:o,len:1/0},e=i.paneCoordinates?t.pos+p:o+p;e>=Math.max(h+o,t.pos)&&e<=Math.min(h+o+c.width,t.pos+t.len)||(g.isInsidePlot=!1);}if(!i.ignoreY&&g.isInsidePlot){let t=!s&&i.axis&&!i.axis.isXAxis&&i.axis||d&&(s?d.xAxis:d.yAxis)||{pos:n,len:1/0},e=i.paneCoordinates?t.pos+u:n+u;e>=Math.max(l+n,t.pos)&&e<=Math.min(l+n+c.height,t.pos+t.len)||(g.isInsidePlot=!1);}return N(this,"afterIsInsidePlot",g),g.isInsidePlot}redraw(t){N(this,"beforeRedraw");let e=this.hasCartesianSeries?this.axes:this.colorAxis||[],i=this.series,s=this.pointer,r=this.legend,o=this.userOptions.legend,n=this.renderer,a=n.isHidden(),h=[],l,d,c,p=this.isDirtyBox,u=this.isDirtyLegend,g;for(n.rootFontSize=n.boxWrapper.getStyle("font-size"),this.setResponsive&&this.setResponsive(!1),m(!!this.hasRendered&&t,this),a&&this.temporaryDisplay(),this.layOutTitles(!1),c=i.length;c--;)if(((g=i[c]).options.stacking||g.options.centerInCategory)&&(d=!0,g.isDirty)){l=!0;break}if(l)for(c=i.length;c--;)(g=i[c]).options.stacking&&(g.isDirty=!0);i.forEach(function(t){t.isDirty&&("point"===t.options.legendType?("function"==typeof t.updateTotals&&t.updateTotals(),u=!0):o&&(o.labelFormatter||o.labelFormat)&&(u=!0)),t.isDirtyData&&N(t,"updatedData");}),u&&r&&r.options.enabled&&(r.render(),this.isDirtyLegend=!1),d&&this.getStacks(),e.forEach(function(t){t.updateNames(),t.setScale();}),this.getMargins(),e.forEach(function(t){t.isDirty&&(p=!0);}),e.forEach(function(t){let e=t.min+","+t.max;t.extKey!==e&&(t.extKey=e,h.push(function(){N(t,"afterSetExtremes",R(t.eventArgs,t.getExtremes())),delete t.eventArgs;})),(p||d)&&t.redraw();}),p&&this.drawChartBox(),N(this,"predraw"),i.forEach(function(t){(p||t.isDirty)&&t.visible&&t.redraw(),t.isDirtyData=!1;}),s&&s.reset(!0),n.draw(),N(this,"redraw"),N(this,"render"),a&&this.temporaryDisplay(!0),h.forEach(function(t){t.call();});}get(t){let e=this.series;function i(e){return e.id===t||e.options&&e.options.id===t}let s=z(this.axes,i)||z(this.series,i);for(let t=0;!s&&t<e.length;t++)s=z(e[t].points||[],i);return s}getAxes(){let t=this.userOptions;for(let i of(N(this,"getAxes"),["xAxis","yAxis"]))for(let s of t[i]=q(t[i]||{}))new e(this,s,i);N(this,"afterGetAxes");}getSelectedPoints(){return this.series.reduce((t,e)=>(e.getPointsCollection().forEach(e=>{V(e.selectedStaging,e.selected)&&t.push(e);}),t),[])}getSelectedSeries(){return this.series.filter(function(t){return t.selected})}setTitle(t,e,i){this.applyDescription("title",t),this.applyDescription("subtitle",e),this.applyDescription("caption",void 0),this.layOutTitles(i);}applyDescription(t,e){let i=this,s=this.options[t]=Y(this.options[t],e),r=this[t];r&&e&&(this[t]=r=r.destroy()),s&&!r&&((r=this.renderer.text(s.text,0,0,s.useHTML).attr({align:s.align,class:"highcharts-"+t,zIndex:s.zIndex||4}).add()).update=function(e,s){i.applyDescription(t,e),i.layOutTitles(s);},this.styledMode||r.css(R("title"===t?{fontSize:this.options.isStock?"1em":"1.2em"}:{},s.style)),this[t]=r);}layOutTitles(t=!0){let e=[0,0,0],i=this.renderer,s=this.spacingBox;["title","subtitle","caption"].forEach(function(t){let r=this[t],o=this.options[t],n=o.verticalAlign||"top",a="title"===t?"top"===n?-3:0:"top"===n?e[0]+2:0;if(r){r.css({width:(o.width||s.width+(o.widthAdjust||0))+"px"});let t=i.fontMetrics(r).b,h=Math.round(r.getBBox(o.useHTML).height);r.align(R({y:"bottom"===n?t:a+t,height:h},o),!1,"spacingBox"),o.floating||("top"===n?e[0]=Math.ceil(e[0]+h):"bottom"===n&&(e[2]=Math.ceil(e[2]+h)));}},this),e[0]&&"top"===(this.options.title.verticalAlign||"top")&&(e[0]+=this.options.title.margin),e[2]&&"bottom"===this.options.caption.verticalAlign&&(e[2]+=this.options.caption.margin);let r=!this.titleOffset||this.titleOffset.join(",")!==e.join(",");this.titleOffset=e,N(this,"afterLayOutTitles"),!this.isDirtyBox&&r&&(this.isDirtyBox=this.isDirtyLegend=r,this.hasRendered&&t&&this.isDirtyBox&&this.redraw());}getContainerBox(){let t=[].map.call(this.renderTo.children,t=>{if(t!==this.container){let e=t.style.display;return t.style.display="none",[t,e]}}),e={width:W(this.renderTo,"width",!0)||0,height:W(this.renderTo,"height",!0)||0};return t.filter(Boolean).forEach(([t,e])=>{t.style.display=e;}),e}getChartSize(){let t=this.options.chart,e=t.width,i=t.height,s=this.getContainerBox(),r=s.height>1&&!(!this.renderTo.parentElement?.style.height&&"100%"===this.renderTo.style.height);this.chartWidth=Math.max(0,e||s.width||600),this.chartHeight=Math.max(0,Z(i,this.chartWidth)||(r?s.height:400)),this.containerBox=s;}temporaryDisplay(t){let e=this.renderTo,i;if(t)for(;e&&e.style;)e.hcOrigStyle&&(O(e,e.hcOrigStyle),delete e.hcOrigStyle),e.hcOrigDetached&&(C.body.removeChild(e),e.hcOrigDetached=!1),e=e.parentNode;else for(;e&&e.style&&(C.body.contains(e)||e.parentNode||(e.hcOrigDetached=!0,C.body.appendChild(e)),("none"===W(e,"display",!1)||e.hcOricDetached)&&(e.hcOrigStyle={display:e.style.display,height:e.style.height,overflow:e.style.overflow},i={display:"block",overflow:"hidden"},e!==this.renderTo&&(i.height=0),O(e,i),e.offsetWidth||e.style.setProperty("display","block","important")),(e=e.parentNode)!==C.body););}setClassName(t){this.container.className="highcharts-container "+(t||"");}getContainer(){let t=this.options,e=t.chart,i="data-highcharts-chart",s=J(),r,o=this.renderTo;o||(this.renderTo=o=e.renderTo),F(o)&&(this.renderTo=o=C.getElementById(o)),o||B(13,!0,this);let a=$(P(o,i));H(a)&&S[a]&&S[a].hasRendered&&S[a].destroy(),P(o,i,this.index),o.innerHTML=p.emptyHTML,e.skipClone||o.offsetWidth||this.temporaryDisplay(),this.getChartSize();let h=this.chartHeight,d=this.chartWidth;O(o,{overflow:"hidden"}),this.styledMode||(r=R({position:"relative",overflow:"hidden",width:d+"px",height:h+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)",userSelect:"none","touch-action":"manipulation",outline:"none",padding:"0px"},e.style||{}));let c=L("div",{id:s},r,o);this.container=c,this.getChartSize(),d===this.chartWidth||(d=this.chartWidth,this.styledMode||O(c,{width:V(e.style?.width,d+"px")})),this.containerBox=this.getContainerBox(),this._cursor=c.style.cursor;let u=e.renderer||!M?n.getRendererType(e.renderer):l;if(this.renderer=new u(c,d,h,void 0,e.forExport,t.exporting&&t.exporting.allowHTML,this.styledMode),m(void 0,this),this.setClassName(e.className),this.styledMode)for(let e in t.defs)this.renderer.definition(t.defs[e]);else this.renderer.setStyle(e.style);this.renderer.chartIndex=this.index,N(this,"afterGetContainer");}getMargins(t){let{spacing:e,margin:i,titleOffset:s}=this;this.resetMargins(),s[0]&&!D(i[0])&&(this.plotTop=Math.max(this.plotTop,s[0]+e[0])),s[2]&&!D(i[2])&&(this.marginBottom=Math.max(this.marginBottom,s[2]+e[2])),this.legend&&this.legend.display&&this.legend.adjustMargins(i,e),N(this,"getMargins"),t||this.getAxisMargins();}getAxisMargins(){let t=this,e=t.axisOffset=[0,0,0,0],i=t.colorAxis,s=t.margin,r=function(t){t.forEach(function(t){t.visible&&t.getOffset();});};t.hasCartesianSeries?r(t.axes):i&&i.length&&r(i),k.forEach(function(i,r){D(s[r])||(t[i]+=e[r]);}),t.setChartSize();}getOptions(){return E(this.userOptions,x)}reflow(t){let e=this,i=e.containerBox,s=e.getContainerBox();delete e.pointer?.chartPosition,!e.isPrinting&&!e.isResizing&&i&&s.width&&((s.width!==i.width||s.height!==i.height)&&(c.clearTimeout(e.reflowTimeout),e.reflowTimeout=K(function(){e.container&&e.setSize(void 0,void 0,!1);},t?100:0)),e.containerBox=s);}setReflow(){let t=this,e=e=>{t.options?.chart.reflow&&t.hasLoaded&&t.reflow(e);};if("function"==typeof ResizeObserver)new ResizeObserver(e).observe(t.renderTo);else {let t=A(w,"resize",e);A(this,"destroy",t);}}setSize(t,e,i){let s=this,r=s.renderer;s.isResizing+=1,m(i,s);let o=r.globalAnimation;s.oldChartHeight=s.chartHeight,s.oldChartWidth=s.chartWidth,void 0!==t&&(s.options.chart.width=t),void 0!==e&&(s.options.chart.height=e),s.getChartSize();let{chartWidth:n,chartHeight:a,scrollablePixelsX:h=0,scrollablePixelsY:l=0}=s;(s.isDirtyBox||n!==s.oldChartWidth||a!==s.oldChartHeight)&&(s.styledMode||(o?g:O)(s.container,{width:`${n+h}px`,height:`${a+l}px`},o),s.setChartSize(!0),r.setSize(n,a,o),s.axes.forEach(function(t){t.isDirty=!0,t.setScale();}),s.isDirtyLegend=!0,s.isDirtyBox=!0,s.layOutTitles(),s.getMargins(),s.redraw(o),s.oldChartHeight=void 0,N(s,"resize"),setTimeout(()=>{s&&N(s,"endResize");},f(o).duration)),s.isResizing-=1;}setChartSize(t){let e,i,s,r;let{chartHeight:o,chartWidth:n,inverted:a,spacing:h,renderer:l}=this,d=this.clipOffset,c=Math[a?"floor":"round"];this.plotLeft=e=Math.round(this.plotLeft),this.plotTop=i=Math.round(this.plotTop),this.plotWidth=s=Math.max(0,Math.round(n-e-this.marginRight)),this.plotHeight=r=Math.max(0,Math.round(o-i-this.marginBottom)),this.plotSizeX=a?r:s,this.plotSizeY=a?s:r,this.spacingBox=l.spacingBox={x:h[3],y:h[0],width:n-h[3]-h[1],height:o-h[0]-h[2]},this.plotBox=l.plotBox={x:e,y:i,width:s,height:r},d&&(this.clipBox={x:c(d[3]),y:c(d[0]),width:c(this.plotSizeX-d[1]-d[3]),height:c(this.plotSizeY-d[0]-d[2])}),t||(this.axes.forEach(function(t){t.setAxisSize(),t.setAxisTranslation();}),l.alignElements()),N(this,"afterSetChartSize",{skipAxes:t});}resetMargins(){N(this,"resetMargins");let t=this,e=t.options.chart,i=e.plotBorderWidth||0,s=i/2;["margin","spacing"].forEach(function(i){let s=e[i],r=X(s)?s:[s,s,s,s];["Top","Right","Bottom","Left"].forEach(function(s,o){t[i][o]=V(e[i+s],r[o]);});}),k.forEach(function(e,i){t[e]=V(t.margin[i],t.spacing[i]);}),t.axisOffset=[0,0,0,0],t.clipOffset=[s,s,s,s],t.plotBorderWidth=i;}drawChartBox(){let t=this.options.chart,e=this.renderer,i=this.chartWidth,s=this.chartHeight,r=this.styledMode,o=this.plotBGImage,n=t.backgroundColor,a=t.plotBackgroundColor,h=t.plotBackgroundImage,l=this.plotLeft,d=this.plotTop,c=this.plotWidth,p=this.plotHeight,u=this.plotBox,g=this.clipRect,f=this.clipBox,m=this.chartBackground,x=this.plotBackground,y=this.plotBorder,b,v,S,C="animate";m||(this.chartBackground=m=e.rect().addClass("highcharts-background").add(),C="attr"),r?b=v=m.strokeWidth():(v=(b=t.borderWidth||0)+(t.shadow?8:0),S={fill:n||"none"},(b||m["stroke-width"])&&(S.stroke=t.borderColor,S["stroke-width"]=b),m.attr(S).shadow(t.shadow)),m[C]({x:v/2,y:v/2,width:i-v-b%2,height:s-v-b%2,r:t.borderRadius}),C="animate",x||(C="attr",this.plotBackground=x=e.rect().addClass("highcharts-plot-background").add()),x[C](u),!r&&(x.attr({fill:a||"none"}).shadow(t.plotShadow),h&&(o?(h!==o.attr("href")&&o.attr("href",h),o.animate(u)):this.plotBGImage=e.image(h,l,d,c,p).add())),g?g.animate({width:f.width,height:f.height}):this.clipRect=e.clipRect(f),C="animate",y||(C="attr",this.plotBorder=y=e.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add()),r||y.attr({stroke:t.plotBorderColor,"stroke-width":t.plotBorderWidth||0,fill:"none"}),y[C](y.crisp({x:l,y:d,width:c,height:p},-y.strokeWidth())),this.isDirtyBox=!1,N(this,"afterDrawChartBox");}propFromSeries(){let t,e,i;let s=this,r=s.options.chart,o=s.options.series;["inverted","angular","polar"].forEach(function(n){for(e=T[r.type],i=r[n]||e&&e.prototype[n],t=o&&o.length;!i&&t--;)(e=T[o[t].type])&&e.prototype[n]&&(i=!0);s[n]=i;});}linkSeries(t){let e=this,i=e.series;i.forEach(function(t){t.linkedSeries.length=0;}),i.forEach(function(t){let{linkedTo:i}=t.options;if(F(i)){let s;(s=":previous"===i?e.series[t.index-1]:e.get(i))&&s.linkedParent!==t&&(s.linkedSeries.push(t),t.linkedParent=s,s.enabledDataSorting&&t.setDataSortingOptions(),t.visible=V(t.options.visible,s.options.visible,t.visible));}}),N(this,"afterLinkSeries",{isUpdating:t});}renderSeries(){this.series.forEach(function(t){t.translate(),t.render();});}render(){let t=this.axes,e=this.colorAxis,i=this.renderer,s=this.options.chart.axisLayoutRuns||2,r=t=>{t.forEach(t=>{t.visible&&t.render();});},o=0,n=!0,a,h=0;for(let e of(this.setTitle(),N(this,"beforeMargins"),this.getStacks?.(),this.getMargins(!0),this.setChartSize(),t)){let{options:t}=e,{labels:i}=t;if(this.hasCartesianSeries&&e.horiz&&e.visible&&i.enabled&&e.series.length&&"colorAxis"!==e.coll&&!this.polar){o=t.tickLength,e.createGroups();let s=new u(e,0,"",!0),r=s.createLabel("x",i);if(s.destroy(),r&&V(i.reserveSpace,!H(t.crossing))&&(o=r.getBBox().height+i.distance+Math.max(t.offset||0,0)),o){r?.destroy();break}}}for(this.plotHeight=Math.max(this.plotHeight-o,0);(n||a||s>1)&&h<s;){let e=this.plotWidth,i=this.plotHeight;for(let e of t)0===h?e.setScale():(e.horiz&&n||!e.horiz&&a)&&e.setTickInterval(!0);0===h?this.getAxisMargins():this.getMargins(),n=e/this.plotWidth>(h?1:1.1),a=i/this.plotHeight>(h?1:1.05),h++;}this.drawChartBox(),this.hasCartesianSeries?r(t):e&&e.length&&r(e),this.seriesGroup||(this.seriesGroup=i.g("series-group").attr({zIndex:3}).shadow(this.options.chart.seriesGroupShadow).add()),this.renderSeries(),this.addCredits(),this.setResponsive&&this.setResponsive(),this.hasRendered=!0;}addCredits(t){let e=this,i=Y(!0,this.options.credits,t);i.enabled&&!this.credits&&(this.credits=this.renderer.text(i.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){i.href&&(w.location.href=i.href);}).attr({align:i.position.align,zIndex:8}),e.styledMode||this.credits.css(i.style),this.credits.add().align(i.position),this.credits.update=function(t){e.credits=e.credits.destroy(),e.addCredits(t);});}destroy(){let t;let e=this,i=e.axes,s=e.series,r=e.container,n=r&&r.parentNode;for(N(e,"destroy"),e.renderer.forExport?j(S,e):S[e.index]=void 0,o.chartCount--,e.renderTo.removeAttribute("data-highcharts-chart"),_(e),t=i.length;t--;)i[t]=i[t].destroy();for(this.scroller&&this.scroller.destroy&&this.scroller.destroy(),t=s.length;t--;)s[t]=s[t].destroy();["title","subtitle","chartBackground","plotBackground","plotBGImage","plotBorder","seriesGroup","clipRect","credits","pointer","rangeSelector","legend","resetZoomButton","tooltip","renderer"].forEach(function(t){let i=e[t];i&&i.destroy&&(e[t]=i.destroy());}),r&&(r.innerHTML=p.emptyHTML,_(r),n&&I(r)),U(e,function(t,i){delete e[i];});}firstRender(){let t=this,e=t.options;t.getContainer(),t.resetMargins(),t.setChartSize(),t.propFromSeries(),t.getAxes();let i=G(e.series)?e.series:[];e.series=[],i.forEach(function(e){t.initSeries(e);}),t.linkSeries(),t.setSortedData(),N(t,"beforeRender"),t.render(),t.pointer?.getChartPosition(),t.renderer.imgCount||t.hasLoaded||t.onload(),t.temporaryDisplay(!0);}onload(){this.callbacks.concat([this.callback]).forEach(function(t){t&&void 0!==this.index&&t.apply(this,[this]);},this),N(this,"load"),N(this,"render"),D(this.index)&&this.setReflow(),this.warnIfA11yModuleNotLoaded(),this.hasLoaded=!0;}warnIfA11yModuleNotLoaded(){let{options:t,title:e}=this;!t||this.accessibility||(this.renderer.boxWrapper.attr({role:"img","aria-label":(e&&e.element.textContent||"").replace(/</g,"&lt;")}),t.accessibility&&!1===t.accessibility.enabled||B('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.',!1,this));}addSeries(t,e,i){let s;let r=this;return t&&(e=V(e,!0),N(r,"addSeries",{options:t},function(){s=r.initSeries(t),r.isDirtyLegend=!0,r.linkSeries(),s.enabledDataSorting&&s.setData(t.data,!1),N(r,"afterAddSeries",{series:s}),e&&r.redraw(i);})),s}addAxis(t,e,i,s){return this.createAxis(e?"xAxis":"yAxis",{axis:t,redraw:i,animation:s})}addColorAxis(t,e,i){return this.createAxis("colorAxis",{axis:t,redraw:e,animation:i})}createAxis(t,i){let s=new e(this,i.axis,t);return V(i.redraw,!0)&&this.redraw(i.animation),s}showLoading(t){let e=this,i=e.options,s=i.loading,r=function(){o&&O(o,{left:e.plotLeft+"px",top:e.plotTop+"px",width:e.plotWidth+"px",height:e.plotHeight+"px"});},o=e.loadingDiv,n=e.loadingSpan;o||(e.loadingDiv=o=L("div",{className:"highcharts-loading highcharts-loading-hidden"},null,e.container)),n||(e.loadingSpan=n=L("span",{className:"highcharts-loading-inner"},null,o),A(e,"redraw",r)),o.className="highcharts-loading",p.setElementHTML(n,V(t,i.lang.loading,"")),e.styledMode||(O(o,R(s.style,{zIndex:10})),O(n,s.labelStyle),e.loadingShown||(O(o,{opacity:0,display:""}),g(o,{opacity:s.style.opacity||.5},{duration:s.showDuration||0}))),e.loadingShown=!0,r();}hideLoading(){let t=this.options,e=this.loadingDiv;e&&(e.className="highcharts-loading highcharts-loading-hidden",this.styledMode||g(e,{opacity:0},{duration:t.loading.hideDuration||100,complete:function(){O(e,{display:"none"});}})),this.loadingShown=!1;}update(t,e,i,s){let r,o,n;let a=this,h={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle",caption:"setCaption"},l=t.isResponsiveOptions,c=[];N(a,"update",{options:t}),l||a.setResponsive(!1,!0),t=E(t,a.options),a.userOptions=Y(a.userOptions,t);let p=t.chart;p&&(Y(!0,a.options.chart,p),this.setZoomOptions(),"className"in p&&a.setClassName(p.className),("inverted"in p||"polar"in p||"type"in p)&&(a.propFromSeries(),r=!0),"alignTicks"in p&&(r=!0),"events"in p&&v(this,p),U(p,function(t,e){-1!==a.propsRequireUpdateSeries.indexOf("chart."+e)&&(o=!0),-1!==a.propsRequireDirtyBox.indexOf(e)&&(a.isDirtyBox=!0),-1===a.propsRequireReflow.indexOf(e)||(a.isDirtyBox=!0,l||(n=!0));}),!a.styledMode&&p.style&&a.renderer.setStyle(a.options.chart.style||{})),!a.styledMode&&t.colors&&(this.options.colors=t.colors),t.time&&(this.time===y&&(this.time=new d(t.time)),Y(!0,a.options.time,t.time)),U(t,function(e,i){a[i]&&"function"==typeof a[i].update?a[i].update(e,!1):"function"==typeof a[h[i]]?a[h[i]](e):"colors"!==i&&-1===a.collectionsWithUpdate.indexOf(i)&&Y(!0,a.options[i],t[i]),"chart"!==i&&-1!==a.propsRequireUpdateSeries.indexOf(i)&&(o=!0);}),this.collectionsWithUpdate.forEach(function(e){t[e]&&(q(t[e]).forEach(function(t,s){let r;let o=D(t.id);o&&(r=a.get(t.id)),!r&&a[e]&&(r=a[e][V(t.index,s)])&&(o&&D(r.options.id)||r.options.isInternal)&&(r=void 0),r&&r.coll===e&&(r.update(t,!1),i&&(r.touched=!0)),!r&&i&&a.collectionsWithInit[e]&&(a.collectionsWithInit[e][0].apply(a,[t].concat(a.collectionsWithInit[e][1]||[]).concat([!1])).touched=!0);}),i&&a[e].forEach(function(t){t.touched||t.options.isInternal?delete t.touched:c.push(t);}));}),c.forEach(function(t){t.chart&&t.remove&&t.remove(!1);}),r&&a.axes.forEach(function(t){t.update({},!1);}),o&&a.getSeriesOrderByLinks().forEach(function(t){t.chart&&t.update({},!1);},this);let u=p&&p.width,g=p&&(F(p.height)?Z(p.height,u||a.chartWidth):p.height);n||H(u)&&u!==a.chartWidth||H(g)&&g!==a.chartHeight?a.setSize(u,g,s):V(e,!0)&&a.redraw(s),N(a,"afterUpdate",{options:t,redraw:e,animation:s});}setSubtitle(t,e){this.applyDescription("subtitle",t),this.layOutTitles(e);}setCaption(t,e){this.applyDescription("caption",t),this.layOutTitles(e);}showResetZoom(){let t=this,e=x.lang,i=t.zooming.resetButton,s=i.theme,r="chart"===i.relativeTo||"spacingBox"===i.relativeTo?null:"plotBox";function o(){t.zoomOut();}N(this,"beforeShowResetZoom",null,function(){t.resetZoomButton=t.renderer.button(e.resetZoom,null,null,o,s).attr({align:i.position.align,title:e.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(i.position,!1,r);}),N(this,"afterShowResetZoom");}zoomOut(){N(this,"selection",{resetSelection:!0},()=>this.transform({reset:!0,trigger:"zoom"}));}pan(t,e){let i=this,s="object"==typeof e?e:{enabled:e,type:"x"},r=s.type,o=r&&i[({x:"xAxis",xy:"axes",y:"yAxis"})[r]].filter(t=>t.options.panningEnabled&&!t.options.isInternal),n=i.options.chart;n?.panning&&(n.panning=s),N(this,"pan",{originalEvent:t},()=>{i.transform({axes:o,event:t,to:{x:t.chartX-(i.mouseDownX||0),y:t.chartY-(i.mouseDownY||0)},trigger:"pan"}),O(i.container,{cursor:"move"});});}transform(t){let{axes:e=this.axes,event:i,from:s={},reset:r,selection:o,to:n={},trigger:a}=t,{inverted:h}=this,l=!1,d,c;for(let t of(this.hoverPoints?.forEach(t=>t.setState()),e)){let{horiz:e,len:p,minPointOffset:u=0,options:g,reversed:f}=t,m=e?"width":"height",x=e?"x":"y",y=V(n[m],t.len),b=V(s[m],t.len),v=10>Math.abs(y)?1:y/b,S=(s[x]||0)+b/2-t.pos,C=S-((n[x]??t.pos)+y/2-t.pos)/v,k=f&&!h||!f&&h?-1:1;if(!r&&(S<0||S>t.len))continue;let M=t.toValue(C,!0)+(o||t.isOrdinal?0:u*k),w=t.toValue(C+p/v,!0)-(o||t.isOrdinal?0:u*k||0),T=t.allExtremes;if(M>w&&([M,w]=[w,M]),1===v&&!r&&"yAxis"===t.coll&&!T){for(let e of t.series){let t=e.getExtremes(e.getProcessedData(!0).yData,!0);T??(T={dataMin:Number.MAX_VALUE,dataMax:-Number.MAX_VALUE}),H(t.dataMin)&&H(t.dataMax)&&(T.dataMin=Math.min(t.dataMin,T.dataMin),T.dataMax=Math.max(t.dataMax,T.dataMax));}t.allExtremes=T;}let{dataMin:A,dataMax:P,min:L,max:O}=R(t.getExtremes(),T||{}),E=A??g.min,I=P??g.max,j=w-M,B=t.categories?0:Math.min(j,I-E),z=E-B*(D(g.min)?0:g.minPadding),N=I+B*(D(g.max)?0:g.maxPadding),W=t.allowZoomOutside||1===v||"zoom"!==a&&v>1,G=Math.min(g.min??z,z,W?L:z),X=Math.max(g.max??N,N,W?O:N);(!t.isOrdinal||t.options.overscroll||1!==v||r)&&(M<G&&(M=G,v>=1&&(w=M+j)),w>X&&(w=X,v>=1&&(M=w-j)),(r||t.series.length&&(M!==L||w!==O)&&M>=G&&w<=X)&&(o?o[t.coll].push({axis:t,min:M,max:w}):(t.isPanning="zoom"!==a,t.isPanning&&(c=!0),t.setExtremes(r?void 0:M,r?void 0:w,!1,!1,{move:C,trigger:a,scale:v}),!r&&(M>G||w<X)&&"mousewheel"!==a&&(d=!0)),l=!0),i&&(this[e?"mouseDownX":"mouseDownY"]=i[e?"chartX":"chartY"]));}return l&&(o?N(this,"selection",o,()=>{delete t.selection,t.trigger="zoom",this.transform(t);}):(!d||c||this.resetZoomButton?!d&&this.resetZoomButton&&(this.resetZoomButton=this.resetZoomButton.destroy()):this.showResetZoom(),this.redraw("zoom"===a&&(this.options.chart.animation??this.pointCount<100)))),l}}return R(Q.prototype,{callbacks:[],collectionsWithInit:{xAxis:[Q.prototype.addAxis,[!0]],yAxis:[Q.prototype.addAxis,[!1]],series:[Q.prototype.addSeries]},collectionsWithUpdate:["xAxis","yAxis","series"],propsRequireDirtyBox:["backgroundColor","borderColor","borderWidth","borderRadius","plotBackgroundColor","plotBackgroundImage","plotBorderColor","plotBorderWidth","plotShadow","shadow"],propsRequireReflow:["margin","marginTop","marginRight","marginBottom","marginLeft","spacing","spacingTop","spacingRight","spacingBottom","spacingLeft"],propsRequireUpdateSeries:["chart.inverted","chart.polar","chart.ignoreHiddenSeries","chart.type","colors","plotOptions","time","tooltip"]}),Q}),i(e,"Extensions/ScrollablePlotArea.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Globals.js"],e["Core/Renderer/RendererRegistry.js"],e["Core/Utilities.js"]],function(t,e,i,s){let{stop:r}=t,{composed:o}=e,{addEvent:n,createElement:a,css:h,defined:l,merge:d,pushUnique:c}=s;function p(){let t=this.scrollablePlotArea;(this.scrollablePixelsX||this.scrollablePixelsY)&&!t&&(this.scrollablePlotArea=t=new g(this)),t?.applyFixed();}function u(){this.chart.scrollablePlotArea&&(this.chart.scrollablePlotArea.isDirty=!0);}class g{static compose(t,e,i){c(o,this.compose)&&(n(t,"afterInit",u),n(e,"afterSetChartSize",t=>this.afterSetSize(t.target,t)),n(e,"render",p),n(i,"show",u));}static afterSetSize(t,e){let i,s,r;let{minWidth:o,minHeight:n}=t.options.chart.scrollablePlotArea||{},{clipBox:a,plotBox:h,inverted:c,renderer:p}=t;if(!p.forExport&&(o?(t.scrollablePixelsX=i=Math.max(0,o-t.chartWidth),i&&(t.scrollablePlotBox=d(t.plotBox),h.width=t.plotWidth+=i,a[c?"height":"width"]+=i,r=!0)):n&&(t.scrollablePixelsY=s=Math.max(0,n-t.chartHeight),l(s)&&(t.scrollablePlotBox=d(t.plotBox),h.height=t.plotHeight+=s,a[c?"width":"height"]+=s,r=!1)),l(r)&&!e.skipAxes))for(let e of t.axes)e.horiz===r&&(e.setAxisSize(),e.setAxisTranslation());}constructor(t){let e;let s=t.options.chart,r=i.getRendererType(),o=s.scrollablePlotArea||{},l=this.moveFixedElements.bind(this),d={WebkitOverflowScrolling:"touch",overflowX:"hidden",overflowY:"hidden"};t.scrollablePixelsX&&(d.overflowX="auto"),t.scrollablePixelsY&&(d.overflowY="auto"),this.chart=t;let c=this.parentDiv=a("div",{className:"highcharts-scrolling-parent"},{position:"relative"},t.renderTo),p=this.scrollingContainer=a("div",{className:"highcharts-scrolling"},d,c),u=this.innerContainer=a("div",{className:"highcharts-inner-container"},void 0,p),g=this.fixedDiv=a("div",{className:"highcharts-fixed"},{position:"absolute",overflow:"hidden",pointerEvents:"none",zIndex:(s.style?.zIndex||0)+2,top:0},void 0,!0),f=this.fixedRenderer=new r(g,t.chartWidth,t.chartHeight,s.style);this.mask=f.path().attr({fill:s.backgroundColor||"#fff","fill-opacity":o.opacity??.85,zIndex:-1}).addClass("highcharts-scrollable-mask").add(),p.parentNode.insertBefore(g,p),h(t.renderTo,{overflow:"visible"}),n(t,"afterShowResetZoom",l),n(t,"afterApplyDrilldown",l),n(t,"afterLayOutTitles",l),n(p,"scroll",()=>{let{pointer:i,hoverPoint:s}=t;i&&(delete i.chartPosition,s&&(e=s),i.runPointActions(void 0,e,!0));}),u.appendChild(t.container);}applyFixed(){let{chart:t,fixedRenderer:e,isDirty:i,scrollingContainer:s}=this,{axisOffset:o,chartWidth:n,chartHeight:a,container:d,plotHeight:c,plotLeft:p,plotTop:u,plotWidth:g,scrollablePixelsX:f=0,scrollablePixelsY:m=0}=t,{scrollPositionX:x=0,scrollPositionY:y=0}=t.options.chart.scrollablePlotArea||{},b=n+f,v=a+m;e.setSize(n,a),(i??!0)&&(this.isDirty=!1,this.moveFixedElements()),r(t.container),h(d,{width:`${b}px`,height:`${v}px`}),t.renderer.boxWrapper.attr({width:b,height:v,viewBox:[0,0,b,v].join(" ")}),t.chartBackground?.attr({width:b,height:v}),h(s,{width:`${n}px`,height:`${a}px`}),l(i)||(s.scrollLeft=f*x,s.scrollTop=m*y);let S=u-o[0]-1,C=p-o[3]-1,k=u+c+o[2]+1,M=p+g+o[1]+1,w=p+g-f,T=u+c-m,A=[["M",0,0]];f?A=[["M",0,S],["L",p-1,S],["L",p-1,k],["L",0,k],["Z"],["M",w,S],["L",n,S],["L",n,k],["L",w,k],["Z"]]:m&&(A=[["M",C,0],["L",C,u-1],["L",M,u-1],["L",M,0],["Z"],["M",C,T],["L",C,a],["L",M,a],["L",M,T],["Z"]]),"adjustHeight"!==t.redrawTrigger&&this.mask.attr({d:A});}moveFixedElements(){let t;let{container:e,inverted:i,scrollablePixelsX:s,scrollablePixelsY:r}=this.chart,o=this.fixedRenderer,n=g.fixedSelectors;for(let a of(s&&!i?t=".highcharts-yaxis":s&&i?t=".highcharts-xaxis":r&&!i?t=".highcharts-xaxis":r&&i&&(t=".highcharts-yaxis"),t&&n.push(`${t}:not(.highcharts-radial-axis)`,`${t}-labels:not(.highcharts-radial-axis-labels)`),n))[].forEach.call(e.querySelectorAll(a),t=>{(t.namespaceURI===o.SVG_NS?o.box:o.box.parentNode).appendChild(t),t.style.pointerEvents="auto";});}}return g.fixedSelectors=[".highcharts-breadcrumbs-group",".highcharts-contextbutton",".highcharts-caption",".highcharts-credits",".highcharts-drillup-button",".highcharts-legend",".highcharts-legend-checkbox",".highcharts-navigator-series",".highcharts-navigator-xaxis",".highcharts-navigator-yaxis",".highcharts-navigator",".highcharts-range-selector-group",".highcharts-reset-zoom",".highcharts-scrollbar",".highcharts-subtitle",".highcharts-title"],g}),i(e,"Core/Axis/Stacking/StackItem.js",[e["Core/Templating.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i){let{format:s}=t,{series:r}=e,{destroyObjectProperties:o,fireEvent:n,isNumber:a,pick:h}=i;return class{constructor(t,e,i,s,r){let o=t.chart.inverted,n=t.reversed;this.axis=t;let a=this.isNegative=!!i!=!!n;this.options=e=e||{},this.x=s,this.total=null,this.cumulative=null,this.points={},this.hasValidPoints=!1,this.stack=r,this.leftCliff=0,this.rightCliff=0,this.alignOptions={align:e.align||(o?a?"left":"right":"center"),verticalAlign:e.verticalAlign||(o?"middle":a?"bottom":"top"),y:e.y,x:e.x},this.textAlign=e.textAlign||(o?a?"right":"left":"center");}destroy(){o(this,this.axis);}render(t){let e=this.axis.chart,i=this.options,r=i.format,o=r?s(r,this,e):i.formatter.call(this);if(this.label)this.label.attr({text:o,visibility:"hidden"});else {this.label=e.renderer.label(o,null,void 0,i.shape,void 0,void 0,i.useHTML,!1,"stack-labels");let s={r:i.borderRadius||0,text:o,padding:h(i.padding,5),visibility:"hidden"};e.styledMode||(s.fill=i.backgroundColor,s.stroke=i.borderColor,s["stroke-width"]=i.borderWidth,this.label.css(i.style||{})),this.label.attr(s),this.label.added||this.label.add(t);}this.label.labelrank=e.plotSizeY,n(this,"afterRender");}setOffset(t,e,i,s,o,l){let{alignOptions:d,axis:c,label:p,options:u,textAlign:g}=this,f=c.chart,m=this.getStackBox({xOffset:t,width:e,boxBottom:i,boxTop:s,defaultX:o,xAxis:l}),{verticalAlign:x}=d;if(p&&m){let t=p.getBBox(void 0,0),e=p.padding,i="justify"===h(u.overflow,"justify"),s;d.x=u.x||0,d.y=u.y||0;let{x:o,y:n}=this.adjustStackPosition({labelBox:t,verticalAlign:x,textAlign:g});m.x-=o,m.y-=n,p.align(d,!1,m),(s=f.isInsidePlot(p.alignAttr.x+d.x+o,p.alignAttr.y+d.y+n))||(i=!1),i&&r.prototype.justifyDataLabel.call(c,p,d,p.alignAttr,t,m),p.attr({x:p.alignAttr.x,y:p.alignAttr.y,rotation:u.rotation,rotationOriginX:t.width*({left:0,center:.5,right:1})[u.textAlign||"center"],rotationOriginY:t.height/2}),h(!i&&u.crop,!0)&&(s=a(p.x)&&a(p.y)&&f.isInsidePlot(p.x-e+(p.width||0),p.y)&&f.isInsidePlot(p.x+e,p.y)),p[s?"show":"hide"]();}n(this,"afterSetOffset",{xOffset:t,width:e});}adjustStackPosition({labelBox:t,verticalAlign:e,textAlign:i}){let s={bottom:0,middle:1,top:2,right:1,center:0,left:-1},r=s[e],o=s[i];return {x:t.width/2+t.width/2*o,y:t.height/2*r}}getStackBox(t){let e=this.axis,i=e.chart,{boxTop:s,defaultX:r,xOffset:o,width:n,boxBottom:l}=t,d=e.stacking.usePercentage?100:h(s,this.total,0),c=e.toPixels(d),p=t.xAxis||i.xAxis[0],u=h(r,p.translate(this.x))+o,g=Math.abs(c-e.toPixels(l||a(e.min)&&e.logarithmic&&e.logarithmic.lin2log(e.min)||0)),f=i.inverted,m=this.isNegative;return f?{x:(m?c:c-g)-i.plotLeft,y:p.height-u-n+p.top-i.plotTop,width:g,height:n}:{x:u+p.transB-i.plotLeft,y:(m?c-g:c)-i.plotTop,width:n,height:g}}}}),i(e,"Core/Axis/Stacking/StackingAxis.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Axis/Axis.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Axis/Stacking/StackItem.js"],e["Core/Utilities.js"]],function(t,e,i,s,r){var o;let{getDeferredAnimation:n}=t,{series:{prototype:a}}=i,{addEvent:h,correctFloat:l,defined:d,destroyObjectProperties:c,fireEvent:p,isArray:u,isNumber:g,objectEach:f,pick:m}=r;function x(){let t=this.inverted;this.axes.forEach(t=>{t.stacking&&t.stacking.stacks&&t.hasVisibleSeries&&(t.stacking.oldStacks=t.stacking.stacks);}),this.series.forEach(e=>{let i=e.xAxis&&e.xAxis.options||{};e.options.stacking&&e.reserveSpace()&&(e.stackKey=[e.type,m(e.options.stack,""),t?i.top:i.left,t?i.height:i.width].join(","));});}function y(){let t=this.stacking;if(t){let e=t.stacks;f(e,(t,i)=>{c(t),delete e[i];}),t.stackTotalGroup?.destroy();}}function b(){this.stacking||(this.stacking=new w(this));}function v(t,e,i,s){return !d(t)||t.x!==e||s&&t.stackKey!==s?t={x:e,index:0,key:s,stackKey:s}:t.index++,t.key=[i,e,t.index].join(","),t}function S(){let t;let e=this,i=e.yAxis,s=e.stackKey||"",r=i.stacking.stacks,o=e.processedXData,n=e.options.stacking,a=e[n+"Stacker"];a&&[s,"-"+s].forEach(i=>{let s=o.length,n,h,l;for(;s--;)n=o[s],t=e.getStackIndicator(t,n,e.index,i),h=r[i]?.[n],(l=h?.points[t.key||""])&&a.call(e,l,h,s);});}function C(t,e,i){let s=e.total?100/e.total:0;t[0]=l(t[0]*s),t[1]=l(t[1]*s),this.stackedYData[i]=t[1];}function k(t){(this.is("column")||this.is("columnrange"))&&(this.options.centerInCategory&&!this.options.stacking&&this.chart.series.length>1?a.setStackedPoints.call(this,t,"group"):t.stacking.resetStacks());}function M(t,e){let i,r,o,n,a,h,c,p,g;let f=e||this.options.stacking;if(!f||!this.reserveSpace()||(({group:"xAxis"})[f]||"yAxis")!==t.coll)return;let x=this.processedXData,y=this.processedYData,b=[],v=y.length,S=this.options,C=S.threshold||0,k=S.startFromThreshold?C:0,M=S.stack,w=e?`${this.type},${f}`:this.stackKey||"",T="-"+w,A=this.negStacks,P=t.stacking,L=P.stacks,O=P.oldStacks;for(P.stacksTouched+=1,c=0;c<v;c++){p=x[c],g=y[c],h=(i=this.getStackIndicator(i,p,this.index)).key||"",L[a=(r=A&&g<(k?0:C))?T:w]||(L[a]={}),L[a][p]||(O[a]?.[p]?(L[a][p]=O[a][p],L[a][p].total=null):L[a][p]=new s(t,t.options.stackLabels,!!r,p,M)),o=L[a][p],null!==g?(o.points[h]=o.points[this.index]=[m(o.cumulative,k)],d(o.cumulative)||(o.base=h),o.touched=P.stacksTouched,i.index>0&&!1===this.singleStacks&&(o.points[h][0]=o.points[this.index+","+p+",0"][0])):(delete o.points[h],delete o.points[this.index]);let e=o.total||0;"percent"===f?(n=r?w:T,e=A&&L[n]?.[p]?(n=L[n][p]).total=Math.max(n.total||0,e)+Math.abs(g)||0:l(e+(Math.abs(g)||0))):"group"===f?(u(g)&&(g=g[0]),null!==g&&e++):e=l(e+(g||0)),"group"===f?o.cumulative=(e||1)-1:o.cumulative=l(m(o.cumulative,k)+(g||0)),o.total=e,null!==g&&(o.points[h].push(o.cumulative),b[c]=o.cumulative,o.hasValidPoints=!0);}"percent"===f&&(P.usePercentage=!0),"group"!==f&&(this.stackedYData=b),P.oldStacks={};}class w{constructor(t){this.oldStacks={},this.stacks={},this.stacksTouched=0,this.axis=t;}buildStacks(){let t,e;let i=this.axis,s=i.series,r="xAxis"===i.coll,o=i.options.reversedStacks,n=s.length;for(this.resetStacks(),this.usePercentage=!1,e=n;e--;)t=s[o?e:n-e-1],r&&t.setGroupedPoints(i),t.setStackedPoints(i);if(!r)for(e=0;e<n;e++)s[e].modifyStacks();p(i,"afterBuildStacks");}cleanStacks(){this.oldStacks&&(this.stacks=this.oldStacks,f(this.stacks,t=>{f(t,t=>{t.cumulative=t.total;});}));}resetStacks(){f(this.stacks,t=>{f(t,(e,i)=>{g(e.touched)&&e.touched<this.stacksTouched?(e.destroy(),delete t[i]):(e.total=null,e.cumulative=null);});});}renderStackTotals(){let t=this.axis,e=t.chart,i=e.renderer,s=this.stacks,r=n(e,t.options.stackLabels?.animation||!1),o=this.stackTotalGroup=this.stackTotalGroup||i.g("stack-labels").attr({zIndex:6,opacity:0}).add();o.translate(e.plotLeft,e.plotTop),f(s,t=>{f(t,t=>{t.render(o);});}),o.animate({opacity:1},r);}}return (o||(o={})).compose=function(t,e,i){let s=e.prototype,r=i.prototype;s.getStacks||(h(t,"init",b),h(t,"destroy",y),s.getStacks=x,r.getStackIndicator=v,r.modifyStacks=S,r.percentStacker=C,r.setGroupedPoints=k,r.setStackedPoints=M);},o}),i(e,"Series/Line/LineSeries.js",[e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i){let{defined:s,merge:r,isObject:o}=i;class n extends t{drawGraph(){let t=this.options,e=(this.gappedPath||this.getGraphPath).call(this),i=this.chart.styledMode;[this,...this.zones].forEach((s,n)=>{let a,h=s.graph,l=h?"animate":"attr",d=s.dashStyle||t.dashStyle;h?(h.endX=this.preventGraphAnimation?null:e.xMap,h.animate({d:e})):e.length&&(s.graph=h=this.chart.renderer.path(e).addClass("highcharts-graph"+(n?` highcharts-zone-graph-${n-1} `:" ")+(n&&s.className||"")).attr({zIndex:1}).add(this.group)),h&&!i&&(a={stroke:!n&&t.lineColor||s.color||this.color||"#cccccc","stroke-width":t.lineWidth||0,fill:this.fillGraph&&this.color||"none"},d?a.dashstyle=d:"square"!==t.linecap&&(a["stroke-linecap"]=a["stroke-linejoin"]="round"),h[l](a).shadow(n<2&&t.shadow&&r({filterUnits:"userSpaceOnUse"},o(t.shadow)?t.shadow:{}))),h&&(h.startX=e.xMap,h.isArea=e.isArea);});}getGraphPath(t,e,i){let r=this,o=r.options,n=[],a=[],h,l=o.step,d=(t=t||r.points).reversed;return d&&t.reverse(),(l=({right:1,center:2})[l]||l&&3)&&d&&(l=4-l),(t=this.getValidPoints(t,!1,!(o.connectNulls&&!e&&!i))).forEach(function(d,c){let p;let u=d.plotX,g=d.plotY,f=t[c-1],m=d.isNull||"number"!=typeof g;(d.leftCliff||f&&f.rightCliff)&&!i&&(h=!0),m&&!s(e)&&c>0?h=!o.connectNulls:m&&!e?h=!0:(0===c||h?p=[["M",d.plotX,d.plotY]]:r.getPointSpline?p=[r.getPointSpline(t,d,c)]:l?(p=1===l?[["L",f.plotX,g]]:2===l?[["L",(f.plotX+u)/2,f.plotY],["L",(f.plotX+u)/2,g]]:[["L",u,f.plotY]]).push(["L",u,g]):p=[["L",u,g]],a.push(d.x),l&&(a.push(d.x),2===l&&a.push(d.x)),n.push.apply(n,p),h=!1);}),n.xMap=a,r.graphPath=n,n}}return n.defaultOptions=r(t.defaultOptions,{legendSymbol:"lineMarker"}),e.registerSeriesType("line",n),n}),i(e,"Series/Area/AreaSeriesDefaults.js",[],function(){return {threshold:0,legendSymbol:"areaMarker"}}),i(e,"Series/Area/AreaSeries.js",[e["Series/Area/AreaSeriesDefaults.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i){let{seriesTypes:{line:s}}=e,{extend:r,merge:o,objectEach:n,pick:a}=i;class h extends s{drawGraph(){this.areaPath=[],super.drawGraph.apply(this);let{areaPath:t,options:e}=this;[this,...this.zones].forEach((i,s)=>{let r={},o=i.fillColor||e.fillColor,n=i.area,a=n?"animate":"attr";n?(n.endX=this.preventGraphAnimation?null:t.xMap,n.animate({d:t})):(r.zIndex=0,(n=i.area=this.chart.renderer.path(t).addClass("highcharts-area"+(s?` highcharts-zone-area-${s-1} `:" ")+(s&&i.className||"")).add(this.group)).isArea=!0),this.chart.styledMode||(r.fill=o||i.color||this.color,r["fill-opacity"]=o?1:e.fillOpacity??.75,n.css({pointerEvents:this.stickyTracking?"none":"auto"})),n[a](r),n.startX=t.xMap,n.shiftUnit=e.step?2:1;});}getGraphPath(t){let e,i,r;let o=s.prototype.getGraphPath,n=this.options,h=n.stacking,l=this.yAxis,d=[],c=[],p=this.index,u=l.stacking.stacks[this.stackKey],g=n.threshold,f=Math.round(l.getThreshold(n.threshold)),m=a(n.connectNulls,"percent"===h),x=function(i,s,r){let o=t[i],n=h&&u[o.x].points[p],a=o[r+"Null"]||0,m=o[r+"Cliff"]||0,x,y,b=!0;m||a?(x=(a?n[0]:n[1])+m,y=n[0]+m,b=!!a):!h&&t[s]&&t[s].isNull&&(x=y=g),void 0!==x&&(c.push({plotX:e,plotY:null===x?f:l.getThreshold(x),isNull:b,isCliff:!0}),d.push({plotX:e,plotY:null===y?f:l.getThreshold(y),doCurve:!1}));};t=t||this.points,h&&(t=this.getStackPoints(t));for(let s=0,o=t.length;s<o;++s)h||(t[s].leftCliff=t[s].rightCliff=t[s].leftNull=t[s].rightNull=void 0),i=t[s].isNull,e=a(t[s].rectPlotX,t[s].plotX),r=h?a(t[s].yBottom,f):f,i&&!m||(m||x(s,s-1,"left"),i&&!h&&m||(c.push(t[s]),d.push({x:s,plotX:e,plotY:r})),m||x(s,s+1,"right"));let y=o.call(this,c,!0,!0);d.reversed=!0;let b=o.call(this,d,!0,!0),v=b[0];v&&"M"===v[0]&&(b[0]=["L",v[1],v[2]]);let S=y.concat(b);S.length&&S.push(["Z"]);let C=o.call(this,c,!1,m);return this.chart.series.length>1&&h&&c.some(t=>t.isCliff)&&(S.hasStackedCliffs=C.hasStackedCliffs=!0),S.xMap=y.xMap,this.areaPath=S,C}getStackPoints(t){let e=this,i=[],s=[],r=this.xAxis,o=this.yAxis,h=o.stacking.stacks[this.stackKey],l={},d=o.series,c=d.length,p=o.options.reversedStacks?1:-1,u=d.indexOf(e);if(t=t||this.points,this.options.stacking){for(let e=0;e<t.length;e++)t[e].leftNull=t[e].rightNull=void 0,l[t[e].x]=t[e];n(h,function(t,e){null!==t.total&&s.push(e);}),s.sort(function(t,e){return t-e});let g=d.map(t=>t.visible);s.forEach(function(t,n){let f=0,m,x;if(l[t]&&!l[t].isNull)i.push(l[t]),[-1,1].forEach(function(i){let r=1===i?"rightNull":"leftNull",o=h[s[n+i]],a=0;if(o){let i=u;for(;i>=0&&i<c;){let s=d[i].index;!(m=o.points[s])&&(s===e.index?l[t][r]=!0:g[i]&&(x=h[t].points[s])&&(a-=x[1]-x[0])),i+=p;}}l[t][1===i?"rightCliff":"leftCliff"]=a;});else {let e=u;for(;e>=0&&e<c;){let i=d[e].index;if(m=h[t].points[i]){f=m[1];break}e+=p;}f=a(f,0),f=o.translate(f,0,1,0,1),i.push({isNull:!0,plotX:r.translate(t,0,0,0,1),x:t,plotY:f,yBottom:f});}});}return i}}return h.defaultOptions=o(s.defaultOptions,t),r(h.prototype,{singleStacks:!1}),e.registerSeriesType("area",h),h}),i(e,"Series/Spline/SplineSeries.js",[e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e){let{line:i}=t.seriesTypes,{merge:s,pick:r}=e;class o extends i{getPointSpline(t,e,i){let s,o,n,a;let h=e.plotX||0,l=e.plotY||0,d=t[i-1],c=t[i+1];function p(t){return t&&!t.isNull&&!1!==t.doCurve&&!e.isCliff}if(p(d)&&p(c)){let t=d.plotX||0,i=d.plotY||0,r=c.plotX||0,p=c.plotY||0,u=0;s=(1.5*h+t)/2.5,o=(1.5*l+i)/2.5,n=(1.5*h+r)/2.5,a=(1.5*l+p)/2.5,n!==s&&(u=(a-o)*(n-h)/(n-s)+l-a),o+=u,a+=u,o>i&&o>l?(o=Math.max(i,l),a=2*l-o):o<i&&o<l&&(o=Math.min(i,l),a=2*l-o),a>p&&a>l?(a=Math.max(p,l),o=2*l-a):a<p&&a<l&&(a=Math.min(p,l),o=2*l-a),e.rightContX=n,e.rightContY=a,e.controlPoints={low:[s,o],high:[n,a]};}let u=["C",r(d.rightContX,d.plotX,0),r(d.rightContY,d.plotY,0),r(s,h,0),r(o,l,0),h,l];return d.rightContX=d.rightContY=void 0,u}}return o.defaultOptions=s(i.defaultOptions),t.registerSeriesType("spline",o),o}),i(e,"Series/AreaSpline/AreaSplineSeries.js",[e["Series/Spline/SplineSeries.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i){let{area:s,area:{prototype:r}}=e.seriesTypes,{extend:o,merge:n}=i;class a extends t{}return a.defaultOptions=n(t.defaultOptions,s.defaultOptions),o(a.prototype,{getGraphPath:r.getGraphPath,getStackPoints:r.getStackPoints,drawGraph:r.drawGraph}),e.registerSeriesType("areaspline",a),a}),i(e,"Series/Column/ColumnSeriesDefaults.js",[],function(){return {borderRadius:3,centerInCategory:!1,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,brightness:.1},select:{color:"#cccccc",borderColor:"#000000"}},dataLabels:{align:void 0,verticalAlign:void 0,y:void 0},startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"}}),i(e,"Series/Column/ColumnSeries.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Color/Color.js"],e["Series/Column/ColumnSeriesDefaults.js"],e["Core/Globals.js"],e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i,s,r,o,n){let{animObject:a}=t,{parse:h}=e,{noop:l}=s,{clamp:d,crisp:c,defined:p,extend:u,fireEvent:g,isArray:f,isNumber:m,merge:x,pick:y,objectEach:b}=n;class v extends r{animate(t){let e,i;let s=this,r=this.yAxis,o=r.pos,n=r.reversed,h=s.options,{clipOffset:l,inverted:c}=this.chart,p={},g=c?"translateX":"translateY";t&&l?(p.scaleY=.001,i=d(r.toPixels(h.threshold),o,o+r.len),c?(i+=n?-Math.floor(l[0]):Math.ceil(l[2]),p.translateX=i-r.len):(i+=n?Math.ceil(l[0]):-Math.floor(l[2]),p.translateY=i),s.clipBox&&s.setClip(),s.group.attr(p)):(e=Number(s.group.attr(g)),s.group.animate({scaleY:1},u(a(s.options.animation),{step:function(t,i){s.group&&(p[g]=e+i.pos*(o-e),s.group.attr(p));}})));}init(t,e){super.init.apply(this,arguments);let i=this;(t=i.chart).hasRendered&&t.series.forEach(function(t){t.type===i.type&&(t.isDirty=!0);});}getColumnMetrics(){let t=this,e=t.options,i=t.xAxis,s=t.yAxis,r=i.options.reversedStacks,o=i.reversed&&!r||!i.reversed&&r,n={},a,h=0;!1===e.grouping?h=1:t.chart.series.forEach(function(e){let i;let r=e.yAxis,o=e.options;e.type===t.type&&e.reserveSpace()&&s.len===r.len&&s.pos===r.pos&&(o.stacking&&"group"!==o.stacking?(void 0===n[a=e.stackKey]&&(n[a]=h++),i=n[a]):!1!==o.grouping&&(i=h++),e.columnIndex=i);});let l=Math.min(Math.abs(i.transA)*(!i.brokenAxis?.hasBreaks&&i.ordinal?.slope||e.pointRange||i.closestPointRange||i.tickInterval||1),i.len),d=l*e.groupPadding,c=(l-2*d)/(h||1),p=Math.min(e.maxPointWidth||i.len,y(e.pointWidth,c*(1-2*e.pointPadding))),u=(t.columnIndex||0)+(o?1:0);return t.columnMetrics={width:p,offset:(c-p)/2+(d+u*c-l/2)*(o?-1:1),paddedWidth:c,columnCount:h},t.columnMetrics}crispCol(t,e,i,s){let r=this.borderWidth,o=this.chart.inverted;return s=c(e+s,r,o)-(e=c(e,r,o)),this.options.crisp&&(i=c(t+i,r)-(t=c(t,r))),{x:t,y:e,width:i,height:s}}adjustForMissingColumns(t,e,i,s){if(!i.isNull&&s.columnCount>1){let r=this.xAxis.series.filter(t=>t.visible).map(t=>t.index),o=0,n=0;b(this.xAxis.stacking?.stacks,t=>{if("number"==typeof i.x){let e=t[i.x.toString()];if(e&&f(e.points[this.index])){let t=Object.keys(e.points).filter(t=>!t.match(",")&&e.points[t]&&e.points[t].length>1).map(parseFloat).filter(t=>-1!==r.indexOf(t)).sort((t,e)=>e-t);o=t.indexOf(this.index),n=t.length;}}}),o=this.xAxis.reversed?n-1-o:o;let a=(n-1)*s.paddedWidth+e;t=(i.plotX||0)+a/2-e-o*s.paddedWidth;}return t}translate(){let t=this,e=t.chart,i=t.options,s=t.dense=t.closestPointRange*t.xAxis.transA<2,o=t.borderWidth=y(i.borderWidth,s?0:1),n=t.xAxis,a=t.yAxis,h=i.threshold,l=y(i.minPointLength,5),c=t.getColumnMetrics(),u=c.width,f=t.pointXOffset=c.offset,x=t.dataMin,b=t.dataMax,v=t.translatedThreshold=a.getThreshold(h),S=t.barW=Math.max(u,1+2*o);i.pointPadding&&(S=Math.ceil(S)),r.prototype.translate.apply(t),t.points.forEach(function(s){let r=y(s.yBottom,v),o=999+Math.abs(r),g=s.plotX||0,C=d(s.plotY,-o,a.len+o),k,M=Math.min(C,r),w=Math.max(C,r)-M,T=u,A=g+f,P=S;l&&Math.abs(w)<l&&(w=l,k=!a.reversed&&!s.negative||a.reversed&&s.negative,m(h)&&m(b)&&s.y===h&&b<=h&&(a.min||0)<h&&(x!==b||(a.max||0)<=h)&&(k=!k,s.negative=!s.negative),M=Math.abs(M-v)>l?r-l:v-(k?l:0)),p(s.options.pointWidth)&&(A-=Math.round(((T=P=Math.ceil(s.options.pointWidth))-u)/2)),i.centerInCategory&&!i.stacking&&(A=t.adjustForMissingColumns(A,T,s,c)),s.barX=A,s.pointWidth=T,s.tooltipPos=e.inverted?[d(a.len+a.pos-e.plotLeft-C,a.pos-e.plotLeft,a.len+a.pos-e.plotLeft),n.len+n.pos-e.plotTop-A-P/2,w]:[n.left-e.plotLeft+A+P/2,d(C+a.pos-e.plotTop,a.pos-e.plotTop,a.len+a.pos-e.plotTop),w],s.shapeType=t.pointClass.prototype.shapeType||"roundedRect",s.shapeArgs=t.crispCol(A,s.isNull?v:M,P,s.isNull?0:w);}),g(this,"afterColumnTranslate");}drawGraph(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data");}pointAttribs(t,e){let i=this.options,s=this.pointAttrToOptions||{},r=s.stroke||"borderColor",o=s["stroke-width"]||"borderWidth",n,a,l,d=t&&t.color||this.color,c=t&&t[r]||i[r]||d,p=t&&t.options.dashStyle||i.dashStyle,u=t&&t[o]||i[o]||this[o]||0,g=y(t&&t.opacity,i.opacity,1);t&&this.zones.length&&(a=t.getZone(),d=t.options.color||a&&(a.color||t.nonZonedColor)||this.color,a&&(c=a.borderColor||c,p=a.dashStyle||p,u=a.borderWidth||u)),e&&t&&(l=(n=x(i.states[e],t.options.states&&t.options.states[e]||{})).brightness,d=n.color||void 0!==l&&h(d).brighten(n.brightness).get()||d,c=n[r]||c,u=n[o]||u,p=n.dashStyle||p,g=y(n.opacity,g));let f={fill:d,stroke:c,"stroke-width":u,opacity:g};return p&&(f.dashstyle=p),f}drawPoints(t=this.points){let e;let i=this,s=this.chart,r=i.options,o=s.renderer,n=r.animationLimit||250;t.forEach(function(t){let a=t.plotY,h=t.graphic,l=!!h,d=h&&s.pointCount<n?"animate":"attr";m(a)&&null!==t.y?(e=t.shapeArgs,h&&t.hasNewShapeType()&&(h=h.destroy()),i.enabledDataSorting&&(t.startXPos=i.xAxis.reversed?-(e&&e.width||0):i.xAxis.width),!h&&(t.graphic=h=o[t.shapeType](e).add(t.group||i.group),h&&i.enabledDataSorting&&s.hasRendered&&s.pointCount<n&&(h.attr({x:t.startXPos}),l=!0,d="animate")),h&&l&&h[d](x(e)),s.styledMode||h[d](i.pointAttribs(t,t.selected&&"select")).shadow(!1!==t.allowShadow&&r.shadow),h&&(h.addClass(t.getClassName(),!0),h.attr({visibility:t.visible?"inherit":"hidden"}))):h&&(t.graphic=h.destroy());});}drawTracker(t=this.points){let e;let i=this,s=i.chart,r=s.pointer,o=function(t){let e=r?.getPointFromEvent(t);r&&e&&i.options.enableMouseTracking&&(r.isDirectTouch=!0,e.onMouseOver(t));};t.forEach(function(t){e=f(t.dataLabels)?t.dataLabels:t.dataLabel?[t.dataLabel]:[],t.graphic&&(t.graphic.element.point=t),e.forEach(function(e){(e.div||e.element).point=t;});}),i._hasTracking||(i.trackerGroups.forEach(function(t){i[t]&&(i[t].addClass("highcharts-tracker").on("mouseover",o).on("mouseout",function(t){r?.onTrackerMouseOut(t);}).on("touchstart",o),!s.styledMode&&i.options.cursor&&i[t].css({cursor:i.options.cursor}));}),i._hasTracking=!0),g(this,"afterDrawTracker");}remove(){let t=this,e=t.chart;e.hasRendered&&e.series.forEach(function(e){e.type===t.type&&(e.isDirty=!0);}),r.prototype.remove.apply(t,arguments);}}return v.defaultOptions=x(r.defaultOptions,i),u(v.prototype,{directTouch:!0,getSymbol:l,negStacks:!0,trackerGroups:["group","dataLabelsGroup"]}),o.registerSeriesType("column",v),v}),i(e,"Core/Series/DataLabel.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Templating.js"],e["Core/Utilities.js"]],function(t,e,i){var s;let{getDeferredAnimation:r}=t,{format:o}=e,{defined:n,extend:a,fireEvent:h,isArray:l,isString:d,merge:c,objectEach:p,pick:u,pInt:g,splat:f}=i;return function(t){function e(){return v(this).some(t=>t?.enabled)}function i(t,e,i,s,r){let{chart:o,enabledDataSorting:h}=this,l=this.isCartesian&&o.inverted,d=t.plotX,p=t.plotY,g=i.rotation||0,f=n(d)&&n(p)&&o.isInsidePlot(d,Math.round(p),{inverted:l,paneCoordinates:!0,series:this}),m=0===g&&"justify"===u(i.overflow,h?"none":"justify"),x=this.visible&&!1!==t.visible&&n(d)&&(t.series.forceDL||h&&!m||f||u(i.inside,!!this.options.stacking)&&s&&o.isInsidePlot(d,l?s.x+1:s.y+s.height-1,{inverted:l,paneCoordinates:!0,series:this})),y=t.pos();if(x&&y){var b;let n=e.getBBox(),d=e.getBBox(void 0,0),p={right:1,center:.5}[i.align||0]||0,v={bottom:1,middle:.5}[i.verticalAlign||0]||0;if(s=a({x:y[0],y:Math.round(y[1]),width:0,height:0},s||{}),"plotEdges"===i.alignTo&&this.isCartesian&&(s[l?"x":"y"]=0,s[l?"width":"height"]=this.yAxis?.len||0),a(i,{width:n.width,height:n.height}),b=s,h&&this.xAxis&&!m&&this.setDataLabelStartPos(t,e,r,f,b),e.align(c(i,{width:d.width,height:d.height}),!1,s,!1),e.alignAttr.x+=p*(d.width-n.width),e.alignAttr.y+=v*(d.height-n.height),e[e.placed?"animate":"attr"]({x:e.alignAttr.x+(n.width-d.width)/2,y:e.alignAttr.y+(n.height-d.height)/2,rotationOriginX:(e.width||0)/2,rotationOriginY:(e.height||0)/2}),m&&s.height>=0)this.justifyDataLabel(e,i,e.alignAttr,n,s,r);else if(u(i.crop,!0)){let{x:t,y:i}=e.alignAttr;x=o.isInsidePlot(t,i,{paneCoordinates:!0,series:this})&&o.isInsidePlot(t+n.width-1,i+n.height-1,{paneCoordinates:!0,series:this});}i.shape&&!g&&e[r?"attr":"animate"]({anchorX:y[0],anchorY:y[1]});}r&&h&&(e.placed=!1),x||h&&!m?(e.show(),e.placed=!0):(e.hide(),e.placed=!1);}function s(){return this.plotGroup("dataLabelsGroup","data-labels",this.hasRendered?"inherit":"hidden",this.options.dataLabels.zIndex||6)}function m(t){let e=this.hasRendered||0,i=this.initDataLabelsGroup().attr({opacity:+e});return !e&&i&&(this.visible&&i.show(),this.options.animation?i.animate({opacity:1},t):i.attr({opacity:1})),i}function x(t){let e;t=t||this.points;let i=this,s=i.chart,a=i.options,l=s.renderer,{backgroundColor:c,plotBackgroundColor:m}=s.options.chart,x=l.getContrast(d(m)&&m||d(c)&&c||"#000000"),y=v(i),{animation:S,defer:C}=y[0],k=C?r(s,S,i):{defer:0,duration:0};h(this,"drawDataLabels"),i.hasDataLabels?.()&&(e=this.initDataLabels(k),t.forEach(t=>{let r=t.dataLabels||[];f(b(y,t.dlOptions||t.options?.dataLabels)).forEach((c,f)=>{let m=c.enabled&&(t.visible||t.dataLabelOnHidden)&&(!t.isNull||t.dataLabelOnNull)&&function(t,e){let i=e.filter;if(i){let e=i.operator,s=t[i.property],r=i.value;return ">"===e&&s>r||"<"===e&&s<r||">="===e&&s>=r||"<="===e&&s<=r||"=="===e&&s==r||"==="===e&&s===r||"!="===e&&s!=r||"!=="===e&&s!==r}return !0}(t,c),{backgroundColor:y,borderColor:b,distance:v,style:S={}}=c,C,k,M,w,T={},A=r[f],P=!A,L;m&&(k=u(c[t.formatPrefix+"Format"],c.format),C=t.getLabelConfig(),M=n(k)?o(k,C,s):(c[t.formatPrefix+"Formatter"]||c.formatter).call(C,c),w=c.rotation,!s.styledMode&&(S.color=u(c.color,S.color,d(i.color)?i.color:void 0,"#000000"),"contrast"===S.color?("none"!==y&&(L=y),t.contrastColor=l.getContrast("auto"!==L&&L||t.color||i.color),S.color=L||!n(v)&&c.inside||0>g(v||0)||a.stacking?t.contrastColor:x):delete t.contrastColor,a.cursor&&(S.cursor=a.cursor)),T={r:c.borderRadius||0,rotation:w,padding:c.padding,zIndex:1},s.styledMode||(T.fill="auto"===y?t.color:y,T.stroke="auto"===b?t.color:b,T["stroke-width"]=c.borderWidth),p(T,(t,e)=>{void 0===t&&delete T[e];})),!A||m&&n(M)&&!!A.div==!!c.useHTML&&(A.rotation&&c.rotation||A.rotation===c.rotation)||(A=void 0,P=!0),m&&n(M)&&(A?T.text=M:(A=l.label(M,0,0,c.shape,void 0,void 0,c.useHTML,void 0,"data-label")).addClass(" highcharts-data-label-color-"+t.colorIndex+" "+(c.className||"")+(c.useHTML?" highcharts-tracker":"")),A&&(A.options=c,A.attr(T),s.styledMode?S.width&&A.css({width:S.width,textOverflow:S.textOverflow}):A.css(S).shadow(c.shadow),h(A,"beforeAddingDataLabel",{labelOptions:c,point:t}),A.added||A.add(e),i.alignDataLabel(t,A,c,void 0,P),A.isActive=!0,r[f]&&r[f]!==A&&r[f].destroy(),r[f]=A));});let c=r.length;for(;c--;)r[c]&&r[c].isActive?r[c].isActive=!1:(r[c]?.destroy(),r.splice(c,1));t.dataLabel=r[0],t.dataLabels=r;})),h(this,"afterDrawDataLabels");}function y(t,e,i,s,r,o){let n=this.chart,a=e.align,h=e.verticalAlign,l=t.box?0:t.padding||0,d=n.inverted?this.yAxis:this.xAxis,c=d?d.left-n.plotLeft:0,p=n.inverted?this.xAxis:this.yAxis,u=p?p.top-n.plotTop:0,{x:g=0,y:f=0}=e,m,x;return (m=(i.x||0)+l+c)<0&&("right"===a&&g>=0?(e.align="left",e.inside=!0):g-=m,x=!0),(m=(i.x||0)+s.width-l+c)>n.plotWidth&&("left"===a&&g<=0?(e.align="right",e.inside=!0):g+=n.plotWidth-m,x=!0),(m=i.y+l+u)<0&&("bottom"===h&&f>=0?(e.verticalAlign="top",e.inside=!0):f-=m,x=!0),(m=(i.y||0)+s.height-l+u)>n.plotHeight&&("top"===h&&f<=0?(e.verticalAlign="bottom",e.inside=!0):f+=n.plotHeight-m,x=!0),x&&(e.x=g,e.y=f,t.placed=!o,t.align(e,void 0,r)),x}function b(t,e){let i=[],s;if(l(t)&&!l(e))i=t.map(function(t){return c(t,e)});else if(l(e)&&!l(t))i=e.map(function(e){return c(t,e)});else if(l(t)||l(e)){if(l(t)&&l(e))for(s=Math.max(t.length,e.length);s--;)i[s]=c(t[s],e[s]);}else i=c(t,e);return i}function v(t){let e=t.chart.options.plotOptions;return f(b(b(e?.series?.dataLabels,e?.[t.type]?.dataLabels),t.options.dataLabels))}function S(t,e,i,s,r){let o=this.chart,n=o.inverted,a=this.xAxis,h=a.reversed,l=((n?e.height:e.width)||0)/2,d=t.pointWidth,c=d?d/2:0;e.startXPos=n?r.x:h?-l-c:a.width-l+c,e.startYPos=n?h?this.yAxis.height-l+c:-l-c:r.y,s?"hidden"===e.visibility&&(e.show(),e.attr({opacity:0}).animate({opacity:1})):e.attr({opacity:1}).animate({opacity:0},void 0,e.hide),o.hasRendered&&(i&&e.attr({x:e.startXPos,y:e.startYPos}),e.placed=!0);}t.compose=function(t){let r=t.prototype;r.initDataLabels||(r.initDataLabels=m,r.initDataLabelsGroup=s,r.alignDataLabel=i,r.drawDataLabels=x,r.justifyDataLabel=y,r.setDataLabelStartPos=S,r.hasDataLabels=e);};}(s||(s={})),s}),i(e,"Series/Column/ColumnDataLabel.js",[e["Core/Series/DataLabel.js"],e["Core/Globals.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i,s){var r;let{composed:o}=e,{series:n}=i,{merge:a,pick:h,pushUnique:l}=s;return function(e){function i(t,e,i,s,r){let o=this.chart.inverted,l=t.series,d=(l.xAxis?l.xAxis.len:this.chart.plotSizeX)||0,c=(l.yAxis?l.yAxis.len:this.chart.plotSizeY)||0,p=t.dlBox||t.shapeArgs,u=h(t.below,t.plotY>h(this.translatedThreshold,c)),g=h(i.inside,!!this.options.stacking);if(p){if(s=a(p),!("allow"===i.overflow&&!1===i.crop)){s.y<0&&(s.height+=s.y,s.y=0);let t=s.y+s.height-c;t>0&&t<s.height-1&&(s.height-=t);}o&&(s={x:c-s.y-s.height,y:d-s.x-s.width,width:s.height,height:s.width}),g||(o?(s.x+=u?0:s.width,s.width=0):(s.y+=u?s.height:0,s.height=0));}i.align=h(i.align,!o||g?"center":u?"right":"left"),i.verticalAlign=h(i.verticalAlign,o||g?"middle":u?"top":"bottom"),n.prototype.alignDataLabel.call(this,t,e,i,s,r),i.inside&&t.contrastColor&&e.css({color:t.contrastColor});}e.compose=function(e){t.compose(n),l(o,"ColumnDataLabel")&&(e.prototype.alignDataLabel=i);};}(r||(r={})),r}),i(e,"Series/Bar/BarSeries.js",[e["Series/Column/ColumnSeries.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i){let{extend:s,merge:r}=i;class o extends t{}return o.defaultOptions=r(t.defaultOptions,{}),s(o.prototype,{inverted:!0}),e.registerSeriesType("bar",o),o}),i(e,"Series/Scatter/ScatterSeriesDefaults.js",[],function(){return {lineWidth:0,findNearestPointBy:"xy",jitter:{x:0,y:0},marker:{enabled:!0},tooltip:{headerFormat:'<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',pointFormat:"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}}}),i(e,"Series/Scatter/ScatterSeries.js",[e["Series/Scatter/ScatterSeriesDefaults.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i){let{column:s,line:r}=e.seriesTypes,{addEvent:o,extend:n,merge:a}=i;class h extends r{applyJitter(){let t=this,e=this.options.jitter,i=this.points.length;e&&this.points.forEach(function(s,r){["x","y"].forEach(function(o,n){if(e[o]&&!s.isNull){let a=`plot${o.toUpperCase()}`,h=t[`${o}Axis`],l=e[o]*h.transA;if(h&&!h.logarithmic){let t=Math.max(0,(s[a]||0)-l),e=Math.min(h.len,(s[a]||0)+l);s[a]=t+(e-t)*function(t){let e=1e4*Math.sin(t);return e-Math.floor(e)}(r+n*i),"x"===o&&(s.clientX=s.plotX);}}});});}drawGraph(){this.options.lineWidth?super.drawGraph():this.graph&&(this.graph=this.graph.destroy());}}return h.defaultOptions=a(r.defaultOptions,t),n(h.prototype,{drawTracker:s.prototype.drawTracker,sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group","markerGroup","dataLabelsGroup"]}),o(h,"afterTranslate",function(){this.applyJitter();}),e.registerSeriesType("scatter",h),h}),i(e,"Series/CenteredUtilities.js",[e["Core/Globals.js"],e["Core/Series/Series.js"],e["Core/Utilities.js"]],function(t,e,i){var s,r;let{deg2rad:o}=t,{fireEvent:n,isNumber:a,pick:h,relativeLength:l}=i;return (r=s||(s={})).getCenter=function(){let t=this.options,i=this.chart,s=2*(t.slicedOffset||0),r=i.plotWidth-2*s,o=i.plotHeight-2*s,d=t.center,c=Math.min(r,o),p=t.thickness,u,g=t.size,f=t.innerSize||0,m,x;"string"==typeof g&&(g=parseFloat(g)),"string"==typeof f&&(f=parseFloat(f));let y=[h(d[0],"50%"),h(d[1],"50%"),h(g&&g<0?void 0:t.size,"100%"),h(f&&f<0?void 0:t.innerSize||0,"0%")];for(!i.angular||this instanceof e||(y[3]=0),m=0;m<4;++m)x=y[m],u=m<2||2===m&&/%$/.test(x),y[m]=l(x,[r,o,c,y[2]][m])+(u?s:0);return y[3]>y[2]&&(y[3]=y[2]),a(p)&&2*p<y[2]&&p>0&&(y[3]=y[2]-2*p),n(this,"afterGetCenter",{positions:y}),y},r.getStartAndEndRadians=function(t,e){let i=a(t)?t:0,s=a(e)&&e>i&&e-i<360?e:i+360;return {start:o*(i+-90),end:o*(s+-90)}},s}),i(e,"Series/Pie/PiePoint.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Series/Point.js"],e["Core/Utilities.js"]],function(t,e,i){let{setAnimation:s}=t,{addEvent:r,defined:o,extend:n,isNumber:a,pick:h,relativeLength:l}=i;class d extends e{getConnectorPath(t){let e=t.dataLabelPosition,i=t.options||{},s=i.connectorShape,r=this.connectorShapes[s]||s;return e&&r.call(this,{...e.computed,alignment:e.alignment},e.connectorPosition,i)||[]}getTranslate(){return this.sliced&&this.slicedTranslation||{translateX:0,translateY:0}}haloPath(t){let e=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(e.x,e.y,e.r+t,e.r+t,{innerR:e.r-1,start:e.start,end:e.end,borderRadius:e.borderRadius})}constructor(t,e,i){super(t,e,i),this.half=0,this.name??(this.name="Slice");let s=t=>{this.slice("select"===t.type);};r(this,"select",s),r(this,"unselect",s);}isValid(){return a(this.y)&&this.y>=0}setVisible(t,e=!0){t!==this.visible&&this.update({visible:t??!this.visible},e,void 0,!1);}slice(t,e,i){let r=this.series;s(i,r.chart),e=h(e,!0),this.sliced=this.options.sliced=t=o(t)?t:!this.sliced,r.options.data[r.data.indexOf(this)]=this.options,this.graphic&&this.graphic.animate(this.getTranslate());}}return n(d.prototype,{connectorShapes:{fixedOffset:function(t,e,i){let s=e.breakAt,r=e.touchingSliceAt,o=i.softConnector?["C",t.x+("left"===t.alignment?-5:5),t.y,2*s.x-r.x,2*s.y-r.y,s.x,s.y]:["L",s.x,s.y];return [["M",t.x,t.y],o,["L",r.x,r.y]]},straight:function(t,e){let i=e.touchingSliceAt;return [["M",t.x,t.y],["L",i.x,i.y]]},crookedLine:function(t,e,i){let{breakAt:s,touchingSliceAt:r}=e,{series:o}=this,[n,a,h]=o.center,d=h/2,{plotLeft:c,plotWidth:p}=o.chart,u="left"===t.alignment,{x:g,y:f}=t,m=s.x;if(i.crookDistance){let t=l(i.crookDistance,1);m=u?n+d+(p+c-n-d)*(1-t):c+(n-d)*t;}else m=n+(a-f)*Math.tan((this.angle||0)-Math.PI/2);let x=[["M",g,f]];return (u?m<=g&&m>=s.x:m>=g&&m<=s.x)&&x.push(["L",m,f]),x.push(["L",s.x,s.y],["L",r.x,r.y]),x}}}),d}),i(e,"Series/Pie/PieSeriesDefaults.js",[],function(){return {borderRadius:3,center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{connectorPadding:5,connectorShape:"crookedLine",crookDistance:void 0,distance:30,enabled:!0,formatter:function(){return this.point.isNull?void 0:this.point.name},softConnector:!0,x:0},fillColor:void 0,ignoreHiddenPoint:!0,inactiveOtherPoints:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:"#ffffff",borderWidth:1,lineWidth:void 0,states:{hover:{brightness:.1}}}}),i(e,"Series/Pie/PieSeries.js",[e["Series/CenteredUtilities.js"],e["Series/Column/ColumnSeries.js"],e["Core/Globals.js"],e["Series/Pie/PiePoint.js"],e["Series/Pie/PieSeriesDefaults.js"],e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Renderer/SVG/Symbols.js"],e["Core/Utilities.js"]],function(t,e,i,s,r,o,n,a,h){let{getStartAndEndRadians:l}=t,{noop:d}=i,{clamp:c,extend:p,fireEvent:u,merge:g,pick:f}=h;class m extends o{animate(t){let e=this,i=e.points,s=e.startAngleRad;t||i.forEach(function(t){let i=t.graphic,r=t.shapeArgs;i&&r&&(i.attr({r:f(t.startR,e.center&&e.center[3]/2),start:s,end:s}),i.animate({r:r.r,start:r.start,end:r.end},e.options.animation));});}drawEmpty(){let t,e;let i=this.startAngleRad,s=this.endAngleRad,r=this.options;0===this.total&&this.center?(t=this.center[0],e=this.center[1],this.graph||(this.graph=this.chart.renderer.arc(t,e,this.center[1]/2,0,i,s).addClass("highcharts-empty-series").add(this.group)),this.graph.attr({d:a.arc(t,e,this.center[2]/2,0,{start:i,end:s,innerR:this.center[3]/2})}),this.chart.styledMode||this.graph.attr({"stroke-width":r.borderWidth,fill:r.fillColor||"none",stroke:r.color||"#cccccc"})):this.graph&&(this.graph=this.graph.destroy());}drawPoints(){let t=this.chart.renderer;this.points.forEach(function(e){e.graphic&&e.hasNewShapeType()&&(e.graphic=e.graphic.destroy()),e.graphic||(e.graphic=t[e.shapeType](e.shapeArgs).add(e.series.group),e.delayedRendering=!0);});}generatePoints(){super.generatePoints(),this.updateTotals();}getX(t,e,i,s){let r=this.center,o=this.radii?this.radii[i.index]||0:r[2]/2,n=s.dataLabelPosition,a=n?.distance||0,h=Math.asin(c((t-r[1])/(o+a),-1,1));return r[0]+Math.cos(h)*(o+a)*(e?-1:1)+(a>0?(e?-1:1)*(s.padding||0):0)}hasData(){return !!this.processedXData.length}redrawPoints(){let t,e,i,s;let r=this,o=r.chart;this.drawEmpty(),r.group&&!o.styledMode&&r.group.shadow(r.options.shadow),r.points.forEach(function(n){let a={};e=n.graphic,!n.isNull&&e?(s=n.shapeArgs,t=n.getTranslate(),o.styledMode||(i=r.pointAttribs(n,n.selected&&"select")),n.delayedRendering?(e.setRadialReference(r.center).attr(s).attr(t),o.styledMode||e.attr(i).attr({"stroke-linejoin":"round"}),n.delayedRendering=!1):(e.setRadialReference(r.center),o.styledMode||g(!0,a,i),g(!0,a,s,t),e.animate(a)),e.attr({visibility:n.visible?"inherit":"hidden"}),e.addClass(n.getClassName(),!0)):e&&(n.graphic=e.destroy());});}sortByAngle(t,e){t.sort(function(t,i){return void 0!==t.angle&&(i.angle-t.angle)*e});}translate(t){u(this,"translate"),this.generatePoints();let e=this.options,i=e.slicedOffset,s=l(e.startAngle,e.endAngle),r=this.startAngleRad=s.start,o=(this.endAngleRad=s.end)-r,n=this.points,a=e.ignoreHiddenPoint,h=n.length,d,c,p,g,f,m,x,y=0;for(t||(this.center=t=this.getCenter()),m=0;m<h;m++){x=n[m],d=r+y*o,x.isValid()&&(!a||x.visible)&&(y+=x.percentage/100),c=r+y*o;let e={x:t[0],y:t[1],r:t[2]/2,innerR:t[3]/2,start:Math.round(1e3*d)/1e3,end:Math.round(1e3*c)/1e3};x.shapeType="arc",x.shapeArgs=e,(p=(c+d)/2)>1.5*Math.PI?p-=2*Math.PI:p<-Math.PI/2&&(p+=2*Math.PI),x.slicedTranslation={translateX:Math.round(Math.cos(p)*i),translateY:Math.round(Math.sin(p)*i)},g=Math.cos(p)*t[2]/2,f=Math.sin(p)*t[2]/2,x.tooltipPos=[t[0]+.7*g,t[1]+.7*f],x.half=p<-Math.PI/2||p>Math.PI/2?1:0,x.angle=p;}u(this,"afterTranslate");}updateTotals(){let t=this.points,e=t.length,i=this.options.ignoreHiddenPoint,s,r,o=0;for(s=0;s<e;s++)(r=t[s]).isValid()&&(!i||r.visible)&&(o+=r.y);for(s=0,this.total=o;s<e;s++)(r=t[s]).percentage=o>0&&(r.visible||!i)?r.y/o*100:0,r.total=o;}}return m.defaultOptions=g(o.defaultOptions,r),p(m.prototype,{axisTypes:[],directTouch:!0,drawGraph:void 0,drawTracker:e.prototype.drawTracker,getCenter:t.getCenter,getSymbol:d,invertible:!1,isCartesian:!1,noSharedTooltip:!0,pointAttribs:e.prototype.pointAttribs,pointClass:s,requireSorting:!1,searchPoint:d,trackerGroups:["group","dataLabelsGroup"]}),n.registerSeriesType("pie",m),m}),i(e,"Series/Pie/PieDataLabel.js",[e["Core/Series/DataLabel.js"],e["Core/Globals.js"],e["Core/Renderer/RendererUtilities.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,i,s,r){var o;let{composed:n,noop:a}=e,{distribute:h}=i,{series:l}=s,{arrayMax:d,clamp:c,defined:p,pick:u,pushUnique:g,relativeLength:f}=r;return function(e){let i={radialDistributionY:function(t,e){return (e.dataLabelPosition?.top||0)+t.distributeBox.pos},radialDistributionX:function(t,e,i,s,r){let o=r.dataLabelPosition;return t.getX(i<(o?.top||0)+2||i>(o?.bottom||0)-2?s:i,e.half,e,r)},justify:function(t,e,i,s){return s[0]+(t.half?-1:1)*(i+(e.dataLabelPosition?.distance||0))},alignToPlotEdges:function(t,e,i,s){let r=t.getBBox().width;return e?r+s:i-r-s},alignToConnectors:function(t,e,i,s){let r=0,o;return t.forEach(function(t){(o=t.dataLabel.getBBox().width)>r&&(r=o);}),e?r+s:i-r-s}};function s(t,e){let{center:i,options:s}=this,r=i[2]/2,o=t.angle||0,n=Math.cos(o),a=Math.sin(o),h=i[0]+n*r,l=i[1]+a*r,d=Math.min((s.slicedOffset||0)+(s.borderWidth||0),e/5);return {natural:{x:h+n*e,y:l+a*e},computed:{},alignment:e<0?"center":t.half?"right":"left",connectorPosition:{breakAt:{x:h+n*d,y:l+a*d},touchingSliceAt:{x:h,y:l}},distance:e}}function r(){let t=this,e=t.points,i=t.chart,s=i.plotWidth,r=i.plotHeight,o=i.plotLeft,n=Math.round(i.chartWidth/3),a=t.center,c=a[2]/2,g=a[1],m=[[],[]],x=[0,0,0,0],y=t.dataLabelPositioners,b,v,S,C=0;t.visible&&t.hasDataLabels?.()&&(e.forEach(t=>{(t.dataLabels||[]).forEach(t=>{t.shortened&&(t.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),t.shortened=!1);});}),l.prototype.drawDataLabels.apply(t),e.forEach(t=>{(t.dataLabels||[]).forEach((e,i)=>{let s=a[2]/2,r=e.options,o=f(r?.distance||0,s);0===i&&m[t.half].push(t),!p(r?.style?.width)&&e.getBBox().width>n&&(e.css({width:Math.round(.7*n)+"px"}),e.shortened=!0),e.dataLabelPosition=this.getDataLabelPosition(t,o),C=Math.max(C,o);});}),m.forEach((e,n)=>{let l=e.length,d=[],f,m,b=0,k;l&&(t.sortByAngle(e,n-.5),C>0&&(f=Math.max(0,g-c-C),m=Math.min(g+c+C,i.plotHeight),e.forEach(t=>{(t.dataLabels||[]).forEach(e=>{let s=e.dataLabelPosition;s&&s.distance>0&&(s.top=Math.max(0,g-c-s.distance),s.bottom=Math.min(g+c+s.distance,i.plotHeight),b=e.getBBox().height||21,e.lineHeight=i.renderer.fontMetrics(e.text||e).h+2*e.padding,t.distributeBox={target:(e.dataLabelPosition?.natural.y||0)-s.top+e.lineHeight/2,size:b,rank:t.y},d.push(t.distributeBox));});}),h(d,k=m+b-f,k/5)),e.forEach(i=>{(i.dataLabels||[]).forEach(h=>{let l=h.options||{},g=i.distributeBox,f=h.dataLabelPosition,m=f?.natural.y||0,b=l.connectorPadding||0,C=h.lineHeight||21,k=(C-h.getBBox().height)/2,M=0,w=m,T="inherit";if(f){if(d&&p(g)&&f.distance>0&&(void 0===g.pos?T="hidden":(S=g.size,w=y.radialDistributionY(i,h))),l.justify)M=y.justify(i,h,c,a);else switch(l.alignTo){case"connectors":M=y.alignToConnectors(e,n,s,o);break;case"plotEdges":M=y.alignToPlotEdges(h,n,s,o);break;default:M=y.radialDistributionX(t,i,w-k,m,h);}if(f.attribs={visibility:T,align:f.alignment},f.posAttribs={x:M+(l.x||0)+(({left:b,right:-b})[f.alignment]||0),y:w+(l.y||0)-C/2},f.computed.x=M,f.computed.y=w-k,u(l.crop,!0)){let t;M-(v=h.getBBox().width)<b&&1===n?(t=Math.round(v-M+b),x[3]=Math.max(t,x[3])):M+v>s-b&&0===n&&(t=Math.round(M+v-s+b),x[1]=Math.max(t,x[1])),w-S/2<0?x[0]=Math.max(Math.round(-w+S/2),x[0]):w+S/2>r&&(x[2]=Math.max(Math.round(w+S/2-r),x[2])),f.sideOverflow=t;}}});}));}),(0===d(x)||this.verifyDataLabelOverflow(x))&&(this.placeDataLabels(),this.points.forEach(e=>{(e.dataLabels||[]).forEach(s=>{let{connectorColor:r,connectorWidth:o=1}=s.options||{},n=s.dataLabelPosition;if(o){let a;b=s.connector,n&&n.distance>0?(a=!b,b||(s.connector=b=i.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-"+e.colorIndex+(e.className?" "+e.className:"")).add(t.dataLabelsGroup)),i.styledMode||b.attr({"stroke-width":o,stroke:r||e.color||"#666666"}),b[a?"attr":"animate"]({d:e.getConnectorPath(s)}),b.attr({visibility:n.attribs?.visibility})):b&&(s.connector=b.destroy());}});})));}function o(){this.points.forEach(t=>{(t.dataLabels||[]).forEach(t=>{let e=t.dataLabelPosition;e?(e.sideOverflow&&(t.css({width:Math.max(t.getBBox().width-e.sideOverflow,0)+"px",textOverflow:(t.options?.style||{}).textOverflow||"ellipsis"}),t.shortened=!0),t.attr(e.attribs),t[t.moved?"animate":"attr"](e.posAttribs),t.moved=!0):t&&t.attr({y:-9999});}),delete t.distributeBox;},this);}function m(t){let e=this.center,i=this.options,s=i.center,r=i.minSize||80,o=r,n=null!==i.size;return !n&&(null!==s[0]?o=Math.max(e[2]-Math.max(t[1],t[3]),r):(o=Math.max(e[2]-t[1]-t[3],r),e[0]+=(t[3]-t[1])/2),null!==s[1]?o=c(o,r,e[2]-Math.max(t[0],t[2])):(o=c(o,r,e[2]-t[0]-t[2]),e[1]+=(t[0]-t[2])/2),o<e[2]?(e[2]=o,e[3]=Math.min(i.thickness?Math.max(0,o-2*i.thickness):Math.max(0,f(i.innerSize||0,o)),o),this.translate(e),this.drawDataLabels&&this.drawDataLabels()):n=!0),n}e.compose=function(e){if(t.compose(l),g(n,"PieDataLabel")){let t=e.prototype;t.dataLabelPositioners=i,t.alignDataLabel=a,t.drawDataLabels=r,t.getDataLabelPosition=s,t.placeDataLabels=o,t.verifyDataLabelOverflow=m;}};}(o||(o={})),o}),i(e,"Core/Geometry/GeometryUtilities.js",[],function(){var t,e;return (e=t||(t={})).getCenterOfPoints=function(t){let e=t.reduce((t,e)=>(t.x+=e.x,t.y+=e.y,t),{x:0,y:0});return {x:e.x/t.length,y:e.y/t.length}},e.getDistanceBetweenPoints=function(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))},e.getAngleBetweenPoints=function(t,e){return Math.atan2(e.x-t.x,e.y-t.y)},e.pointInPolygon=function({x:t,y:e},i){let s=i.length,r,o,n=!1;for(r=0,o=s-1;r<s;o=r++){let[s,a]=i[r],[h,l]=i[o];a>e!=l>e&&t<(h-s)*(e-a)/(l-a)+s&&(n=!n);}return n},t}),i(e,"Extensions/OverlappingDataLabels.js",[e["Core/Geometry/GeometryUtilities.js"],e["Core/Utilities.js"]],function(t,e){let{pointInPolygon:i}=t,{addEvent:s,fireEvent:r,objectEach:o,pick:n}=e;function a(t){let e=t.length,s=(t,e)=>!(e.x>=t.x+t.width||e.x+e.width<=t.x||e.y>=t.y+t.height||e.y+e.height<=t.y),o=(t,e)=>{for(let s of t)if(i({x:s[0],y:s[1]},e))return !0;return !1},n,a,l,d,c,p=!1;for(let i=0;i<e;i++)(n=t[i])&&(n.oldOpacity=n.opacity,n.newOpacity=1,n.absoluteBox=function(t){if(t&&(!t.alignAttr||t.placed)){let e=t.box?0:t.padding||0,i=t.alignAttr||{x:t.attr("x"),y:t.attr("y")},s=t.getBBox();return t.width=s.width,t.height=s.height,{x:i.x+(t.parentGroup?.translateX||0)+e,y:i.y+(t.parentGroup?.translateY||0)+e,width:(t.width||0)-2*e,height:(t.height||0)-2*e,polygon:s?.polygon}}}(n));t.sort((t,e)=>(e.labelrank||0)-(t.labelrank||0));for(let i=0;i<e;++i){d=(a=t[i])&&a.absoluteBox;let r=d?.polygon;for(let n=i+1;n<e;++n){c=(l=t[n])&&l.absoluteBox;let e=!1;if(d&&c&&a!==l&&0!==a.newOpacity&&0!==l.newOpacity&&"hidden"!==a.visibility&&"hidden"!==l.visibility){let t=c.polygon;if(r&&t&&r!==t?o(r,t)&&(e=!0):s(d,c)&&(e=!0),e){let t=a.labelrank<l.labelrank?a:l,e=t.text;t.newOpacity=0,e?.element.querySelector("textPath")&&e.hide();}}}}for(let e of t)h(e,this)&&(p=!0);p&&r(this,"afterHideAllOverlappingLabels");}function h(t,e){let i,s,o=!1;return t&&(s=t.newOpacity,t.oldOpacity!==s&&(t.hasClass("highcharts-data-label")?(t[s?"removeClass":"addClass"]("highcharts-data-label-hidden"),i=function(){e.styledMode||t.css({pointerEvents:s?"auto":"none"});},o=!0,t[t.isOld?"animate":"attr"]({opacity:s},void 0,i),r(e,"afterHideOverlappingLabel")):t.attr({opacity:s})),t.isOld=!0),o}function l(){let t=this,e=[];for(let i of t.labelCollectors||[])e=e.concat(i());for(let i of t.yAxis||[])i.stacking&&i.options.stackLabels&&!i.options.stackLabels.allowOverlap&&o(i.stacking.stacks,t=>{o(t,t=>{t.label&&e.push(t.label);});});for(let i of t.series||[])if(i.visible&&i.hasDataLabels?.()){let s=i=>{for(let s of i)s.visible&&(s.dataLabels||[]).forEach(i=>{let r=i.options||{};i.labelrank=n(r.labelrank,s.labelrank,s.shapeArgs?.height),r.allowOverlap??Number(r.distance)>0?(i.oldOpacity=i.opacity,i.newOpacity=1,h(i,t)):e.push(i);});};s(i.nodes||[]),s(i.points);}this.hideOverlappingLabels(e);}return {compose:function(t){let e=t.prototype;e.hideOverlappingLabels||(e.hideOverlappingLabels=a,s(t,"render",l));}}}),i(e,"Extensions/BorderRadius.js",[e["Core/Defaults.js"],e["Core/Globals.js"],e["Core/Utilities.js"]],function(t,e,i){let{defaultOptions:s}=t,{noop:r}=e,{addEvent:o,extend:n,isObject:a,merge:h,relativeLength:l}=i,d={radius:0,scope:"stack",where:void 0},c=r,p=r;function u(t,e,i,s,r={}){let o=c(t,e,i,s,r),{innerR:n=0,r:a=i,start:h=0,end:d=0}=r;if(r.open||!r.borderRadius)return o;let p=d-h,g=Math.sin(p/2),f=Math.max(Math.min(l(r.borderRadius||0,a-n),(a-n)/2,a*g/(1+g)),0),m=Math.min(f,p/Math.PI*2*n),x=o.length-1;for(;x--;)!function(t,e,i){let s,r,o;let n=t[e],a=t[e+1];if("Z"===a[0]&&(a=t[0]),("M"===n[0]||"L"===n[0])&&"A"===a[0]?(s=n,r=a,o=!0):"A"===n[0]&&("M"===a[0]||"L"===a[0])&&(s=a,r=n),s&&r&&r.params){let n=r[1],a=r[5],h=r.params,{start:l,end:d,cx:c,cy:p}=h,u=a?n-i:n+i,g=u?Math.asin(i/u):0,f=a?g:-g,m=Math.cos(g)*u;o?(h.start=l+f,s[1]=c+m*Math.cos(l),s[2]=p+m*Math.sin(l),t.splice(e+1,0,["A",i,i,0,0,1,c+n*Math.cos(h.start),p+n*Math.sin(h.start)])):(h.end=d-f,r[6]=c+n*Math.cos(h.end),r[7]=p+n*Math.sin(h.end),t.splice(e+1,0,["A",i,i,0,0,1,c+m*Math.cos(d),p+m*Math.sin(d)])),r[4]=Math.abs(h.end-h.start)<Math.PI?0:1;}}(o,x,x>1?m:f);return o}function g(){if(this.options.borderRadius&&!(this.chart.is3d&&this.chart.is3d())){let{options:t,yAxis:e}=this,i="percent"===t.stacking,r=s.plotOptions?.[this.type]?.borderRadius,o=f(t.borderRadius,a(r)?r:{}),h=e.options.reversed;for(let s of this.points){let{shapeArgs:r}=s;if("roundedRect"===s.shapeType&&r){let{width:a=0,height:d=0,y:c=0}=r,p=c,u=d;if("stack"===o.scope&&s.stackTotal){let r=e.translate(i?100:s.stackTotal,!1,!0,!1,!0),o=e.translate(t.threshold||0,!1,!0,!1,!0),n=this.crispCol(0,Math.min(r,o),0,Math.abs(r-o));p=n.y,u=n.height;}let g=(s.negative?-1:1)*(h?-1:1)==-1,f=o.where;!f&&this.is("waterfall")&&Math.abs((s.yBottom||0)-(this.translatedThreshold||0))>this.borderWidth&&(f="all"),f||(f="end");let m=Math.min(l(o.radius,a),a/2,"all"===f?d/2:1/0)||0;"end"===f&&(g&&(p-=m),u+=m),n(r,{brBoxHeight:u,brBoxY:p,r:m});}}}}function f(t,e){return a(t)||(t={radius:t||0}),h(d,e,t)}function m(){let t=f(this.options.borderRadius);for(let e of this.points){let i=e.shapeArgs;i&&(i.borderRadius=l(t.radius,(i.r||0)-(i.innerR||0)));}}function x(t,e,i,s,r={}){let o=p(t,e,i,s,r),{r:n=0,brBoxHeight:a=s,brBoxY:h=e}=r,l=e-h,d=h+a-(e+s),c=l-n>-.1?0:n,u=d-n>-.1?0:n,g=Math.max(c&&l,0),f=Math.max(u&&d,0),m=[t+c,e],y=[t+i-c,e],b=[t+i,e+c],v=[t+i,e+s-u],S=[t+i-u,e+s],C=[t+u,e+s],k=[t,e+s-u],M=[t,e+c],w=(t,e)=>Math.sqrt(Math.pow(t,2)-Math.pow(e,2));if(g){let t=w(c,c-g);m[0]-=t,y[0]+=t,b[1]=M[1]=e+c-g;}if(s<c-g){let r=w(c,c-g-s);b[0]=v[0]=t+i-c+r,S[0]=Math.min(b[0],S[0]),C[0]=Math.max(v[0],C[0]),k[0]=M[0]=t+c-r,b[1]=M[1]=e+s;}if(f){let t=w(u,u-f);S[0]+=t,C[0]-=t,v[1]=k[1]=e+s-u+f;}if(s<u-f){let r=w(u,u-f-s);b[0]=v[0]=t+i-u+r,y[0]=Math.min(b[0],y[0]),m[0]=Math.max(v[0],m[0]),k[0]=M[0]=t+u-r,v[1]=k[1]=e;}return o.length=0,o.push(["M",...m],["L",...y],["A",c,c,0,0,1,...b],["L",...v],["A",u,u,0,0,1,...S],["L",...C],["A",u,u,0,0,1,...k],["L",...M],["A",c,c,0,0,1,...m],["Z"]),o}return {compose:function(t,e,i){let s=t.types.pie;if(!e.symbolCustomAttribs.includes("borderRadius")){let r=i.prototype.symbols;o(t,"afterColumnTranslate",g,{order:9}),o(s,"afterTranslate",m),e.symbolCustomAttribs.push("borderRadius","brBoxHeight","brBoxY"),c=r.arc,p=r.roundedRect,r.arc=u,r.roundedRect=x;}},optionsToObject:f}}),i(e,"Core/Responsive.js",[e["Core/Utilities.js"]],function(t){var e;let{diffObjects:i,extend:s,find:r,merge:o,pick:n,uniqueKey:a}=t;return function(t){function e(t,e){let i=t.condition;(i.callback||function(){return this.chartWidth<=n(i.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=n(i.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=n(i.minWidth,0)&&this.chartHeight>=n(i.minHeight,0)}).call(this)&&e.push(t._id);}function h(t,e){let s=this.options.responsive,n=this.currentResponsive,h=[],l;!e&&s&&s.rules&&s.rules.forEach(t=>{void 0===t._id&&(t._id=a()),this.matchResponsiveRule(t,h);},this);let d=o(...h.map(t=>r((s||{}).rules||[],e=>e._id===t)).map(t=>t&&t.chartOptions));d.isResponsiveOptions=!0,h=h.toString()||void 0;let c=n&&n.ruleIds;h===c||(n&&(this.currentResponsive=void 0,this.updatingResponsive=!0,this.update(n.undoOptions,t,!0),this.updatingResponsive=!1),h?((l=i(d,this.options,!0,this.collectionsWithUpdate)).isResponsiveOptions=!0,this.currentResponsive={ruleIds:h,mergedOptions:d,undoOptions:l},this.updatingResponsive||this.update(d,t,!0)):this.currentResponsive=void 0);}t.compose=function(t){let i=t.prototype;return i.matchResponsiveRule||s(i,{matchResponsiveRule:e,setResponsive:h}),t};}(e||(e={})),e}),i(e,"masters/highcharts.src.js",[e["Core/Globals.js"],e["Core/Utilities.js"],e["Core/Defaults.js"],e["Core/Animation/Fx.js"],e["Core/Animation/AnimationUtilities.js"],e["Core/Renderer/HTML/AST.js"],e["Core/Templating.js"],e["Core/Renderer/RendererRegistry.js"],e["Core/Renderer/RendererUtilities.js"],e["Core/Renderer/SVG/SVGElement.js"],e["Core/Renderer/SVG/SVGRenderer.js"],e["Core/Renderer/HTML/HTMLElement.js"],e["Core/Axis/Axis.js"],e["Core/Axis/DateTimeAxis.js"],e["Core/Axis/LogarithmicAxis.js"],e["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],e["Core/Axis/Tick.js"],e["Core/Tooltip.js"],e["Core/Series/Point.js"],e["Core/Pointer.js"],e["Core/Legend/Legend.js"],e["Core/Legend/LegendSymbol.js"],e["Core/Chart/Chart.js"],e["Extensions/ScrollablePlotArea.js"],e["Core/Axis/Stacking/StackingAxis.js"],e["Core/Axis/Stacking/StackItem.js"],e["Core/Series/Series.js"],e["Core/Series/SeriesRegistry.js"],e["Series/Column/ColumnDataLabel.js"],e["Series/Pie/PieDataLabel.js"],e["Core/Series/DataLabel.js"],e["Extensions/OverlappingDataLabels.js"],e["Extensions/BorderRadius.js"],e["Core/Responsive.js"],e["Core/Color/Color.js"],e["Core/Time.js"]],function(t,e,i,s,r,o,n,a,h,l,d,c,p,u,g,f,m,x,y,b,v,S,C,k,M,w,T,A,P,L,O,D,E,I,j,B){return t.AST=o,t.Axis=p,t.Chart=C,t.Color=j,t.DataLabel=O,t.Fx=s,t.HTMLElement=c,t.Legend=v,t.LegendSymbol=S,t.OverlappingDataLabels=t.OverlappingDataLabels||D,t.PlotLineOrBand=f,t.Point=y,t.Pointer=b,t.RendererRegistry=a,t.Series=T,t.SeriesRegistry=A,t.StackItem=w,t.SVGElement=l,t.SVGRenderer=d,t.Templating=n,t.Tick=m,t.Time=B,t.Tooltip=x,t.animate=r.animate,t.animObject=r.animObject,t.chart=C.chart,t.color=j.parse,t.dateFormat=n.dateFormat,t.defaultOptions=i.defaultOptions,t.distribute=h.distribute,t.format=n.format,t.getDeferredAnimation=r.getDeferredAnimation,t.getOptions=i.getOptions,t.numberFormat=n.numberFormat,t.seriesType=A.seriesType,t.setAnimation=r.setAnimation,t.setOptions=i.setOptions,t.stop=r.stop,t.time=i.defaultTime,t.timers=s.timers,E.compose(t.Series,t.SVGElement,t.SVGRenderer),P.compose(t.Series.types.column),O.compose(t.Series),u.compose(t.Axis),c.compose(t.SVGRenderer),v.compose(t.Chart),g.compose(t.Axis),D.compose(t.Chart),L.compose(t.Series.types.pie),f.compose(t.Chart,t.Axis),b.compose(t.Chart),I.compose(t.Chart),k.compose(t.Axis,t.Chart,t.Series),M.compose(t.Axis,t.Chart,t.Series),x.compose(t.Pointer),e.extend(t,e),t}),e["masters/highcharts.src.js"]._modules=e,e["masters/highcharts.src.js"]}); 
    } (highcharts));

    var highchartsExports = highcharts.exports;

    window.addEventListener('load', function () {
     highchartsExports.chartt('container', {
        chart: {
          type: 'column',
          events: {
            load: requestData
          }
        },
        title: {
          text: 'Monthly Sales Data'
        },
        yAxis: {
          minPadding: 0.2,
          maxPadding: 0.2,
          title: {
            text: 'Value',
            margin: 80,
          }
        },
        xAxis: {
          categories: ['Jan','Feb','March','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
        },
        series: [{
          name: 'Buy',
          data: [] 
        }, {
          name: 'Sell',
          data: []
        }]
      });;
    });;

})();
